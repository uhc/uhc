<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd"><html><head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><title>EHC examples</title></head><body><p>This page is intended to give an impression of the available features implemented  in each version of the series of EH compilers. A more elaborate description  can be found in the accompanying documentation.</p><h1>EH 1: lambda calculus</h1><p>The first version implements typed lambda calculus. For example, the following  EH program is accepted:</p><blockquote>  <pre>%%1srcfile(test/1-demo2.eh%%)</pre></blockquote><p>The compiler will, when invoked with the above source code give the followingannotated pretty printed output: </p><blockquote>  <pre>%%1ppfile(test/1-demo2.eh%%)</pre></blockquote><h1>EH 2: monomorphic type inference</h1><p>The second version implements type inference, but finds monomorphic types  only. The following program infers for id :: Int -&gt; Int: </p><blockquote>  <pre>%%2srcfile(test/2-demo1.eh%%)</pre></blockquote><p>Types may also be specified partially by means of a type wildcard, denotedby `...':</p><blockquote>  <pre>%%2srcfile(test/2-ty-wild.eh%%)</pre></blockquote><p>The type of a wildcard is filled in by the type inferencer, the compiler annotated  pretty printed version looks like:</p><blockquote>  <pre>%%2ppfile(test/2-ty-wild.eh%%)</pre></blockquote><h1>EH 3: polymorphic type inference</h1><p>The third version provides polymorphism a la Haskell (with Hindley-Milner  type inferencing): </p><blockquote>  <pre>%%3srcfile(test/3-all-ok.eh%%)</pre></blockquote><p>Polymorphism is inferred or specified explicitly (for polymorphic recursive  use). All bindings in a let expression are analysed together as a binding group. </p><h1>EH 4: forall and exists everywhere</h1><p>The fourth versions allows universal and existential quantifiers in a type,  at any position in the type. For example, universal quantification on a higher  ranked position can be specified explicitly: </p><blockquote>  <pre>%%4srcfile(test/4-demo3.eh%%)</pre></blockquote><p>The quantifier may be omitted. As a form of syntactic sugar the location ofthe quantifier is inferred: a universal quantifier for a type variable is placed  around the smallest arrowtype containing all occurrences of the type variable. </p><blockquote>  <pre>%%4srcfile(test/4-demo4.eh%%)</pre></blockquote><p>Existential types:</p><blockquote>  <pre>%%4srcfile(test/4-demo1.eh%%)</pre></blockquote><h1>EH 5: data types</h1><p>No surprises here:</p><blockquote>  <pre>%%5srcfile(test/5-list.eh%%) </pre></blockquote><h1>EH 6: kind inference</h1><p>Kind polymorphism, explicitly specified:</p><blockquote>  <pre>%%6srcfile(test/5-all-ok2.eh%%)</pre></blockquote><p>or inferred:</p><blockquote>  <pre>%%6srcfile(test/6-expl-ki.eh%%)  </pre></blockquote><h1>EH 7: non extensible records</h1><p>Records with notation for extension, update and selection. Support  for extensible records (that is, independence of labels across argument passing  to functions) is included in version 10.</p><blockquote>  <pre>%%7srcfile(test/7-demo1.eh%%)  </pre></blockquote><h1>EH 8: code generation</h1><p>Code generation for an extended version of <a href="http://www.cs.chalmers.se/%7Eboquist/phd/index.html">GRIN</a>.FFI is supported, but only as much as is required for testing. A rudimentary  GRIN interpreter (gri) can be used for testing.</p><blockquote>  <pre>%%8srcfile(test/8-sum.eh%%)  </pre></blockquote><p>Grin output:</p><blockquote>  <pre>%%8grinfile(test/8-sum.eh%%)  </pre></blockquote><h1>EH 9: explicit implicitness, classes</h1><p>Explicit construction and passing of dictionary:</p><blockquote>  <pre>%%9srcfile(test/9-eq-nub.eh%%)  </pre></blockquote><p>Higher order predicates:</p><blockquote>  <pre>%%9srcfile(test/9-snd-order1.eh%%)  </pre></blockquote><h1>EH 10: extensible records</h1><p>Polymorphic (in remaining labels) access to fields:</p><blockquote>  <pre>%%10srcfile(test/10-demo1.eh%%)  </pre></blockquote><p>Tuple access, but independent of tuple arity: </p><blockquote>  <pre>%%10srcfile(test/10-snd.eh%%)  </pre></blockquote><h1>&nbsp;</h1></body></html>