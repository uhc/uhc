%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

Pass all free variables of let bound lambda expressions explicitly.
Later, these expressions can then be lifted globally.


For example:
f is a let-bound lambda expression that uses a (more) global variable g

   let g = ...            
in let f = \x -> ...g...  
in ...f...

The transformation introduces an additional formal parameter e to the lambda expression
and passes the global variable g as an actual parameter to all uses of f:

   let g = ...            
in let f = \e x -> ...e...  
in ...f g...




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Globals as args
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.LamGlobalAsArg} import(EH.Util.Utils,Data.Maybe,qualified Data.Set as Set,Data.List,qualified Data.Map as Map,{%{EH}Base.Common},{%{EH}Core},{%{EH}Ty}) export(cmodTrfLamGlobalAsArg)
%%]

%%[(8 codegen) hs import({%{EH}Core.Utils})
%%]

-- for debug
%%[(8 codegen) hs import({%{EH}Base.Debug},EH.Util.Pretty)
%%]
%%[(8 codegen) hs import(Debug.Trace)
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn},{Core/CommonLev},{Core/Trf/CommonFv},{Core/Trf/CommonLev},{Core/Trf/CommonGlobalAsArg})
WRAPPER CodeAGItf
%%]

We have cycles, but they are there by design:

*** UU.AG warning  ***
problem  : Direct circular dependency pattern for inherited attribute levMp
            and synthesized attribute levOfMp of nonterminal CBindL
pattern  : see help
help     : The following attributes formed the cycle:
           CExpr.Let, inherited attribute binds.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 9, column 35))
           CBindL.Cons, inherited attribute lhs.levMp
           CBindL.Cons, inherited attribute hd.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CBind.Bind, inherited attribute lhs.levMp
           CBind.Bind, inherited attribute expr.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.App, inherited attribute lhs.levMp
           CExpr.App, inherited attribute arg.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.Case, inherited attribute lhs.levMp
           CExpr.Case, inherited attribute dflt.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.HoleLet, inherited attribute lhs.levMp
           CExpr.HoleLet, inherited attribute body.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.ImplsApp, inherited attribute lhs.levMp
           CExpr.ImplsApp, inherited attribute func.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.ImplsLam, inherited attribute lhs.levMp
           CExpr.ImplsLam, inherited attribute body.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 1, column 18))
           CExpr.Lam, inherited attribute lhs.levMp
           CExpr.Lam, local attribute levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 45, column 33))
           CExpr.Lam, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CExpr.ImplsLam, synthesized attribute body.levOf
           CExpr.ImplsLam, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CExpr.ImplsApp, synthesized attribute func.levOf
           CExpr.ImplsApp, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CExpr.HoleLet, synthesized attribute body.levOf
           CExpr.HoleLet, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CExpr.Case, synthesized attribute dflt.levOf
           CExpr.Case, local attribute levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 41, column 33))
           CExpr.Case, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CExpr.App, synthesized attribute arg.levOf
           CExpr.App, local attribute levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 40, column 33))
           CExpr.App, synthesized attribute lhs.levOf ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 36, column 22))
           CBind.Bind, synthesized attribute expr.levOf
           CBind.Bind, synthesized attribute lhs.levOfMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 54, column 33))
           CBindL.Cons, synthesized attribute hd.levOfMp
           CBindL.Cons, synthesized attribute lhs.levOfMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 51, column 20))
           CExpr.Let, synthesized attribute binds.levOfMp
           CExpr.Let, inherited attribute binds.levMp ("build/9/lib-ehc/EH9//Core/Trf/CommonLev.ag"(line 9, column 35))

%%[(9 codegen)
PRAGMA nocycle
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
cmodTrfLamGlobalAsArg :: CModule -> CModule
cmodTrfLamGlobalAsArg cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf)
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: Int | ]

SEM CodeAGItf
  | AGItf       module      .   gUniq       =   0

SEM CBind
  | Bind        expr        .   gUniq       =   @lhs.gUniq + Map.size @argMpNew

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Free var of lams for which arg lifting is done
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ fvSLamMp: FvSMp | | ]

SEM CodeAGItf
  | AGItf       module      .   fvSLamMp    =   Map.empty

SEM CExpr
  | Let         loc         .   fvSLamMp    =   (let  start varS = fvsClosure @binds.bindLamS @lhs.lamS varS @lhs.fvSLamMp @binds.fvSMp
                                                 in   case @categ of
                                                        CBindings_Rec
                                                          ->  fvsTransClosure lm m
                                                          where (m,lm)  = start (@lhs.varS `Set.union` @binds.bindVarS)
                                                        _ ->  m
                                                          where (m,_)   = start @lhs.varS
                                                )
                                                `Map.union` @lhs.fvSLamMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Mapping of argument names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ argMp: CVarReplNmMp | | ]

SEM CodeAGItf
  | AGItf       module      .   argMp       =   Map.empty

SEM CBind
  | Bind        expr        .   argMp       =   @argMpNew `Map.union` @lhs.argMp
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adding parameters to lam call sites
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type LamArgMp = Map.Map HsName CVarIntroL
%%]

%%[(8 codegen)
ATTR AllBind CExpr [ | | bindLamArgMp USE {`Map.union`} {Map.empty}: LamArgMp ]
ATTR AllCodeNT [ lamArgMp: LamArgMp | | ]

SEM CodeAGItf
  | AGItf       module      .   lamArgMp    =   Map.empty

SEM CExpr
  | Let         loc         .   lamArgMp    =   @binds.bindLamArgMp `Map.union` @lhs.lamArgMp
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Finding instance annotations
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
ATTR CMetaVal CMetas [ bindLamArgMp: LamArgMp | | isInstance: {Bool} ]

SEM CMetaVal
  | DictInstance    lhs.isInstance = True
  | *-DictInstance  lhs.isInstance = False

SEM CExpr
  | Lam			argMeta		.	bindLamArgMp=	Map.empty
%%]]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]

SEM CBind
  | Bind        loc         .   (argNewL,argMpNew,bindLamArgMp)
                                            =   if {- @isLiftable && @lhs.lev /= cLevModule -} @expr.isLam
                                                then  let  argLevL = fvLAsArg @lhs.introCVarIntroMp $ panicJust "LamGlobalAsArg.CBind.Bind.argLevL" $ Map.lookup @nm $ @lhs.fvSLamMp
                                                           (argOL,argNL,argONMp) = fvLArgRepl @lhs.gUniq $ argLevL
                                                      in   (argNL, argONMp, @nm `Map.singleton` argOL)
                                                else  ([],Map.empty, Map.empty)
%%]


%%[(8 codegen)
SEM CBind
%%[[8
  | Bind        lhs         .   cTrf        =   mkCBind1 @nm $ mkCExprLam (assocLKeys @argNewL) @expr.cTrf
%%][9
  | Bind        lhs         .   cTrf        =   --trace ("use of global: " ++ show @nm ++ " uses " ++ show @bindLamArgMp ++ "\n"
                                                --      ++ (if @bindMeta.isInstance then ("instance " ++ show @nm ++ " finds " ++ show @expr.bindLamArgMp ++ "\n") else "")
                                                --      ) $
                                                (mkCBind1Metas @nm @bindMeta.cTrf $ mkCExprLamMeta [(n,cviMeta cvi) | (n,cvi) <- @argNewL] @expr.cTrf)
                bindMeta    . bindLamArgMp  =  @expr.bindLamArgMp
%%]]
%%]


%%[(8 codegen)

ATTR CExpr [ | | mbBodyVar : {Maybe HsName} ]

SEM CExpr
  | Let         lhs.mbBodyVar  =  @body.mbBodyVar   
  | Var         lhs.mbBodyVar  =  Just @nm
  | *-Let Var Ann
  				lhs.mbBodyVar  =  Nothing

%%]

%%[(9 codegen)
ATTR CMetaVal CMetas [ mbBodyVar : {Maybe HsName} | | ]

SEM CBind
  | Bind   bindMeta.mbBodyVar = @expr.mbBodyVar

SEM CExpr
  | Lam			argMeta		.	mbBodyVar	=	Nothing
%%]]



%%[(8 codegen)

SEM CExpr
  | Var         lhs         .   cTrf        =   let  r n = fvVarRepl @lhs.argMp n
                                                     v1 = r @nm
%%[[8
                                                     mk as = mkCExprApp v1 $ [r a | (a,_) <- as]
%%][9
                                                     mk as = mkCExprAppMeta v1 $ [(r a,cviMeta cvi) | (a,cvi) <- as]
%%]]
                                                     v2 = maybe v1 mk $ Map.lookup @nm $ @lhs.lamArgMp
                                                in   v2
%%]


%%[(8 codegen)

{

metaExtend :: LamArgMp -> Maybe HsName -> [HsName] -> [HsName]

metaExtend mp self []       = []
metaExtend mp self (nm:nms) = let r = Map.lookup nm mp
                                  e = maybe [] assocLKeys r
                                  e2 = maybe e (\s -> filter (/=s) e) self
                              in  -- trace (show nm ++ " extended with " ++ show e2 ) $
                                  (nm : (e2 ++ nms))

  
}

%%[[9
SEM CMetaVal
  |  DictInstance   lhs.cTrf = CMetaVal_DictInstance (map (metaExtend @lhs.bindLamArgMp  @lhs.mbBodyVar) @names)
%%]]
%%]

