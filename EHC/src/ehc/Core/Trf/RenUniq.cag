%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Simplify code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs module {%{EH}Core.Trf.RenUniq} import(Data.Maybe,Data.Char,Control.Monad(liftM),qualified Data.Map as Map)
%%]

%%[(8 codegen) hs import({%{EH}Base.Common},{%{EH}Base.Builtin},{%{EH}Core},{%{EH}Ty})
%%]

%%[(8 codegen).WRAPPER ag import({Core/AbsSyn})
WRAPPER CodeAGItf
%%]

%%[(99 codegen)
PRAGMA strictcase
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Haskell itf
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs export(cmodTrfRenUniq)
cmodTrfRenUniq :: CModule -> CModule
cmodTrfRenUniq cmod
  =  let  t = wrap_CodeAGItf  (sem_CodeAGItf (CodeAGItf_AGItf cmod))
                              (Inh_CodeAGItf {gUniq_Inh_CodeAGItf = uidStart})
     in   cTrf_Syn_CodeAGItf t
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | gUniq: UID | ]
ATTR CodeAGItf [ gUniq: UID | | ]

SEM CExpr
  | Let         (binds.gUniq,loc.lUniq)     =   mkNewLevUID  @lhs.gUniq
  | Lam         (body.gUniq,loc.lUniq)      =   mkNewUID     @lhs.gUniq

SEM CAlt
  | Alt         (pat.gUniq,loc.lUniq)       =   mkNewLevUID  @lhs.gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Module name used to uniqify globally over all modules
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 codegen)
ATTR AllExpr [ moduleNm: HsName | | ]

SEM CModule
  | Mod         expr        .   moduleNm    =   @moduleNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Transformation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllCodeNT [ | | cTrf: SELF ]
ATTR CodeAGItf [ | | cTrf: CModule ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% alpha renaming so all identifiers are unique
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
type ARenMp = Map.Map HsName HsName
%%]

%%[(8 codegen) hs
-- breaks assumption that globals are qualified, locals not. Problem in future when records are used for globals and access differs.
mkUniq :: HsName -> HsName -> UID -> HsName
mkUniq q n u
  = 
%%[[20
    (if hsnIsQual n
     then id
     else hsnSetQual q
    ) $ 
%%]]
    hsnUniqifyUID HsNameUniqifier_GloballyUnique u n
%%]

%%[(8 codegen) hs
%%[[8
aRenAdd :: Bool -> [HsName] -> UID -> ARenMp -> ARenMp
aRenAdd isGlob nL u m
%%][20
aRenAdd :: Bool -> HsName -> [HsName] -> UID -> ARenMp -> ARenMp
aRenAdd isGlob q nL u m
%%]]
  = Map.fromList [ (n,mkNm n u) | (n,u) <- zip nL uL ] `Map.union` m
  where uL = mkNewUIDL (length nL) u
        doChngNm n = not isGlob || n `Map.member` m
        mkNm n u = if doChngNm n
%%[[8
                   then mkUniq hsnUnknown n u
%%][20
                   then mkUniq q n u
%%]]
                   else n
%%]

%%[(8 codegen) hs
aRenRepl :: ARenMp -> HsName -> HsName
aRenRepl m n = maybe n id . Map.lookup n $ m
%%]



%%[(8 codegen)
ATTR AllCodeNT [ aRenMp: ARenMp  lev: Int | | ]
ATTR AllBind AllPat [ | | nmL USE {++} {[]}: {[HsName]} ]
%%]

%%[(9 codegen)
ATTR CExpr 
     AllAlt 
     AllBind    [ protectedBindingNames : {[HsName]} | | ]
ATTR AllMetaVal [ | | protectableBindingNames : {[HsName]} ]
%%]

%%[(8 codegen)
SEM CodeAGItf
  | AGItf       module      .   aRenMp      =   Map.empty
                            .   lev         =   cLevModule
SEM CBind
%%[[8
  | Bind        lhs         .   nmL         =   [@nm]
%%][9
  | Bind        lhs         .   nmL         =   if   @nm `elem` @lhs.protectedBindingNames
                                                then []
                                                else [@nm]
%%]]

SEM CPatBind
  | Bind        lhs         .   nmL         =   [@nm] ++ @pat.nmL

SEM CPat
  | Var Con     loc         .   nm          =   @pnm
                loc         .   nm          :   {HsName}
  | Var         lhs         .   nmL         =   [@nm]
  | Con         lhs         .   nmL         =   [@nm] ++ @rest.nmL ++ @binds.nmL

SEM CPatRest
  | Var         lhs         .   nmL         =   [@nm]

SEM CExpr
  | Let         loc         .   aRenMp      =   aRenAdd (@lhs.lev == cLevModule) @binds.nmL @lUniq @lhs.aRenMp
                binds       .   lev         =   @lhs.lev + 1
  | Lam         loc         .   aRenMp      =   aRenAdd False [@arg] @lUniq @lhs.aRenMp
                body        .   lev         =   if @body.isLamBody then @lhs.lev + 1 else @lhs.lev

SEM CAlt
  | Alt         loc         .   aRenMp      =   aRenAdd False @pat.nmL @lUniq @lhs.aRenMp
                expr        .   lev         =   @lhs.lev + 1
%%]

%%[(20 codegen)
SEM CExpr
  | Let         loc         .   aRenMp      :=  aRenAdd (@lhs.lev == cLevModule) @lhs.moduleNm @binds.nmL @lUniq @lhs.aRenMp
  | Lam         loc         .   aRenMp      :=  aRenAdd False @lhs.moduleNm [@arg] @lUniq @lhs.aRenMp

SEM CAlt
  | Alt         loc         .   aRenMp      :=  aRenAdd False @lhs.moduleNm @pat.nmL @lUniq @lhs.aRenMp
%%]

%%[(8 codegen)
ATTR CExpr [ | | isLamBody: Bool ]

SEM CExpr
  | Lam         lhs         .   isLamBody   =   False
  | * - Lam Ann lhs         .   isLamBody   =   True
%%]

%%[(8 codegen)
SEM CExpr
  | Var         lhs         .   cTrf        =   CExpr_Var (aRenRepl @lhs.aRenMp @nm)
  | Lam         lhs         .   cTrf        =   CExpr_Lam (aRenRepl @aRenMp @arg) @argMeta.cTrf @body.cTrf

SEM CBind
  | Bind        lhs         .   cTrf        =   CBind_Bind (aRenRepl @lhs.aRenMp @nm) @bindMeta.cTrf @expr.cTrf

SEM CPatBind
  | Bind        lhs         .   cTrf        =   CPatBind_Bind @lbl @offset.cTrf (aRenRepl @lhs.aRenMp @nm) @pat.cTrf

SEM CPat
  | Var         lhs         .   cTrf        =   CPat_Var (aRenRepl @lhs.aRenMp $ @nm)
  | Con         lhs         .   cTrf        =   CPat_Con (aRenRepl @lhs.aRenMp $ @nm) @tag @rest.cTrf @binds.cTrf

SEM CPatRest
  | Var         lhs         .   cTrf        =   CPatRest_Var (aRenRepl @lhs.aRenMp @nm)
  
%%]


%%[(9 codegen)
SEM CBind
  | Bind        expr.protectedBindingNames  =   @bindMeta.protectableBindingNames ++ @lhs.protectedBindingNames

SEM CMetaVal
  | DictClass   lhs.protectableBindingNames   =   [ nm  | Just nm <- @names ]
  | DictInstance lhs.protectableBindingNames   =  concat @names
  | Dict         lhs.protectableBindingNames  =   []
  | Val          lhs.protectableBindingNames   =   []
  
SEM CModule
  | Mod          expr.protectedBindingNames  =   []

SEM CPatBind
  | Bind         offset.protectedBindingNames  =   []
%%]
