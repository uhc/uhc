%%[(9 codegen grin) ag import({GrinCode/AbsSyn})
%%]

%%[(9 codegen grin).wrapper
WRAPPER GrAGItf
%%]

%%[(9 codegen grin) hs module {%{EH}GrinCode.Trf.MergeInstance} import(qualified Data.Map as Map)
%%]
%%[(9 codegen grin) hs import(Debug.Trace)
%%]


%%[(9 codegen grin) hs import({%{EH}Base.Common}, {%{EH}Base.Builtin}, {%{EH}GrinCode.Common}, {%{EH}GrinCode}) export(mergeInstance)

mergeInstance :: GrModule -> GrModule
mergeInstance code
  = let inh = Inh_GrAGItf
        syn = wrap_GrAGItf (sem_GrAGItf (GrAGItf_AGItf code)) inh
    in  grTrf_Syn_GrAGItf syn

%%]

%%[(9 codegen grin)
ATTR GrAGItf [ | | grTrf: GrModule ]
ATTR AllNT   [ | | grTrf: SELF     ]
%%]


%%[(9 codegen grin) hs

type ClassMap = Map.Map HsName [Maybe HsName]
type DictMap  = Map.Map HsName [[HsName]]
type ArityMap = Map.Map HsName (Int, [[Int]])
type SynoMap  = Map.Map HsName HsName

%%]


%%[(9 codegen grin)

ATTR AllBind [ 
             | 
             | collectClassMap USE {`Map.union`} {Map.empty} : {ClassMap} 
               collectArityMap USE {`Map.union`} {Map.empty} : {ArityMap} 
               collectDictMap  USE {`Map.union`} {Map.empty} : {DictMap}
               newBinds        USE {++}          {[]}        : GrBindL
             ]
              
ATTR AllGlobal [ dictMap  :  {DictMap}
                 classMap :  {ClassMap}
                 arityMap :  {ArityMap}
               | 
               | collectSynoMap USE {`Map.union`} {Map.empty} : {SynoMap}
               ]

ATTR GrTag GrVal [ | | mbFunNm : {Maybe HsName} ]


SEM GrModule
  | Mod    globalL.dictMap  = Map.mapKeys (\k -> (Map.findWithDefault (error ("MergeInstance: no synonym for" ++ show k ++ " in " ++ show @globalL.collectSynoMap)) k @globalL.collectSynoMap)) @bindL.collectDictMap 
           globalL.classMap = @bindL.collectClassMap
           globalL.arityMap = @bindL.collectArityMap


SEM GrBind
  | Bind    lhs.collectClassMap  =  case @annot of
                                      GrBindAnnClass xs -> Map.singleton @nm xs
                                      _                 -> Map.empty
            lhs.collectArityMap  =  case @annot of
                                      GrBindAnnOverloaded xs -> Map.singleton @nm (length @argNmL - length xs, xs )
                                      GrBindAnnClass _       -> Map.empty
                                      GrBindAnnInstance _    -> Map.empty
                                      _                      -> Map.singleton @nm (length @argNmL            , [] )



SEM GrBind
  | Bind    (lhs.newBinds
            ,lhs.collectDictMap)  =  case @annot of
                                           GrBindAnnInstance xs  -> case @argNmL of
                                                                      [] -> ([], Map.singleton @nm xs)
                                                                      _  -> ([@loc.grTrf], Map.empty)
                                           _                     -> ([@loc.grTrf], Map.empty)
  | Rec     lhs.newBinds = [GrBind_Rec @bindL.grTrf]

SEM GrBindL
  | Nil     lhs.grTrf = []
  | Cons    lhs.grTrf = @hd.newBinds ++ @tl.grTrf

SEM GrGlobal
  | Global  lhs.collectSynoMap  =  maybe Map.empty
                                         (\nm2 -> Map.singleton nm2 @nm)
                                         @val.mbFunNm                             

SEM GrTag
  | Fun     lhs.mbFunNm  =  Just @nm
  | *-Fun   lhs.mbFunNm  =  Nothing

SEM GrVal
  | Node    lhs.mbFunNm  =  if    null @fldL.grTrf
                            then  @tag.mbFunNm
                            else  Nothing
  | *-Node  lhs.mbFunNm  =  Nothing


SEM GrGlobalL
  | Cons     lhs.grTrf  =  case @hd.grTrf of
                             GrGlobal_Global nm1 (GrVal_Node (GrTag_Fun nm2) []) 
                                -> maybe @loc.grTrf
                                         (\([tagNm] : [classNm] : funDefs)
                                             ->                let dfltDefs = Map.findWithDefault (error "class not found") classNm @lhs.classMap
                                                                   arity  = length funDefs
                                                                   tagAnn = GrTagAnn arity arity
                                                                   tag    = GrTag_Con tagAnn 0 tagNm
                                                                   pairs  = mergeFields @lhs.dictMap @lhs.arityMap nm1 funDefs dfltDefs
                                                                   fields = [ v | (v, _     ) <- pairs ]
                                                                   globs  = [ g | (_, Just g) <- pairs ]
                                                                   value  = GrVal_Node tag fields
                                                                   glob   = GrGlobal_Global nm1 value
                                                               in  ( globs ++ [glob] ++ @tl.grTrf)
                                         )
                                         (Map.lookup nm1 @lhs.dictMap)                 
                             _ -> @loc.grTrf



%%]

%%[(9 codegen grin) hs

mergeFields :: DictMap -> ArityMap -> HsName -> [[HsName]] -> [Maybe HsName] -> [(GrVal, Maybe GrGlobal)]
mergeFields    dictMap    am          i         fundefs       defltdefs      =  zipWith3 (mergeField dictMap fundefs am i) [0..] fundefs defltdefs

mergeField :: DictMap -> [[HsName]] -> ArityMap -> HsName -> Int -> [HsName] -> Maybe HsName -> (GrVal, Maybe GrGlobal)
mergeField dictMap fundefs am nm k (v:vs)   _        = makeGlobal dictMap fundefs am nm k (v:vs)
mergeField dictMap fundefs am nm k _        (Just v) = makeGlobal dictMap fundefs am nm k [v]
mergeField dictMap fundefs am nm k _        Nothing  = (GrVal_Var hsnUndefined, Nothing)

makeGlobal :: DictMap -> [[HsName]] -> ArityMap -> HsName -> Int -> [HsName] -> (GrVal, Maybe GrGlobal)
makeGlobal dictMap fundefs am nm k (v:vs) 
   = case Map.lookup v am of
                        Nothing      -> (GrVal_Var v, Nothing)
                        Just (a,dss) -> let a2   = a - length vs
                                            tag  = GrTag_PApp a2 v
                                            args = map f dss
                                            f ds = selectField dictMap fundefs nm ds
                                            node = GrVal_Node tag (map GrVal_Var vs ++ args)
                                            name = hsnUniqifyStr HsNameUniqifier_GloballyUniqueDict (show k) nm -- hsnSuffix nm ('~':show k)
                                        in  (GrVal_Var name, Just (GrGlobal_Global name node))

selectField :: DictMap -> [[HsName]] -> HsName -> [Int] -> GrVal
selectField dictMap fundefs nm []     =  GrVal_Var nm
selectField dictMap fundefs nm (x:xs) =  let (a:_) = fundefs!!x
                                             b = Map.findWithDefault (error ("not found: " ++ show a ++ " being " ++ show x ++ " from " ++ show fundefs )) a dictMap
                                         in selectField dictMap (drop 2 b) a xs

%%]
