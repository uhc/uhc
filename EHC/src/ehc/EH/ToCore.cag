%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is main body 'main'?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).mainUseExists
SEM AGItf
  | AGItf       loc         .   mainUseExists
                                            =   case @expr.letCBody of
                                                  CExpr_Var n | n == hsnMain -> True
                                                  _                          -> False
                            .   insertMainUse
                                            =   not @mainUseExists
%%]

%%[(20 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainUse
                                            :=  not @mainUseExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Does a binding for main exist?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen).mainDefExists
SEM AGItf
  | AGItf       loc         .   mainDefExists
                                            =   let ds = [ b | (_,g) <- @expr.letCBindL, b <- g, cbindNm b == hsnMain ]
                                                in  not (null ds)
                            .   insertMainDef
                                            =   not @mainDefExists
%%]

%%[(20 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainDef
                                            :=  not @mainDefExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AGItf [ | | cmodule: CModule ]

SEM AGItf
  | AGItf       lhs         .   cmodule     =   let b = if @insertMainUse then CExpr_Var hsnMain else @expr.letCBody
                                                    d = if @insertMainDef then mkCExprLet CBindings_Plain [mkCBind1 hsnMain @expr.letCBody] else id
                                                in  CModule_Mod @lhs.moduleNm
                                                        (
%%[[9
                                                           cSubstAppExpr True @expr.cSubst
%%]]
                                                           (foldr (\(c,b) e -> mkCExprLet c b e)
                                                             (d b)
                                                             (@extraCBindL ++ @expr.frontCBindL ++ @expr.letCBindL
%%[[94
                                                             ++ @expr.backCBindL
%%]]
                                                             )
                                                           )
%%[[9
                                                           Nothing
%%]]
                                                        )
                                                        [ (tn,Map.toList m) | (tn,dgi) <- gamToAssocL @expr.gathDataGam, not (dgiIsNewtype dgi), let m = Map.map dtiCTag $ dgiConstrTagMp dgi ]
                loc         .   extraCBindL =   []
%%]

%%[(9 codegen)
SEM AGItf
  | AGItf       loc         .   extraCBindL :=  [(CBindings_Rec,@chrScopeMainBindL)]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Uniq's for Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | IConst CConst SConst Var Con
    App AppImpred AppTop Rec TypeAs
    Lam Let
%%[[12
    AppImpl
    LamImpl
%%]]
%%[[97
    IIConst
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   cexpr       =   CExpr_Int  @int
  | CConst      loc         .   cexpr       =   CExpr_Char @char
  | Var         loc         .   cexpr       =   CExpr_Var  @nm
  | Con         loc         .   cexpr       =   CExpr_Var  @nm
%%[(8 codegen)
ATTR Expr [ | | cexpr: CExpr ]

SEM Expr
  | Ann         loc         .   cexpr       =   @expr.cexpr
  | Let         loc         .   frontCBindL =   [(CBindings_FFI,@decls.ffiCBindL)]
%%[[94
                            .   backCBindL  =   [(CBindings_FFE,@decls.ffeCBindL)]
%%]]
                            .   howToBind   =   if @isStrict then CBindings_Strict else CBindings_Rec
                            .   letCBindL   =   [(@howToBind,@decls.cbindL)]
                            .   letCBindOtherL
                                            =   []
                            .   cexprtop    =   foldr (\(c,b) e -> mkCExprLet c b e) @letCBody @letCBindRemL
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   cexprapp    =   mkCExprApp1 @func.cexpr @arg.cexpr
                            .   cexpr       =   if @func.isNewtype then @arg.cexpr else @cexprapp
  | Lam         loc         .   cexpr       =   mkCExprLam1 @arg.topNm
                                                    (rceMatch @rceEnv [@arg.topNm] [RAlt_Alt [@arg.rpat] @body.cexpr @body.caseFailS])
  | Case        loc         .   cexpr       =   let (ns,bs,as)
                                                      = if @isTupOfArg
                                                        then let ns = [ n | (CExpr_Var n) <- fuL2ExprL (reverse @expr.fuCExprL) ]
                                                             in  (ns,[],@alts.raltL')
                                                        else let n = uidHNm @lUniq2
                                                             in  ([n],[mkCBind1 n @expr.cexpr],@alts.raltL)
                                                in  mkCExprLet CBindings_Plain bs (rceMatch @rceEnv ns as)
  | AppTop      loc         .   cexprtop    =   @expr.cexpr
  | Rec         loc         .   cexprtop    =   @rcexpr
  | Parens TypeAs
                loc         .   cexpr       =   @expr.cexpr
  | AppTop Rec Let
                loc         .   cexpr       =   @cexprtop
  | Undefined   loc         .   cexpr       =   cundefined @lhs.opts
  | CaseAltFail loc         .   cexpr       =   CExpr_CaseAltFail @caseId (cerror @lhs.opts ("FAIL " ++ show @caseId))
%%]

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   cexprBase   :=  CExpr_Int @int
  | CConst      loc         .   cexprBase   :=  CExpr_Char @char
  | Var         loc         .   cexprBase   :=  CExpr_Var @nm
  | Var IConst CConst
                loc         .   cexpr       :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase
  | Con         loc         .   cexprBase   :=  CExpr_Var @nm
                            .   cexpr       :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase

-- between variant 5 .. 99, reconstruction of AG rules, getting rid of ruler3 until Arie's ruler4 can be used
%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst      loc         .   cexprBase   =   CExpr_Int @int
  | CConst      loc         .   cexprBase   =   CExpr_Char @char
  | SConst      loc         .   cexprBase   =   cstring @lhs.opts @str
%%[[97
  | IIConst     loc         .   cexprBase   =   cinteger @lhs.opts @integer
%%]]
  | Var Con     loc         .   cexprBase   =   CExpr_Var @nm
%%]

%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
%%[[8
                loc         .   cexpr       =   @cexprBase
%%][9
                loc         .   (cexpr,cexprCSubst)
                                            =   foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @lhs.cSubst @cexprBase
                lhs         .   cSubst      =   cSubstApp @lhs.cSubst @cexprCSubst
%%]]
%%]

%%[(9 codegen)
SEM Expr
  | Let         loc         .   letCBindOtherL
                                            :=  [ (CBindings_Rec,@chrScopeBindL) ]
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (cexprapp,cexprappCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    -- ww    = coeWipeWeave @lhs.opts @lhs.finTyVarMp @arg.cSubst @appImplsCoeL []
                                                    (ww,s1)   = coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @arg.cSubst @appImplsCoeL []
                                                    (f ,s2)   = coeEvalOnAsSubst u2 ww @func.cexpr
                                                in  (mkCExprApp1 f @arg.cexpr, s1 `cSubstApp` s2)
                lhs         .   cSubst      =   cSubstApp @arg.cSubst @cexprappCSubst
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   (cexpr,cexprlamCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @body.cSubst @lamBodyCoeL @lamArgCoeL
                                                    (b ,s2)   = coeEvalOnAsSubst u2 ww @body.appFunCExpr
                                                in  (b, s1 `cSubstApp` s2)
                lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprlamCSubst
  | AppTop      loc         .   cSubstTop   =   @expr.cSubst
  | Rec         loc         .   cSubstTop   =   @recExpr.cSubst
  | Let         loc         .   cSubstTop   =   @body.cSubst
  | AppTop Rec Let
                loc         .   (cexpr,cexprapptopCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @cSubstTop [] @lamArgCoeL
                                                    (e ,s2)   = coeEvalOnAsSubst u2 ww @cexprtop
                                                in  (@cann e, s1 `cSubstApp` s2)
  | AppTop      lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprapptopCSubst
  | Rec         lhs         .   cSubst      =   cSubstApp @recExpr.cSubst @cexprapptopCSubst
  | Let         lhs         .   cSubst      =   cSubstApp @body.cSubst @cexprapptopCSubst
  | TypeAs      loc         .   (cexpr,cexprtypeasCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (e1,s1)   = foAppLRCoeAsSubst @lhs.opts u1 @fo_fitDown @lhs.finTyVarMp @expr.cSubst @expr.cexpr
                                                    (e2,s2)   = foAppLRCoeAsSubst @lhs.opts u2 @fo_        @lhs.finTyVarMp @expr.cSubst e1
                                                in  (e2, s1 `cSubstApp` s2)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprtypeasCSubst
%%]

%%[(10 codegen)
SEM Expr
  | DynVar      loc         .   cexpr       =   cundefined @lhs.opts
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   cexprBaseEq =   CExpr_Var @eqFldNm
                            .   (cexpr,cexprpatCSubst)
                                            =   let (e,s) = foAppLRCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @expr.cSubst @cexprBaseEq
                                                in  (mkCExprApp e [@expr.cexpr], s)
                lhs         .   cSubst      =   cSubstApp @expr.cSubst @cexprpatCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Annotation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
%%[[8
  | *           loc         .   cann		=   id
%%][97
  | AppTop      loc         .   cann		=   CExpr_Ann (CExprAnn_Ty @finalTyExpanded)
  | * - AppTop  loc         .   cann		=   id
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | Rec         loc         .   rcexpr          =   
%%[[10  
                                                    if  not (@recExpr.isExtFromEmpty)
                                                    then  fuMkCExpr @lhs.opts @lUniq3 (reverse @recExpr.fuCExprL) @recExpr.recCExpr
                                                    else
%%]]                                                    
                                                          foldl mkCExprApp1 (CExpr_Tup CTagRec)
                                                            $ fuL2ExprL $ tyRowCanonOrder $ @recExpr.fuCExprL
%%[[10
                loc         .   lUniq3          :   UNIQUEREF gUniq
%%]]
%%]

%%[(8 codegen)
ATTR RecExpr [ | | recCExpr: CExpr ]
ATTR RecExpr Expr [ | | fuCExprL: {FieldUpdateL CExpr} ]

SEM RecExpr
  | Empty       loc         .   recCExpr        =   CExpr_Tup CTagRec
                lhs         .   fuCExprL        =   []
  | Expr        loc         .   recCExpr        =   @expr.cexpr
                lhs         .   fuCExprL        =   []
  | Ext         loc         .   rcexpr          =   CExpr_TupIns @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Upd         loc         .   rcexpr          =   CExpr_TupUpd @recExpr.recCExpr CTagRec @nm @offset @expr.cexpr
  | Ext Upd     lhs         .   fuCExprL        =   if @knRecHasLab
                                                    then (@nm,(@rcexpr,Nothing)) : @recExpr.fuCExprL
                                                    else @recExpr.fuCExprL

SEM Expr
  | * - Rec     lhs         .   fuCExprL        =   []
%%]

%%[(8 codegen)
ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty
%%]

%%[(8 codegen)
SEM RecExpr
  | Ext Upd     loc         .   offset          =   CExpr_Int (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recExpr.ty)
%%]

%%[(10 codegen)
SEM RecExpr
  | Ext Upd     loc         .   offset          :=  cSubstApp @expr.cSubst $ mkCExprPrHole @lhs.opts @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | DataFields  loc         .   dfexpr      =   let mkTup dti mkDflt con
                                                      = foldl mkCExprApp1 con
                                                        . fuL2ExprL
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr" ("arity" >#< length dflt) v)
                                                        . listSaturateWith 0 (ctagArity (dtiCTag dti) - 1) (\(_,(_,Just o)) -> o) dflt
                                                        -- . (\v -> v `seq` tr "Expr.DataFields.dfexpr2" ("arity" >#< length dflt) v)
                                                        . fuMap (\l mke -> let o = dtiOffsetOfFld l dti in (mke dti o,o))
                                                      where dflt = [ (o,(f,(CExpr_TupIns (cundefined @lhs.opts) (dtiCTag dti) f (CExpr_Int o) (mkDflt f),Just o)))
                                                                   | (f,i) <- Map.toList $ dtiFldMp dti, let o = dfiOffset i
                                                                   ]
                                                in  if dgiIsNewtype @dgi
                                                    then mkCExprLet CBindings_Plain @dataFieldExpr.dfeCBindL
                                                         $ head $ fuL2ExprL $ fuMap (\_ f -> (f emptyDataTagInfo 0,0)) $ @dataFieldExpr.fuCExprL
                                                    else case @dataFieldExpr.mbConNm of
                                                           Just conNm
                                                             -> mkCExprLet CBindings_Plain @dataFieldExpr.dfeCBindL
                                                                  (mkTup (dgiDtiOfCon conNm @dgi) (const $ cundefined @lhs.opts) @dataFieldExpr.dfeCExpr @dataFieldExpr.fuCExprL)
                                                           _ -> mkCExprLet CBindings_Plain (err ++  @dataFieldExpr.dfeCBindL)
                                                                  (mkCExprSatSelsCases (rceUpdEnv (CExpr_Var en) @rceEnv) (Just $ mkHNm @lUniq) @dataFieldExpr.dfeCExpr alts)
                                                             where alts = [ ( dtiCTag dti
                                                                            , [ (f,f,dfiOffset i) | (f,i) <- Map.toList $ dtiFldMp dti ]
                                                                            , Nothing
                                                                            , mkTup dti CExpr_Var (CExpr_Tup $ dtiCTag dti) @dataFieldExpr.fuCExprL
                                                                            )
                                                                          | dti <- @dtiInFldL
                                                                          ]
                                                                   err = [mkCBind1 en (cerror @lhs.opts ("has no field update '" ++ show @fldL ++ "'"))]
                                                                   en = mkHNm "_upd_error"
                            .   cexpr       =   @dfexpr
%%]

%%[(8 codegen)
ATTR
  DataFieldExpr
    [ | | dfeCExpr: CExpr
          dfeCBindL: CBindL
          fuCExprL: {FieldUpdateL (DataTagInfo -> Int -> CExpr)}
    ]

SEM DataFieldExpr
  | Upd         loc         .   fldExprNm   =   mkHNm @lUniq
                lhs         .   fuCExprL    =   let mke dti o = CExpr_TupIns @dataFieldExpr.dfeCExpr (dtiCTag dti) @nm (CExpr_Int o) (CExpr_Var @fldExprNm)
                                                in  (@nm,(mke,Nothing)) : @dataFieldExpr.fuCExprL
                            .   dfeCBindL   =   mkCBind1 @fldExprNm @expr.cexpr : @dataFieldExpr.dfeCBindL
  | Con         lhs         .   dfeCExpr    =   CExpr_Tup (dtiCTag @dti)
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []
  | Expr        loc         .   dfeCExpr    =   @expr.cexpr
                            .   fuCExprL    =   []
                            .   dfeCBindL   =   []

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, dissection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | Sel         loc         .   offset          =   CExpr_Int (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @lbl @expr.ty)
                            .   cexpr           =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq_freshKnTy
                                                    in   mkCExprSelCase @rceEnv (Just n1) @expr.cexpr CTagRec n2 @lbl @offset Nothing
%%]
  | Sel         loc         .   offset          =   CExpr_Int (tyRecOffset @lbl (@lhs.finTyVarMp |=> @expr.ty))

%%[(10 codegen)
SEM Expr
  | Sel         loc         .   offset          :=  cSubstApp @expr.cSubst $ mkCExprPrHole @lhs.opts @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data constr wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM DataConstr
  | Constr      lhs         .   cbindL      =   let len = length @fields.fldTyL
                                                    nms = map (\i -> hsnFromString ("x" ++ show i)) [1..len]
                                                in  if @lhs.isNewtype
                                                    then [ mkCBind1 @conNm (CExpr_Var $ ehbnId $ ehcOptBuiltinNames @lhs.opts) ]
                                                    else [ mkCBind1 @conNm
                                                             (mkCExprLam nms
                                                               (mkCExprApp (CExpr_Tup @ctag)
                                                                 (map CExpr_Var nms)))
                                                         ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data field selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Decl
  | Data        loc         .   fldSelCBindL=   let (xn1:xn2:_) = hsnLclSupply
                                                    tgSels f i = [ (t,[(f,f,o)],Nothing,CExpr_Var f) | (t,o) <- Map.toList $ dficInTagMp i ]
                                                in  if @isNewtype
                                                    then [ [ mkCBind1 f (CExpr_Var $ ehbnId $ ehcOptBuiltinNames @lhs.opts)
                                                           | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         ] ]
                                                    else [ [ mkCBind1 f
                                                               (mkCExprLam [xn1]
                                                                 (mkCExprSatSelsCases (rceUpdEnv (CExpr_Var en) @rceEnv) (Just xn2) (CExpr_Var xn1) (tgSels f i)))
                                                           , mkCBind1 en (cerror @lhs.opts ("has no field selection '" ++ show f ++ "'"))
                                                           ]
                                                         | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         , let en = hsnUniqifyStr HsNameUniqifier_New "datafield_sel_error" f -- hsnSuffix f "_datafield_sel_error"
                                                         ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: all bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Decl
  | Data        lhs         .   cbindL      =   concat @fldSelCBindL ++ @constrs.cbindL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR PatExpr [ | | cpNm: RPatNm ]

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable
%%[[97
    Expr
%%]]
                loc         .   cpNm        =   maybe (RPatNmUniq @topNm) RPatNmOrig @mbTopNm
  | App         loc         .   cpNm        =   @arg.cpNm
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tyConNm     =   tyConNm $ fst $ tyAppFunArgs @finKnPatTy -- $ tyAppFunArgsWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @knPatTy
                            .   dgi         =   panicJust ("PatExpr.{AppTop,Con}.dgi: " ++ show @tyConNm)
                                                    $ dataGamLookup @tyConNm $ @lhs.dataGam
                            .   dti         =   panicJust ("PatExpr.{AppTop,Con}.dti: " ++ show @tyConNm ++ "." ++ show @appFunNm)
                                                    $ Map.lookup @appFunNm $ dgiConstrTagMp @dgi
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tag         =   dtiCTag @dti
                            .   rest        =   CPatRest_Empty
  | Rec         loc         .   tag         =   CTagRec
                            .   rest        =   @recPatExpr.patCRest
  | DataFields  loc         .   tag         =   dtiCTag @dataFieldPatExpr.dti
                            .   rest        =   @dataFieldPatExpr.patCRest
%%]

%%[(8 codegen) hs
fsL2PatOffsetL :: FieldSplitL -> AssocL RPatFld (Maybe Int)
fsL2PatOffsetL l = [ (RPatFld_Fld n oe p,Just oi) | (o,(foff,p)) <- zip [0..] l, let (oi,oe) = foffMkOff foff o, let n = foffLabel foff ]
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   rpatBinds   =   fsL2PatOffsetL $ reverse                   $ @fsRPatL
  | Rec         loc         .   rpatBinds   =   fsL2PatOffsetL $ tyRowCanonOrderBy compare $ @fsRPatL
  | DataFields  loc         .   (rpatBindss,rpatBindsNonSat,rpatBind0)
                                            =   let fsL = reverse @fsRPatL
                                                    grp = groupByOn (\o1 o2 -> (foffOffset o1 `compare` foffOffset o2) /= GT) fst
                                                    max = ctagArity @tag - 1
                                                    sat = -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                          listSaturateWith 0 max (foffOffset . fst) $
                                                          -- (\v -> v `seq` tr "PatExpr.DataFields.rpatBindss2" ("tag" >#< @tag >#< "arity" >#< max) v) $
                                                            (zipWith (\o n -> (o,(FldKnownOffset n o,RPat_Var (RPatNmOrig n)))) [0..max] hsnLclSupply)
                                                in  ( map (fsL2PatOffsetL . sat) $ grp fsL      -- groups of bindings which can be dealt with simultaneously
                                                    , fsL2PatOffsetL fsL                        -- bindings
                                                    , fsL2PatOffsetL $ sat []                   -- 0 binding
                                                    )
%%]

%%[(8 codegen)
ATTR PatExpr [ | | rpat: RPat ]

SEM PatExpr
  | IConst      loc         .   rpat        =   RPat_Int @cpNm @int
  | CConst      loc         .   rpat        =   RPat_Char @cpNm @char
  | SConst      loc         .   rpat        =   RPat_Int @cpNm (-1) -- for now
  | Var         loc         .   rpat        =   RPat_Var @cpNm
  | VarAs       loc         .   rpat        =   @patExpr.rpat {rcpPNm = @cpNm}
  | Con         loc         .   rpat        =   RPat_Con @cpNm @tag (RPatConBind_One CPatRest_Empty [])
  | AppTop      loc         .   rpat        =   RPat_Con @cpNm @tag (RPatConBind_One @rest (map fst @rpatBinds))
  | Rec         loc         .   rpat        =   case @rest of
                                                    CPatRest_Empty
                                                      ->  RPat_Con @cpNm @tag (RPatConBind_One @rest (map fst @rpatBinds))
                                                    CPatRest_Var r
                                                      ->  RPat_Con @cpNm @tag (RPatConBind_One @rest pbL)
                                                          where  pbL = map fst $ fsL2PatOffsetL $ fsLReorder @lhs.opts $ reverse $ @fsRPatL
  | DataFields  loc         .   rpat        =   RPat_Con @cpNm @tag
                                                    (rpatConBindUnFlatten (RPatConBind_One @rest $ map fst @rpatBind0)
                                                     $ map (RPatConBind_One @rest . map fst)
                                                           @rpatBindss
                                                    )
  | Irrefutable loc         .   rpat        =   RPat_Irrefutable @cpNm @patExpr.cbindL -- $ cbindInPatFlatten @patExpr.cbindInPatL
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   rpat        =   RPat_BoolExpr @cpNm @cexpr @mbConst
%%]

%%[(8 codegen)
ATTR AllPatExpr [ | | patCRest: CPatRest ]

SEM RecPatExpr
  | Empty       lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @recPatExpr.patCRest

SEM DataFieldPatExpr
  | Con         lhs         .   patCRest    =   CPatRest_Empty
  | Ext         lhs         .   patCRest    =   @dataFieldPatExpr.patCRest

SEM PatExpr
  | Var         lhs         .   patCRest    =   CPatRest_Var @nm
  | * - Var     lhs         .   patCRest    =   CPatRest_Empty
%%]

%%[(8 codegen)
ATTR AllPatExpr [ | | fsRPatL: FieldSplitL ]

SEM DataFieldPatExpr
  | Con         lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldKnownOffset @nm @ioffset,@patExpr.rpat) : @dataFieldPatExpr.fsRPatL

SEM RecPatExpr
  | Empty       lhs         .   fsRPatL     =   []
  | Ext         lhs         .   fsRPatL     =   (FldComputeOffset @nm @offset,@patExpr.rpat) : @recPatExpr.fsRPatL

SEM PatExpr
  | App         lhs         .   fsRPatL     =   (FldImplicitOffset,@arg.rpat) : @func.fsRPatL
  | AppTop      loc         .   fsRPatL     =   @patExpr.fsRPatL
  | Rec         loc         .   fsRPatL     =   @recPatExpr.fsRPatL
  | DataFields  loc         .   fsRPatL     =   @dataFieldPatExpr.fsRPatL
  | Con         loc         .   fsRPatL     =   []
  | * - App Con Rec
                lhs         .   fsRPatL     =   []
%%]

%%[(8 codegen)
SEM DataFieldPatExpr
  | Ext         loc         .   ioffset     =   dfiOffset $ panicJust "DataFieldPatExpr.Ext.ioffset" $ Map.lookup @nm $ dtiFldMp @dataFieldPatExpr.dti
                            .   offset      =   CExpr_Int @ioffset

SEM RecPatExpr
  | Ext         loc         .   ioffset     =   tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recPatExpr.ty
                            .   offset      =   CExpr_Int @ioffset
%%]
  | Ext         loc         .   offset      =   CExpr_Int (tyRecOffset @nm (@lhs.finTyVarMp |=> @recPatExpr.ty))

%%[(10 codegen)
SEM RecPatExpr
  | Ext         loc         .   offset      :=  cSubstApp @patExpr.cSubst $ mkCExprPrHole @lhs.opts @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercions resulting from pred usage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
SEM Expr
  | App AppImpred
                loc         .   appImplsCoeL        =   (mkPoisAppCoe @lhs.opts $ map poPoi @prOccL) ++ [CoeImplApp $ ipoId @imPrvOcc]
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL
%%]

%%[(12 codegen)
SEM Expr
  | AppImpl     loc         .   appImplsCoeL        =   []
                            .   appImplsLRCoe       =   lrcoeLFromList @appImplsCoeL
%%]

%%[(9 codegen)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lamBodyCoeL         =   mkLamBodyCoe
                                                            (mkCoe (\e -> rceMatch @rceEnv [@arg.topNm] [RAlt_Alt [@arg.rpat] e Set.empty]))
                                                            @body.appArgCoeL
%%]

%%[(9 codegen)
SEM Expr
  | Lam         loc         .   lamArgCoeL          =   mkPoiLLamCoe (mkLetRecCoe @poiBindL) @poiL ++ [mkLamCoe1 @arg.topNm]
  | AppTop Rec Let
                loc         .   lamArgCoeL          =   mkPoiLLamCoe (mkLetRecCoe @poiBindL) @poiL
%%]

%%[(12 codegen)
SEM Expr
  | LamImpl     loc         .   lamArgCoeL          =   [mkLamCoe1 @arg.topNm `coeCompose` mkLetRecCoe @poiBindL]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering coercions/cexpr for app args for optimization by weaving above apptop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen)
ATTR Expr [ | | appArgCoeL: {[Coe]}  appFunCExpr: CExpr ]

SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if @func.isNewtype
                                                    then ([],@arg.cexpr)
                                                    else (@func.appArgCoeL ++ @appImplsCoeL ++ [mkAppCoe1 @arg.cexpr],@func.appFunCExpr)
  | AppTop      lhs         .   (appArgCoeL,appFunCExpr)
                                                =   if null @lamArgCoeL
                                                    then (@expr.appArgCoeL,@expr.appFunCExpr)
                                                    else ([],@cexpr)
  | * - App AppImpred AppTop
%%[[12
    AppImpl
%%]]
                lhs         .   appArgCoeL      =   []
                            .   appFunCExpr     =   @cexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR
  Decls Decl AllDataConstr
    [ | | cbindL
        , ffiCBindL
%%[[94
        , ffeCBindL
%%]]
          USE {++} {[]}: CBindL
    ]
%%]

%%[(8 codegen)
SEM Decl
  | Val         lhs         .   cbindL          =   [mkCBind1 @patExpr.topNm @expr.cexpr] ++ @patExpr.cbindL -- cbindInPatFlatten @patExpr.cbindInPatL
  | TySig       lhs         .   cbindL          =   []
  | FFI         lhs         .   ffiCBindL       =   [CBind_FFI @callconv @safety @impEnt @nm @ty_sig_expanded]
%%]

%%[(9 codegen)
SEM Decl
  | Val         lhs         .   cbindL          :=  [mkCBind1 @patExpr.topNm $ mkCExprLet' True CBindings_Rec @chrScopeValBindL @expr.cexpr] ++ @patExpr.cbindL -- cbindInPatFlatten @patExpr.cbindInPatL    -- '
%%]

%%[(94 codegen)
  | FFE         loc         .   nmCoerced       =   mkHNmPrefix "coerced_" @nm
                lhs         .   cbindL          =   [mkCBind1 @nmCoerced @expr.cexpr]
                            .   ffeCBindL       =   [CBind_FFE @nm @callconv @expEnt @nmCoerced @ty_sig_expanded]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Front/back bindings are inserted before/after the other bindings, though only on top level.
Meant for global defs like FFI/FFE.
Merging is done to group all mutual recursive stuff together, in particular instances which are out of order declared.
Reordering and splitting up in smaller groups is then done later by a Core transformation.

%%[(8 codegen) hs
mkLetCBodyBindL :: Bool -> CBindingsCateg -> [(CBindingsCateg,CBindL)] -> [(CBindingsCateg,CBindL)] -> [(CBindingsCateg,CBindL)] -> CExpr -> ([(CBindingsCateg,CBindL)],CExpr)
mkLetCBodyBindL isStrict howToBind locBindL locOthBindL bodyBindL body
  = if isStrict
    then (locOthBindL,foldr (\(c,b) e -> mkCExprLet c b e) body (merge $ locBindL ++ bodyBindL))
    else (merge $ locOthBindL ++ locBindL ++ bodyBindL, body)
  where merge (cb1@(c1,b1) : tl)
          = case merge tl of
              (c2,b2) : tl' | c1 == c2 && c1 == CBindings_Rec
                  -> (c1,b1++b2) : tl'
              tl' -> cb1 : tl'
        merge [] = []
%%]

%%[(8 codegen)
ATTR
  Expr
    [ | | letCBindL
        , frontCBindL
%%[[94
        , backCBindL
%%]]
            : {[(CBindingsCateg,CBindL)]}
          letCBody: CExpr
    ]

SEM Expr
  | Let         (loc.letCBindRemL,loc.letCBody) =   mkLetCBodyBindL @isStrict @howToBind @letCBindL @letCBindOtherL @body.letCBindL @body.letCBody
                lhs         .   letCBindL       =   @letCBindRemL
                            .   frontCBindL     =   @frontCBindL ++ @body.frontCBindL
%%[[94
                            .   backCBindL      =   @backCBindL ++ @body.backCBindL
%%]]
  | * - Let     lhs         .   letCBody        =   @cexpr
                            .   letCBindL       =   []
                            .   frontCBindL     =   []
%%[[94
                            .   backCBindL      =   []
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9 codegen) hs
cdictOffset :: HsName -> Ty -> Int
cdictOffset n r = tyRecOffset n $ r
%%]

%%[(9 codegen)
SEM Decl
  | Class       lhs         .   cbindL      =   let  x = mkHNm "x"
                                                     vx = CExpr_Var x
                                                     xStrict = hsnUniqifyEval x
                                                     vxStrict = CExpr_Var xStrict
                                                     mkSel n = mkCExprSatSelsCaseMeta
                                                                 ((emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}) (Just xStrict) (CMetaVal_Dict Nothing) vx @dictTag
                                                                 [(n,n,cdictOffset n @clsTyRec)] Nothing (CExpr_Var n)
                                                     mkApp = if ehcCfgInstFldHaveSelf @lhs.opts
                                                             then (\f -> mkCExprApp1Meta f vx (CMetaVal_Dict Nothing))
                                                             else id
                                                     dDflt
                                                       = [mkCBind1 nDflt (mkCExprLam1Meta nD (CMetaVal_Dict Nothing) d)] 
                                                       where nDflt = clgiDfltDictNm @clgi2
                                                             d = mkCExprApp (CExpr_Tup @dictTag) (replicate (length $ snd $ tyRecExts $ @clsTyRec) (cundefined @lhs.opts))
                                                             nD = hsnUniqify HsNameUniqifier_SelfDict nDflt
                                                in   (maybe dDflt (const []) @mbDefaultInstNm)
                                                     ++ [ mkCBind1 n $ mkCExprLam1Meta x (CMetaVal_Dict Nothing) $ mkApp $ mkSel n
                                                        | (n,_) <- @clsFldL
                                                        ]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Three Haskell-constructs give rise to an instance-declaration in EH.
In EH, they can be dicerned by inspecting @instVariant:
* InstNormal:   a normal HS instance-declaration
* InstDefault:  the default definitions of a HS class-declaration
* InstDeriving: a deriving-annotation in a data-declaration
The attribute below generates Core code for these.

As an example we show the processing of a simplified form of a HS class "Eq" 
and "Boolean" as an instance of it:

  class Eq a where
    eq :: a -> a -> Bool
    ne :: a -> a -> Bool
    ne x y = not (eq x y)   -- a default definition
                            -- To show how missing definitions are treated, we do not give a default definition for eq here, as in the Prelude
  instance Eq Boolean where
    eq x y = cond x y (not y)  -- the implementation of equality on booleans
                               -- For the "ne" function, it falls back on the default implementation

In the transformation below, before the actual Core code is generated, we have two auxiliary functions:
  * mkNormalD:  generates the dictionary for an instance definition (either from code supplied by the HS programmer, or generated because of "deriving")
  * mkDefaultD: generates the dictionary for a default definition
Also there are some local values:
  * some fresh variable names to be used in the Core code
  * some auxiliary lists, which hold transformations of the original member definitions
Some of these local values are local to mkNormalD or mkDefaultD, others can be definied generically for both.

The elements of the lists correspond to class members. The correspondence can be encode in two ways:
  * as an association list (either 2-tuples, or CBinds)
  * positional: a fixed number of elements in a fixed order
We explain their meaning by showing example values during processing of the Eq code mentioned above.
Part of the processing is generating fresh names for members.
In the example, "03" is a prefix specific for the default definitions of class Eq, and "05" for the instance definition Eq Boolean.

We use a few notational conventions in the example:
 * what is shown as a string is really an HsName, thus "eq" really is HsName_Base "eq"
 * we use => to denote a CBind, thus  a=>b  means  CBind a m b 
 * we omit the meta-annotation m in CBinds.

 
memberNames          =  [       "eq",       "ne" ]  positional
memberNewNames       =  [     "03eq",     "03ne" ]  positional
      or, respectively, [     "05eq",     "05ne" ]  positional
memberNewVars        =  [ Var "03eq", Var "03ne" ]  positional
      or, respectively, [ Var "05eq", Var "05ne" ]  positional

defaultBindings      =  [                                               "ne"   => \xy.not(eq x y) ]  association
defaultBindingPairs  =  [                                              ("ne"   ,  \xy.not(eq x y))]  association
defaultMbBodies      =  [ Nothing                                , Just           \xy.not(eq x y) ]  positional
defaultMbNewNames    =  [ Nothing                                , Just "03ne"                    ]  positional
defaultBodies        =  [                   cundef               ,                \xy.not(eq x y) ]  positional
defaultNewBindings   =  [         "03eq" => cundef               ,      "03ne" => \xy.not(eq x y) ]  association, and also positional

instanceBindings     =  [         "eq" =>   \xy.cond x y (not y)                                  ]  association
instanceBindingPairs =  [        ("eq" ,    \xy.cond x y (not y))                                 ]  association
instanceMbBodies     =  [ Just              \xy.cond x y (not y) , Nothing                        ]  positional
instanceMbNewNames   =  [ Just    "05eq"                         , Nothing                        ]  positional
instanceMbNames      =  [ Just    "eq"                           , Nothing                        ]  positional
instanceNameMapping  =  [        ("eq"  ,   Var "05eq")                                           ]  association
instanceNewBindings  =  [         "05eq" => \xy.cond x y (not y)                                  ]  association


The primary use of these lists is generating the ...NewBindings.
But for the meta-annotation, also the ...MbNewNames lists are needed.
The other lists are auxiliary.


%%[(9 codegen)


SEM Decl
  | Instance    lhs         .   cbindL      =   let  (generatedDictionary, generatedMeta)
                                                       = case @instVariant of
                                                            InstNormal   -> mkNormalD  @decls.cbindL
                                                            InstDefault  -> mkDefaultD @decls.cbindL
%%[[95                                                            
                                                            InstDeriving -> mkNormalD  [ @loc.mkf dcf | dcf <- dclFldL @derivDCL ]
%%]]


                                                     memberNames     = [ n 
                                                                       | (n,_) <- tyRowCanonOrder @recTyExts 
                                                                       ]
                                                     memberNewNames  = [ hsnUniqifyStr HsNameUniqifier_DictField (show n) @dictNm -- hsnSuffix @dictNm ('~':show n)
                                                                       | n <- memberNames
                                                                       ]
                                                     memberNewVars   = map CExpr_Var memberNewNames

                                                     rsltNm   = @dictBuildNm
                                                     rsltVar  = CExpr_Var rsltNm
                                                                                                                                                                                       
                                                     mkNormalD instanceBindings
                                                       = let dfltNm       = clgiDfltDictNm @clgi
                                                             rsltNmStrict = hsnUniqifyEval rsltNm
                                                             dfltNmStrict = hsnUniqifyEval dfltNm
                                                             dfltVar      = CExpr_Var dfltNm
                                                             rsltVarStrict= CExpr_Var rsltNmStrict
                                                             dfltVarStrict= CExpr_Var dfltNmStrict

                                                             instanceBindingPairs= [ (nm,v)
                                                                                   |  CBind_Bind nm _ v <- instanceBindings
                                                                                   ]
                                                             instanceMbBodies    = map (flip lookup instanceBindingPairs) memberNames
                                                             instanceMbNewNames  = let f _ Nothing  = Nothing
                                                                                       f n (Just e) = Just n
                                                                                   in zipWith f memberNewNames instanceMbBodies
                                                             instanceMbNames     = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNames instanceMbNewNames
                                                             instanceNameMapping = [ (nm, CMetaVal_Val, v)
                                                                                   | (Just nm,v) <- zip instanceMbNames memberNewVars
                                                                                   ]
                                                             instanceNewBindings = [ mkCBind1Meta nm CMetaVal_Val v
                                                                                   | (nm,Just v) <- zip memberNewNames instanceMbBodies
                                                                                   ]
                                                                                   
                                                             superNewVars        = map CExpr_Var @chrSuperProveNmL
                                                             superNameMapping    = zip3 @supClsFldL
                                                                                        (repeat (CMetaVal_Dict Nothing))
                                                                                        superNewVars

                                                             superNameMapping2   = zip @supClsFldL
                                                                                       @chrSuperProveNmL
                                                             superPairs          = map getBindLeftAndRightVar @chrScopeSuperBindL
                                                             
                                                             doubleLookup :: HsName -> Maybe HsName
                                                             doubleLookup nm   =  do { nm2 <- lookup nm superNameMapping2
                                                                                     ; nm3 <- lookup nm2 superPairs
                                                                                     ; return nm3
                                                                                     }
                                                             
                                                             superMbNewNames   =  map doubleLookup memberNames

                                                             instanceAndSuperMbNewNames = let f (Just x) _ = Just x
                                                                                              f _ (Just y) = Just y
                                                                                              f _ _        = Nothing
                                                                                          in zipWith f instanceMbNewNames superMbNewNames

                                                             instanceCHRBindings = -- cSubstApp @decls.cSubst
                                                                                                (  @chrAssumeSuperBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL 
                                                                                                ++ @chrAssumeDeclsCtxtBindL 
                                                                                                ++ @chrScopeSuperBindL 
                                                                                                ++ @chrScopeDeclsBindL
                                                                                                )

                                                             dict1     = mkCExprApp1Meta dfltVar rsltVar (CMetaVal_Dict Nothing)
                                                             dict2     = CExpr_Let CBindings_Strict [bind1] (@loc.mkSetFlds superNameMapping    dfltVarStrict)
                                                             dict3     = CExpr_Let CBindings_Strict [bind2] (@loc.mkSetFlds instanceNameMapping rsltVarStrict)
                                                             dict4     = mkCExprLetRec ([bind3] ++ instanceNewBindings ++ instanceCHRBindings) rsltVar
                                                             
                                                             bind1     = mkCBind1Meta dfltNmStrict (CMetaVal_Dict Nothing) dict1
                                                             bind2     = mkCBind1Meta rsltNmStrict (CMetaVal_Dict Nothing) dict2
                                                             bind3     = mkCBind1Meta rsltNm       (CMetaVal_Dict (Just [])) dict3
                                                             contextArguments = cmetaLiftDict @chrCtxtArgNmL
                                                             
                                                             mbToList Nothing = []
                                                             mbToList (Just x) = [x]
                                                             
                                                         in  ( mkCExprLamMeta contextArguments dict4   
                                                             , CMetaVal_DictInstance (map mbToList (Just (ctagTyNm @dictTag) : Just dfltNm : instanceAndSuperMbNewNames))
                                                             )

                                                     mkDefaultD defaultBindings
                                                       = let selfNm    = @dictSelfNm
                                                       
                                                             lookupMeta n = if n `elem` @supClsFldL then (CMetaVal_Dict Nothing) else CMetaVal_Val
                                                       
                                                             defaultBindingPairs = [ (nm,v)
                                                                                   |  CBind_Bind nm _ v <- defaultBindings
                                                                                   ]
                                                             defaultMbBodies     = map (flip lookup defaultBindingPairs) memberNames
                                                             defaultMetas        = map lookupMeta                        memberNames
                                                             defaultBodies       = map (maybe (cundefined @lhs.opts) id) defaultMbBodies
                                                             defaultMbNewNames   = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNewNames defaultMbBodies
                                                             
                                                             defaultNewBindings  = zipWith3 mkCBind1Meta memberNewNames 
                                                                                                         defaultMetas
                                                                                                         defaultBodies
                                                             defaultCHRBindings  = -- cSubstApp @decls.cSubst
                                                                                                (  @chrScopeDeclsBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL
                                                                                                )
                                                                                                
                                                             defaultCHRBindingsAnnotated = annotateBindings @dictSelfNm defaultCHRBindings
                                                                                                
                                                             dict5     = mkCExprAppMeta (CExpr_Tup @dictTag)
                                                                                        (zip memberNewVars defaultMetas)
                                                             dict6     = mkCExprLetRec ([bind5] ++ defaultNewBindings ++ defaultCHRBindingsAnnotated) rsltVar
                                                             
                                                             bind5     = mkCBind1Meta rsltNm (CMetaVal_Dict Nothing) dict5

                                                         in  ( mkCExprLam1Meta selfNm (CMetaVal_Dict (Just [])) dict6
                                                             , CMetaVal_DictClass defaultMbNewNames
                                                             )

                                                in   [mkCBind1Meta @dictNm generatedMeta (generatedDictionary)]
  | InstanceIntro
                lhs         .   cbindL      =   [mkCBind1Meta @dictNm (CMetaVal_Dict Nothing) @expr.cexpr]
%%]

%%[(9 codegen) hs

getBindRightVar :: CBind -> Maybe HsName

getBindRightVar (CBind_Bind _ _ (CExpr_Var nm)) = Just nm
getBindRightVar _ = Nothing


getBindLeftAndRightVar :: CBind -> (HsName,HsName)

getBindLeftAndRightVar (CBind_Bind nm1 _ (CExpr_Var nm2)) = (nm1,nm2)
getBindLeftAndRightVar _ = error "getBindLeftAndRightVar: not a bind"



annBind (CBind_Bind x _ e) mba = CBind_Bind x (CMetaBind_Plain, CMetaVal_Dict mba) e

annotateBindings selfnm bs = zipWith annBind bs (map mbFindValueVar xs)
  where ps = map (\(CBind_Bind x _ e)->(x,e)) bs
        mp = Map.fromList ps
        xs = map fst ps
        mbFindValueVar x  |  x==selfnm  =  Just []
                          |  otherwise  =  maybe Nothing mbFindValueExpr (Map.lookup x mp)
        mbFindValueExpr (CExpr_Var y) = mbFindValueVar y
        mbFindValueExpr (CExpr_Let _ [CBind_Bind _ _ (CExpr_Var v)] c) = let  mba = mbFindValueVar v
                                                                         in   maybe (trace ("ToCore: annotateBindings: name not found:"++show v) Nothing) (\a->Just (a ++ [findPlace c])) mba
        mbFindValueExpr e = Nothing
        findPlace (CExpr_Case _ [CAlt_Alt (CPat_Con _ _ zs) (CExpr_Var v)] _) = findPosition v 0 zs
        findPosition v n [] = error ("ToCore: annotateBindings: position not found: " ++ show v)
        findPosition v n (CPatFld_Fld x _ _:zs) | v==x       =  n
                                                | otherwise  =  findPosition v (n+1) zs       

%%]



An auxiliary local attribute that decides (based on an option) how
to set fields in a dictionary:
- by updates of a record
- by matching and rebuilding a datatype 

%%[(9 codegen)
SEM Decl
  | Instance    loc         .   mkSetFlds   =   let  off n = cdictOffset n @recTy
                                                     mkSetFldsRec ts d0
                                                       = foldl (\d (n,_,v) -> mkSet d n v) d0 ts
                                                       where mkSet d n v = CExpr_TupUpd d @dictTag n (CExpr_Int $ off n) v

                                                     mkSetFldsData ts d0
                                                       = mkCExprSatSelsCaseMeta env Nothing (CMetaVal_Dict Nothing) d0 @dictTag nmLblOffL Nothing sel
                                                       where env = (emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}
                                                             fullListWithTrivialValues = [ (o, (o, (CExpr_Var n,CMetaVal_Val) ) ) 
                                                                                         | (n,_,o) <- nmLblOffL 
                                                                                         ]
                                                             sparseListWithInterestingValues = [ (off n, (v,m) ) 
                                                                                               | (n,m,v) <- ts
                                                                                               ]
                                                             arity = length @recTyExts
                                                             ns = take arity hsnLclSupply
                                                             nmLblOffL = zip3 ns ns [0..]
                                                             sel = mkCExprAppMeta (CExpr_Tup @dictTag) 
                                                                                  (map snd
                                                                                   -- $ (\v -> v `seq` tr "Decl.Instance.mkSetFlds" (pp arity) v)
                                                                                   $ listSaturateWith 0 
                                                                                                      (arity-1) 
                                                                                                      fst 
                                                                                                      fullListWithTrivialValues
                                                                                                      sparseListWithInterestingValues
                                                                                  )
                                                   in  if   ehcCfgClassViaRec @lhs.opts  
                                                       then mkSetFldsRec  
                                                       else mkSetFldsData

%%]


An auxiliary local attribute that generates thee bindings for a DERIVED instance

%%[(95 codegen)
SEM Decl
  | Instance    loc         .   mkf         =   let   rsltNm   = @dictBuildNm
                                                      rsltVar  = CExpr_Var rsltNm
                                                      
                                                      mkf :: DerivClsFld -> CBind
                                                      mkf dcf
                                                       = mkCBind1 (dcfNm dcf)
                                                           (if fArity == 0
                                                            then mkCExprLam (dcfInitialArgL dcf)
                                                                 $ dcfNoArgSubsCExpr dcf @rceEnv
                                                                     [ (dti,mkcSubs dti (repeat []) altPrOccL) | (dti,altPrOccL) <- zip dtis @derivAltsPrOcc ]
                                                                     nrOfAlts rsltVar extraCxL (dcfInitialArgL dcf)
                                                            else mkCExprLam (dcfInitialArgL dcf ++ take fArity nsA)
                                                                   (dcfWrapCase dcf @lhs.opts @derivDataDGI nrOfAlts n1 (dcfInitialArgL dcf)
                                                                    $ mkCExprStrictSatCase @rceEnv (Just $ hsnUniqifyEval n1) n1v
                                                                      [ CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just $ n1subs ctag))
                                                                                 (mkc splDTI altInx (fArity - 1) n1s [n1subs ctag] altPrOccL)
                                                                      | (ctag,altPrOccL) <- zip (map dtiCTag dtis) @derivAltsPrOcc
                                                                      , let splDTI@(dtisLT,_,_) = splitDTIs ctag dtis
                                                                            altInx = length dtisLT
                                                                      ]
                                                           )       )
                                                       where n1v = CExpr_Var n1
                                                             nsA@(n1:n1s) = hsnLclSupplyWith (mkHNm "x")
                                                             dtis  = panicJust "Decl.Instance.Deriving.dataGamDTIsOfTy" $ dataGamDTIsOfTy @derivHdDataTy @lhs.dataGam
                                                             nrOfAlts = length dtis
                                                             splitDTIs t ts -- in (lt,eq,gt), according to list ordering
                                                               = (l,e,g)
                                                               where (l,(e:g)) = span ((/= t) . dtiCTag) ts
                                                             fArity = (length $ tyArrowArgs $ dcfTy dcf) - dcfNrOmitTailArg dcf - length (dcfInitialArgL dcf) - 1 {- dictionary -}
                                                             n1subs t = nsubs t n1
                                                             nsubs t n = take (ctagArity t) $ hsnLclSupplyWith n
                                                             extraCxL = [ mkCExprPrHole @lhs.opts (poPoi prOcc) | prOcc <- @derivExtraPrOcc ]
                                                             mkcSubs dti nmFldLL altPrOccL
                                                               = [ mkCExprAppMeta
                                                                     (CExpr_Var (dcfNm dcf))
                                                                     (cmetaLiftDict [mkCExprPrHole @lhs.opts (poPoi prOcc)]
                                                                       ++ cmetaLift (dcfInitialSubArgL dcf dti ++ map CExpr_Var nmFldL))
                                                                 | (nmFldL,prOcc) <- zip nmFldLL altPrOccL
                                                                 ]
                                                             mkc tg@(dtisLT,dti,dtisGT) altInx arity nms nmFldLL altPrOccL
                                                               = case nms of
                                                                   (n:ns) | arity > 0
                                                                     -> mkCExprStrictSatCase @rceEnv (Just $ hsnUniqifyEval n) (CExpr_Var n)
                                                                          (   [ mka (dtiCTag dti) tsubs (mkc tg altInx (arity - 1) ns (nmFldLL ++ [tsubs]) altPrOccL) ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagLtCExpr dcf) | t <- map dtiCTag dtisLT ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagGtCExpr dcf) | t <- map dtiCTag dtisGT ]
                                                                          )
                                                                     where tsubs = nsubs (dtiCTag dti) n
                                                                           mka ctag nsubs e = CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just nsubs)) e
                                                                   _ -> dcfFoldSubsCExpr dcf @lUniq @rceEnv dti (altInx, nrOfAlts) (dcfInitialArgL dcf)
                                                                        $ mkcSubs dti (transpose nmFldLL) altPrOccL
                                                in  mkf
%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
%%]
ATTR AllCase [ | | mkAlts: MkAlts ]

SEM CaseAlt
  | Pat         lhs         .   mkAlts      =   \n -> [@patExpr.mkAlt n @expr.cexpr]

SEM CaseAlts
  | Nil         lhs         .   mkAlts      =   \n -> []
  | Cons        lhs         .   mkAlts      =   \n -> @hd.mkAlts n ++ @tl.mkAlts n

%%[(8 codegen)
ATTR CaseAlt [ | | ralt: RAlt  ralt': RAlt ]
ATTR CaseAlts [ | | raltL: {[RAlt]}  raltL': {[RAlt]} ]

SEM CaseAlt
  | Pat         lhs         .   ralt        =   RAlt_Alt [@patExpr.rpat] @expr.cexpr @expr.caseFailS
                            .   ralt'       =   RAlt_Alt (fsL2PatL $ reverse @patExpr.fsRPatL) @expr.cexpr @expr.caseFailS

SEM CaseAlts
  | Nil         lhs         .   raltL       =   []
                            .   raltL'      =   []
  | Cons        lhs         .   raltL       =   @hd.ralt  : @tl.raltL
                            .   raltL'      =   @hd.ralt' : @tl.raltL'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in (recursive) let bindings (lazy unpacking)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
%%]
data CBindInPat = CBindInPat CBind [CBindInPat]

cbindInPatFlatten :: [CBindInPat] -> [CBind]
cbindInPatFlatten = concatMap (\(CBindInPat b subs) -> b : cbindInPatFlatten subs)

rpatBindL2CBindL :: RCEEnv -> [CBindInPat] -> HsName -> CTag -> MbCPatRest -> AssocL RPatFld (Maybe Int) -> [CBindInPat]
rpatBindL2CBindL env subBinds parNm ct rest pbL 
  = concat
    $  map  (\(RPatFld_Fld l o p,mbOff)
                -> let  b n = [CBindInPat (mkCBind1 n (mkc n mbOff)) subBinds]
                        pn  = parNm
                        pn' = hsnUniqifyEval pn
                        mkc n (Just o) = mkCExprSatSelCase env (Just pn') (CExpr_Var pn) ct n l o rest
                        mkc n Nothing  = mkCExprSelCase    env (Just pn') (CExpr_Var pn) ct n l o rest
                   in   case {- tr "rpatBindL2CBindL" (rcpPNm p >#< hasSub) $ -} rcpPNm p of
                            RPatNmOrig n           -> b n
                            RPatNmUniq n | hasSub  -> b n
                            _                      -> []
            )
    $  pbL
  where hasSub = not $ null subBinds
%%[(8 codegen) hs
rpatBindL2CBindL :: RCEEnv -> Bool -> HsName -> CTag -> MbCPatRest -> AssocL RPatFld (Maybe Int) -> [CBind]
rpatBindL2CBindL env hasSub parNm ct rest pbL 
  = concat
    $  map  (\(RPatFld_Fld l o p,mbOff)
                -> let  b n = [mkCBind1 n (mkc n mbOff)]
                        pn  = parNm
                        pn' = hsnUniqifyEval pn
                        mkc n (Just o) = mkCExprSatSelCase env (Just pn') (CExpr_Var pn) ct n l o rest
                        mkc n Nothing  = mkCExprSelCase    env (Just pn') (CExpr_Var pn) ct n l o rest
                   in   case {- tr "rpatBindL2CBindL" (rcpPNm p >#< hasSub) $ -} rcpPNm p of
                            RPatNmOrig n           -> b n
                            RPatNmUniq n | hasSub  -> b n
                            _                      -> []
            )
    $  pbL
%%]

ATTR AllPatExpr [ | | cbindInPatL USE {++} {[]}: {[CBindInPat]} ]

SEM PatExpr
  | AppTop Rec  loc         .   cbindInPatL =   rpatBindL2CBindL @rceEnv @cbindInPatLSub @lhs.ceParentNm @tag (Just (@rest,length @fsRPatL)) @rpatBinds 
  | DataFields  loc         .   cbindInPatL =   rpatBindL2CBindL @rceEnv @cbindInPatLSub @lhs.ceParentNm @tag (Just (@rest,ctagArity @tag)) @rpatBindsNonSat 
%%[(8 codegen)
ATTR AllPatExpr [ | | cbindL USE {++} {[]}: CBindL ]

SEM PatExpr
  | AppTop Rec  loc         .   cbindL      =   rpatBindL2CBindL @rceEnv (not $ null @cbindLSub) @lhs.ceParentNm @tag (Just (@rest,length @fsRPatL)) @rpatBinds 
  | DataFields  loc         .   cbindL      =   rpatBindL2CBindL @rceEnv (not $ null @cbindLSub) @lhs.ceParentNm @tag (Just (@rest,ctagArity @tag)) @rpatBindsNonSat 
  | AppTop Rec DataFields
                lhs         .   cbindL      =   @cbindL ++ @cbindLSub
%%]

SEM PatExpr
  | AppTop      loc         .   cbindInPatLSub  =   @patExpr.cbindInPatL
  | Rec         loc         .   cbindInPatLSub  =   @recPatExpr.cbindInPatL
  | DataFields  loc         .   cbindInPatLSub  =   @dataFieldPatExpr.cbindInPatL
%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   cbindLSub   =   @patExpr.cbindL
  | Rec         loc         .   cbindLSub   =   @recPatExpr.cbindL
  | DataFields  loc         .   cbindLSub   =   @dataFieldPatExpr.cbindL
%%]

%%[(8 codegen)
ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | App         arg         .   ceParentNm  =   rpatNmNm @arg.cpNm
--  | Irrefutable patExpr       .   ceParentNm  =   tr "PatExpr.Irrefutable" (@cpNm >#< @lhs.ceParentNm >#< @patExpr.topNm) @lhs.ceParentNm

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   rpatNmNm @patExpr.cpNm

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm
%%]

%%[(12 codegen)
SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can a CExpr fail, that is, has a guard which can fail? Indicated by non-emptyness of caseId's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | caseFailS USE {`Set.union`} {Set.empty}: UIDS ]

SEM Expr
  | Case        lhs         .   caseFailS   =   @caseFailS
%%]
  | CaseAltFail lhs         .   caseFailS   =   Set.singleton @caseId

