%%[0
%include lhs2TeX.fmt
%include afp.fmt
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind inferencing for data, placeholders, known ki use
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(5 hmtyinfer).tyGam
SEM Decl
  | Data        tyVars      .   tyGam               =   emptyGam
                lhs         .   patTyGam            =   gamAdd @tyNm (TyGamInfo (Ty_Con @tyNm)) @lhs.patTyGam
                constrs     .   tyGam               =   gamPushGam @tyVars.tyGam @lhs.tyGam
%%]

%%[(6 hmtyinfer)
SEM Decl
  | Data        loc         .   dataTgi             =   mkTGI (Ty_Con @tyNm)
                            .   dataTkgi            =   TyKiGamInfo (tyEnsureNonAny @lUniq @knKi)
                lhs         .   patTyGam            :=  if @hasKiSig  then @lhs.patTyGam
                                                                      else gamAdd @tyNm @dataTgi @lhs.patTyGam
                            .   patTyKiGam          =   if @hasKiSig  then @lhs.patTyKiGam
                                                                      else tyKiGamNameSingleton @tyNm @dataTkgi `gamUnion` @lhs.patTyKiGam
                loc         .   fo_                 =   fitsIn  strongFIOpts defaultFIEnv @lUniq2 @lhs.patKiVarMp
                                                                (@tyVars.kiL `mkArrow` kiStar) (tkgiKi @dataTkgi)
                            .   dataKi              =   foTy @fo_
                lhs         .   patKiVarMp          =   foVarMp @fo_ |=> @lhs.patKiVarMp
                constrs     .   tyKiGam             =   gamPushGam  (tyKiGamInst1Exists @lUniq3 (@lhs.kiVarMp |=> @tyVars.tyKiGam))
                                                                    @lhs.tyKiGam
                loc         .   lUniq               :   UNIQUEREF gUniq
                loc         .   lUniq2              :   UNIQUEREF gUniq
                loc         .   lUniq3              :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind inferencing for data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(6 hmtyinfer)
SEM DataConstr
  | Constr      loc         .   fldsKiVarMp         =   @fields.kiVarMp
                            .   (_,fo_)             =   fitsInL  weakFIOpts defaultFIEnv @lUniq @fldsKiVarMp
                                                                 @fields.kiL (repeat kiStar)
                lhs         .   kiVarMp             =   foVarMp @fo_ |=> @fldsKiVarMp
                loc         .   lUniq               :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data info gam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer).dataGam
ATTR
  AllDecl AllExpr AllCase
%%[[97
  AllPatExpr
%%]]
    [ | gathDataGam: DataGam | ]
ATTR AllDecl AllExpr AllCase AllPatExpr [ dataGam: DataGam | | ]

SEM AGItf
  | AGItf       expr        .   gathDataGam         =   emptyGam
%%]

%%[(7 hmtyinfer).initDataGam
SEM AGItf
  | AGItf       expr        .   dataGam             =   @expr.gathDataGam
%%]

%%[(20 hmtyinfer) -7.initDataGam
ATTR AGItf [ dataGam: DataGam | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering tag info for data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AGItf [ | | gathDataGam: DataGam ]

SEM Decl
  | Data        loc         .   dgi                 =   mkDGI @tyNm ([@dataTy] `mkArrow` @dataAltTy) @constrs.dataConstrNmL @constrs.dataConstrTagMp
%%[[7
                                                              @isNewtype
%%][94
                                                              (if @isNewtype
                                                               then Just $ foldr Ty_Lam @constrs.dataAltForNewType (map (panicJust "EH.InferData.Decl.Data.tyMbVar" . tyMbVar) @tyVars.tyL)
                                                               else Nothing
                                                              )
%%]]
                lhs         .   gathDataGam         =   gamAdd @tyNm @dgi @lhs.gathDataGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Tying at toplevel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(20 hmtyinfer)
SEM AGItf
  | AGItf       expr        .   dataGam             =   @expr.gathDataGam `gamUnion` @lhs.dataGam
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type of data constructors
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(5 hmtyinfer)
ATTR AllData [ dataTy: Ty | | ]
ATTR AllDataConstr [ | patValGam: ValGam | ]

SEM DataConstr
  | Constr      loc         .   dataConTy           =   @fields.tyL `mkArrow` @lhs.dataTy
                            .   dataConTyFv         =   ftv @lhs.dataTy
                            .   dataConProdTy       =   mkProdApp @fields.tyL
                            .   dataConProdTyFv     =   ftv @dataConProdTy
                loc         .   dataQuUnConTy       =   let fvD = @dataConTyFv
                                                            fvU = @dataConProdTyFv
%%[[5
                                                            mkk = id
%%][6
                                                            tkg = gamUnion @lhs.finTyKiGam @fields.intlTyKiGam
                                                            mkk tvs = [ (v,tvarKi tkg @lhs.tvKiVarMp emptyVarMp v) | v <- tvs ] -- zip tvs (repeat kiStar) -- TBD
%%]]
                                                        in  ({- mkTyQu tyQu_Forall (mkk fvD) -} ([@lhs.dataTy] `mkArrow` mkTyQu tyQu_Exists (mkk (fvU \\ fvD)) @dataConProdTy))
                loc         .   dataConTyVar        =   @lUniq_con
                            .   dataConTyAsVar      =   mkNewTyVar @lUniq_con
                            .   dataUnConTyVar      =   @lUniq_uncon
                            .   dataUnConTyAsVar    =   mkNewTyVar @lUniq_uncon
                lhs         .   patValGam           =   gamUnions
                                                          [ assocLToGam
                                                              [ (@conNm, ValGamInfo @dataConTyAsVar)
                                                              , (hsnUn @conNm, ValGamInfo @dataUnConTyAsVar)
                                                              ]
                                                          , @lhs.patValGam
                                                          ]
                            .   patTyVarMp          =   assocTyLToVarMp [(@dataConTyVar,@dataConTy),(@dataUnConTyVar,@dataQuUnConTy)] |=> @lhs.patTyVarMp
                loc         .   lUniq_con           :   UNIQUEREF gUniq
                loc         .   lUniq_uncon         :   UNIQUEREF gUniq
%%]

%%[(5 hmtyinfer)
SEM Decl
  | Data        loc         .   dataTy              =   @tyNm `mkConApp` @tyVars.tyL
%%]

%%[(7 hmtyinfer)
SEM Decl
  | Data        lhs         .   patValGam           =   gamUnions
                                                          [ gamNoDups @constrs.fldSelGam
                                                          , gamNoDups @constrs.fldUpdGam
                                                          , @constrs.patValGam
                                                          ]
%%]


%%[(7 hmtyinfer)
ATTR AllDataConstr [ | | dataAltTyL USE {++} {[]}: {AssocL HsName Ty} ]

SEM DataConstr
  | Constr      loc         .   dataConTy2          =   assocLElts @fields.fldTyL `mkArrow` @lhs.dataTy 
                            .   dataConProdTy2      =   let  lbls = zipWith (\p (ml,_) -> maybe p id ml) positionalFldNames @fields.fldTyL
                                                        in   mkTyRec (zipWith (\l (_,t) -> (l,t)) lbls @fields.fldTyL) 

                            .   dataConTy           :=  @dataConTy1
                            .   dataConProdTy       :=  @dataConProdTy1

                            .   dataAltTyL          =   [(@conNm,@dataConProdTy)]

SEM Decl
  | Data        loc         .   dataAltTy           =   mkTySum @constrs.dataAltTyL
                            .   dataTgi             :=  mkTGIData (Ty_Con @tyNm) Ty_Any {- ([@dataTy] `mkArrow` @dataAltTy) -}
%%]

%%[(94 hmtyinfer)
ATTR AllDataConstr [ | | dataAltForNewType USE {`const`} {Ty_Any}: Ty ]

SEM DataConstr
  | Constr      loc         .   dataAltForNewType   =   maybeHd Ty_Any snd @fields.fldTyL       -- should be only one
%%]

%%[(7 hmtyinfer).dataConXTy
SEM DataConstr
  | Constr      loc         .   dataConTy1          =   @loc.dataConTy2
                            .   dataConProdTy1      =   @loc.dataConProdTy2
%%]

%%[(16 hmtyinfer).dataConXTy -7.dataConXTy
SEM DataConstr
  | Constr
      (loc.dataConTy1, loc.cycVarMp) = @loc.eqsVarMp `tyAppVarLookup2_RhsOfEqOnly` @loc.dataConTy2
      (loc.dataConProdTy1, _)        = @loc.eqsVarMp `tyAppVarLookup2_RhsOfEqOnly` appendEqPreds @eqs.prOccL @loc.dataConProdTy2  -- cyclic occurrences subsumed by @loc.cycVarMp
      loc.occErrL                    = varmpOccurErr 
%%[[99
                                         @range
%%]]
                                         @loc.eqsVarMp @loc.cycVarMp
%%]

%%[(16 hmtyinfer) hs
-- assumption: Ty is a product
-- this function is supposed to be applied to the RHS of the unquantified type of the deconstructor function, which
-- is a product of the field types of the constructor. The equality constraints are encoded by adding them to the
-- end of this product.
appendEqPreds :: [PredOcc] -> Ty -> Ty
appendEqPreds preds ty
  = let predsTyL = map (Ty_Pred . poPr) preds
        prodTyL  = tyProdArgs ty
     in mkProdApp (prodTyL ++ predsTyL)
%%]

%%[(8 hmtyinfer)
ATTR AllDataConstr [ dataAltTy: Ty | | ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ty name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AllDataConstr [ tyNm: HsName | | ]

SEM Decl
  | Data        constrs     .   tyNm                =   @tyNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Map for tag + arity + fld labels offsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
SEM DataConstr
%%[[7
  | Constr      loc         .   fldMp               =   let mk = emptyDataFldInfo
                                                            mkfs = foldl (\m (ml,_) -> maybe m (\l -> (l,mk):m) ml) []
%%][8
  | Constr      loc         .   fldMp               =   let mk o = emptyDataFldInfo {dfiOffset = o}
                                                            mkfs = fst . foldl (\(m,o) (ml,_) -> maybe (m,o+1) (\l -> ((l,mk o):m,o+1)) ml) ([],0)
%%]]
                                                        in  Map.fromList $ mkfs $ @fields.fldTyL
%%]

%%[(7 hmtyinfer)
ATTR
  AllDataConstr
    [ | | dataConstrTagMp USE {`Map.union`} {Map.empty}: DataConstrTagMp
          dataConstrNmL USE {++} {[]}: {[HsName]}
    ]

SEM DataConstr
  | Constr      lhs         .   dataConstrTagMp     =   @conNm `Map.singleton` @dti
                            .   dataConstrNmL       =   [@conNm]
                loc         .   dti                 =   emptyDataTagInfo
                                                          { dtiFldMp = @fldMp
                                                          , dtiConNm = @conNm
%%[[8
                                                          , dtiCTag  = @ctag
%%]]
%%[[95
                                                          , dtiMbFixityPrio  = @mbFixityPrio
%%]]
                                                          }
%%[[8
                            .   tag                 =   tyRecOffset @conNm @lhs.dataAltTy
                            .   arity               =   length @fields.fldTyL
                            .   ctag                =   CTag @lhs.tyNm @conNm @tag @arity @lhs.maxArity
                loc         .   ctag                :   CTag
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Maximum arity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 hmtyinfer)
ATTR AllDataConstr [ maxArity: Int | | gathMaxArity USE {`max`} {0}: Int ]

SEM DataConstr
  | Constr      lhs         .   gathMaxArity        =   @arity

SEM Decl
  | Data        constrs     .   maxArity            =   @constrs.gathMaxArity
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type+label of data fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AllDataField [ | | fldTyL USE {++} {[]}: FldTyL ]

SEM DataField
  | Field       loc         .   fldTyL              =   case @mbLabels of
                                                          Just ls -> zipWith (\l t -> (Just l,t)) ls (repeat @tyExpr.ty)
                                                          _       -> [(Nothing,@tyExpr.ty)]
                loc         .   fldTyL              :   FldTyL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gam for selector functions of data fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AllDataField AllDataConstr [ | | fldSelGam USE {`gamUnion`} {emptyGam}: ValGam ]

SEM DataField
  | Field       loc         .   fldSelGam           =   assocLToGam [ (l,ValGamInfo $ [@lhs.dataTy] `mkArrow` t) | (Just l,t) <- @fldTyL ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gam for update functions of data fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AllDataField AllDataConstr [ | | fldUpdGam USE {`gamUnion`} {emptyGam}: ValGam ]

SEM DataField
  | Field       loc         .   fldUpdGam           =   let mk t = [t,fr @lhs.dataTy] `mkArrow` @lhs.dataTy
                                                                 where fv = tyFtvMp t
                                                                       fr dt = dt
                                                        in  assocLToGam [ (hsnFldUpd l,ValGamInfo $ mk t) | (Just l,t) <- @fldTyL ]
%%]
                                                                       fr dt = tyFreshVar (`Map.member` fv) @lUniq dt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Kind of data fields
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR AllDataField [ | | kiL USE {++} {[]}: TyL ]

SEM DataField
  | Field       lhs         .   kiL                 =   replicate (maybe 1 length @mbLabels) @tyExpr.ki
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Additional info for checks, codegen, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 hmtyinfer)
ATTR AllDataConstr [ isNewtype: Bool | | ]

SEM Decl
  | Data        constrs     .   isNewtype           =   @isNewtype
%%]

%%[(8 hmtyinfer)
ATTR Expr [ | | isNewtype: Bool ]

SEM Expr
  | Con         loc         .   (dgi,_)             =   dataGamLookupErr @nm @lhs.dataGam
                            .   isNewtype           =   dgiIsNewtype @dgi
  | * - Con     lhs         .   isNewtype           =   False
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% DataFieldExpr: additional info for checks, codegen, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
%%]
SEM DataFieldExpr
  | Con         loc         .   finConTy            =   @lhs.finTyVarMp |=> @ty

%%[(7 hmtyinfer)
ATTR DataFieldExpr [ | | mbConNm: {Maybe HsName} ]

SEM DataFieldExpr
  | Con         lhs         .   mbConNm             =   Just @nm
  | * - Con Upd lhs         .   mbConNm             =   Nothing
%%]

%%[(7 hmtyinfer)
ATTR DataFieldExpr [ | | mbDti: {Maybe DataTagInfo} ]

SEM DataFieldExpr
  | Con         loc         .   dti                 =   dgiDtiOfCon @nm @lhs.dgi
                lhs         .   mbDti               =   Just @dti
  | * - Con Upd lhs         .   mbDti               =   Nothing
%%]

%%[(7 hmtyinfer)
ATTR DataFieldExpr [ | | fldL: {[HsName]} ]

SEM DataFieldExpr
  | Upd         lhs         .   fldL                =   @nm : @dataFieldExpr.fldL
  | * - Upd     lhs         .   fldL                =   []

SEM Expr
  | DataFields  loc         .   fldL                =   sortBy rowLabCmp @dataFieldExpr.fldL
                            .   fldS                =   Set.fromList @fldL
%%]

%%[(7 hmtyinfer)
ATTR DataFieldExpr [ dgi: DataGamInfo | | ]

SEM Expr
  | DataFields  loc         .   dgi                 =   let dgiOf t = maybe emptyDataGamInfo id $ dataGamDgiOfTy t @lhs.dataGam
                                                        in  case (@dataFieldExpr.mbConNm,@fldL) of
                                                              (Just c,_)
                                                                -> dgiOf t
                                                                where (_,t,_) = valGamTyOfDataCon c @lhs.valGam
                                                              (_,(f:_))
                                                                -> dgiOf t
                                                                where (_,t,_) = valGamTyOfDataFld f @lhs.valGam
                                                              _ -> panic "Expr.DataFields.dgi"
                            .   dtiL                =   Map.elems $ dgiConstrTagMp @dgi
                            .   (dtiInFldL,dtiOutFldL)
                                                    =   partition (\i -> @fldS `Set.isSubsetOf` Map.keysSet (dtiFldMp i)) $ @dtiL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% GADT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Kind of LHS of the DataConstrEq should match the kind of the RHS.

%%[(16 hmtyinfer)
SEM DataConstrEq
  | Eq          loc         .   fo_                 =   fitsIn weakFIOpts defaultFIEnv @lUniq @tyExpr.kiVarMp @tyVar.ki @tyExpr.ki
                lhs         .   kiVarMp             =   foVarMp @loc.fo_ |=> @tyExpr.kiVarMp
                loc         .   lUniq               :   UNIQUEREF gUniq

ATTR AllDataConstrEq [ | | prOccL USE {++} {[]} : {[PredOcc]} ]

SEM DataConstrEq
  | Eq          loc         .   pr                  =   Pred_Eq @tyVar.ty @tyExpr.ty
                loc         .   prOccId             =   mkPrIdCHR @loc.lUniq3
                loc         .   prOcc               =   rngLift @range mkPredOccRng @loc.pr @loc.prOccId @lhs.predScope
                lhs         .   prOccL              =   [@loc.prOcc]
                loc         .   lUniq3              :   UNIQUEREF gUniq
%%]

Construct a substitution from the additional equations. This subsitution is applied to the type of the constructor function to obtain
the actual type of the constructor, i.e. the additional equations do not show up in the type of a constructor. The equations are required
to be non-cyclic, and in case one equation is multiply defined, the right hand sides have to be equal modulo unification.

%%[(16 hmtyinfer)
SEM AllDataConstrEq [ | eqVarMp : {VarMp} | ]

SEM DataConstr
  | Constr      eqs.eqVarMp  = emptyVarMp
                loc.eqsVarMp = @eqs.eqVarMp

SEM DataConstrEq
  | Eq          loc         .   tv                  =   tyVar @tyVar.ty
                loc         .   knRhsTy             =   maybe Ty_Any id $ varmpTyLookup @loc.tv @lhs.eqVarMp
                loc         .   foRhsTy             =   fitsIn strongFIOpts defaultFIEnv @lUniq2 @lhs.eqVarMp @loc.knRhsTy @tyExpr.ty
                loc         .   unitVarMp           =   @loc.tv `varmpTyUnit` foTy @loc.foRhsTy
                lhs         .   eqVarMp             =   @loc.unitVarMp |=> foVarMp @loc.foRhsTy |=> @lhs.eqVarMp
                loc         .   lUniq               :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pattern: additional info for checks, codegen, etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(7 hmtyinfer)
ATTR DataFieldPatExpr [ | | dti: DataTagInfo ]

SEM DataFieldPatExpr
  | Con         loc         .   dgi                 =   let (_,t,_) = valGamTyOfDataCon @nm @lhs.valGam
                                                        in  panicJust "DataFieldPatExpr.dgi" $ dataGamDgiOfTy t @lhs.dataGam
                            .   dti                 =   dgiDtiOfCon @nm @dgi
%%]

%%[(7 hmtyinfer)
ATTR DataFieldPatExpr [ | | fldL: {[HsName]} ]

SEM DataFieldPatExpr
  | Ext         lhs         .   fldL                =   @nm : @dataFieldPatExpr.fldL
  | * - Ext     lhs         .   fldL                =   []
%%]

Check that LHS of equations is a tyvar in scope
%%[(16 hmtyinfer)
ATTR AllDataConstrEq TyVar [ | | tyvarNms USE {`Set.union`} {Set.empty} : {Set HsName} ]
SEM TyVar
  | Var  lhs.tyvarNms = Set.singleton @nm

SEM DataConstr
  | Constr
      loc.tyVarsInScope = Set.fromList (gamKeys @fields.tyGam)
      loc.undefTyVarsInEqs = @eqs.tyvarNms `Set.difference` @loc.tyVarsInScope
      loc.undefVarsErrSq = if Set.null @loc.undefTyVarsInEqs
                           then Seq.empty
                           else Seq.singleton $
                                  Err_NamesNotIntrod
%%[[99
                                    @range
%%]]
                                    "" [(pp nm, Nothing) | nm <- Set.toList @loc.undefTyVarsInEqs]

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type signatures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(99 hmtyinfer)
%%]
SEM DataConstr
  | Constr      loc         .   arity               :   {Int}
