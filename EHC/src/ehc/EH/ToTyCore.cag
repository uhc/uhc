%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Is main body 'main'?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen).mainUseExists
SEM AGItf
  | AGItf       loc         .   mainUseExists
                                            =   case @expr.letTCBody of
                                                  Expr_Var n | n == hsnMain -> True
                                                  _                          -> False
                            .   insertMainUse
                                            =   not @mainUseExists
%%]

%%[(2020 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainUse
                                            :=  not @mainUseExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Does a binding for main exist?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen).mainDefExists
SEM AGItf
  | AGItf       loc         .   mainDefExists
                                            =   let ds = [ b | (_,g) <- @expr.letValBindL, b <- g, C.valBindNm b == hsnMain ]
                                                in  not (null ds)
                            .   insertMainDef
                                            =   not @mainDefExists
%%]

%%[(2020 codegen)
SEM AGItf
  | AGItf       loc         .   insertMainDef
                                            :=  not @mainDefExists && @lhs.isMainMod
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: utils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen) hs
ctyLookup :: TyKiGam -> HsName -> ValGam -> C.Ty
ctyLookup tkg nm g = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi tkg) $ fst $ valGamLookupTy nm g

ctyFromTy :: TyKiGam -> VarMp -> Ty -> C.Ty
ctyFromTy tkg m t = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi tkg) (m |=> t)

ctyBareFromTy :: VarMp -> Ty -> C.Ty
ctyBareFromTy m t = C.tyToTyCoreBare (m |=> t)
%%]

%%[(8 codegen) hs
ctyCloseExists :: C.Ty -> (C.Ty,C.Expr -> C.Expr)
ctyCloseExists t
  = case C.unTySeq t of
      (C.Expr_Exists s te) -> (te,C.Expr_CloseExists (C.tyL0BindToL1Bind s) (C.tyErr "ctyCloseExists.tyClosed") t)
      _                    -> (t ,id)

%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: redo all fitting, but now against complete(d) types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 hmtyinfer codegen)
SEM Expr
  | Var Con     loc         .   fo_fin      =   @doFit (@lhs.fiOpts {fioExpandEqTyVar=True}) @lhs.finTyVarMp
  | Lam         loc         .   fo_fin      =   @doFit (@knFunFIOpts {fioExpandEqTyVar=True}) @lhs.finTyVarMp
%%[[9
  | AppTop      loc         .   fo_fin      =   @doFit (@lhs.fiOpts {fioExpandEqTyVar=True}) @lhs.finTyVarMp
%%]]
%%[[12
  | LamImpl     loc         .   fo_fin      =   @doFit (implFIOpts {fioBindRFirst=True, fioExpandEqTyVar=True}) @lhs.finTyVarMp
%%]]
%%]

%%[(8 hmtyinfer codegen)
SEM Decl
  | Val         loc         .   doFit       =   \o m -> fitsIn o @fe @lUniq_fo m @expr.ty @exprKnTy
                            .   fo_fin      =   @doFit (@exprFiOpts {fioExpandEqTyVar=True}) @lhs.finTyVarMp
                loc         .   lUniq_fo    :   UNIQUEREF gUniq

SEM DataConstr
  | Constr      loc         .   doFit       =   \o m -> fitsIn o @fe @lUniq_fo m @dataConTy @dataConTyAsVar
                            .   fo_fin      =   @doFit (strongFIOpts {fioExpandEqTyVar=True}) @lhs.finTyVarMp
                loc         .   lUniq_fo    :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: down passing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllExpr AllPatExpr AllCase [ ctyTopDown: {C.Ty} | | ]
ATTR AllCase [ ctyPatTopDown: {C.Ty} | | ]

SEM Expr
  | IConst      loc         .   cty         =   C.mkTySeq C.tyInt
  | Var Con     loc         .   cty         =   ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @ty_g_
  | Lam         
%%[[12
    LamImpl
%%]]
                loc         .   ctyTopDownArgBase
                                            =   C.cSubstApp @tcSubstLamSpine @ctyLamArg
                            .   ctyTopDownResBase
                                            =   C.cSubstApp @tcSubstLamSpine @ctyLamRes
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   ctyTopDownArgBase
                                            =   C.cSubstApp @func.tcSubstAppSpine $ C.tyUnThunkTySeq $ C.unTySeq @ctyAppArg
                loc         .   cty         =   @ctyTyAppRes
  | * - Var Con IConst App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   cty         =   @lhs.ctyTopDown

SEM PatExpr
  | AppTop Rec  loc         .   ctyPat      =   C.mkTySeq $ ctyFromTy @lhs.finTyKiGam emptyVarMp @finKnPatTy -- @lhs.finTyVarMp @knPatTy

SEM PatExpr
  | Var         loc         .   cty         =   @lhs.ctyTopDown
  | AppTop      loc         .   cty         =   C.mkTyThunk @ctyPat

SEM Decl
  | Val         loc         .   cty         =   ctyLookup @lhs.finTyKiGam @patExpr.topNm @lhs.finValGam
                            .   ctyBind     =   if @lhs.isStrict then @cty else C.mkTyThunk @cty
  | Data        loc         .   cki         =   C.tyToTyCoreKi $ @lhs.finKiVarMp |=> tkgiKi @dataTkgi -- $ tkgiKi $ fst $ tyKiGamLookupByNameErr @tyNm @lhs.finTyKiGam
%%]

%%[(8 codegen)
SEM AGItf
  | AGItf       expr        .   ctyTopDown  =   C.tyErr "AGItf.AGItf.ctyTopDown"

SEM Expr
  | Lam         
%%[[12
    LamImpl
%%]]
                arg         .   ctyTopDown  =   @ctyTopDownArgBase
                (body.ctyTopDown,loc.closeExistsWrap)
                                            =   ctyCloseExists @ctyTopDownResBase
  | Case        alts        .   ctyPatTopDown
                                            =   @expr.ctyBotUp
  | App AppImpred
%%[[12
    AppImpl
%%]]
                arg         .   ctyTopDown  =   @ctyTopDownArgBase

SEM Decl
  | Val         loc         .   ctyTopDown  =   C.tyUnThunkTySeq @ctyBind

SEM PatExpr
  | App         arg         .   ctyTopDown  =   C.cSubstApp @lhs.tcSubstPatSpine $ C.mkTyThunk $ ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @knArgTy

SEM RecPatExpr
  | Ext         patExpr     .   ctyTopDown  =   C.cSubstApp @lhs.tcSubstPatSpine $ C.mkTyThunk $ ctyFromTy @lhs.finTyKiGam @lhs.finTyVarMp @patTy

SEM CaseAlt
  | Pat         patExpr     .   ctyTopDown  =   @lhs.ctyPatTopDown
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: up passing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | ctyBotUp: {C.Ty} ]

SEM Expr
  | *
                loc         .   ctyBotUp    =   @ctyTyAppRes
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: splitting into args/res for App
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instantiation info [InstTo] drives the splitting up into type and value args.
For now this is extracted from value bindings only, but must be done for other constructs as well.

%%[(8 codegen)
ATTR Expr [ | | appInstToL: {[InstTo]} ]
%%]

%%[(8 codegen)
SEM Expr
  | Var Con     
%%[[9
    AppTop
%%]]
                loc         .   (appInstToLHere,appInstToL)
                                            =   instToSplitQu (foLInstToL @fo_fin)
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (appInstToLHere,appInstToL)
                                            =   instToSplitQu $ drop 1 @func.appInstToL
  | * - Var Con App AppImpred
%%[[9
    AppTop
%%]]
%%[[12
    AppImpl
%%]]
                loc         .   appInstToLHere
                                            =   []
                            .   appInstToL  =   []
%%]

%%[(8 codegen)
SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (ctyTyAppArgL,ctyAppArg,ctyTyAppRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_ArgBefore @appInstToLHere @func.ctyBotUp
  | * - App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   (ctyTyAppArgL,_,ctyTyAppRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_InstOnly @appInstToLHere @cty
%%]

%%[(8 codegen)
SEM Expr
  | *           loc         .   tcTyArgAppWrap
                                            =   \e -> foldr (flip C.Expr_App) e $ @tcSubstAppSpine `C.cSubstApp` map C.tyL0BindToL1Val @ctyTyAppArgL
                            .   tcTyArgLamWrap
                                            =   \e -> foldr C.Expr_Lam e $ map (C.cSubstAppExprAndBinds @lhs.tcSubstLamSpine . C.tyL0BindToL1Bind) @ctyTyLamArgL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: splitting into args/res for Lam
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Instantiation info [InstTo] drives the splitting up into type and value args,
see remarks for appInstToL.

%%[(8 codegen)
ATTR Expr [ lamInstToL: {[InstTo]} | | ]
%%]

%%[(8 codegen)
SEM Decl
  | Val         loc         .   lamInstToL  =   foRInstToL @fo_fin
%%]

%%[(8 codegen)
SEM Expr
  | Lam         
%%[[12
    LamImpl
%%]]
                loc         .   (lamInstToLHere,lamInstToL)
                                            =   let lamInstToL = if @lhs.isTopLam then foRInstToL @fo_fin else @lhs.lamInstToL
                                                in  instToSplitQu lamInstToL
                body        .   lamInstToL  =   drop 1 @lamInstToL
                            
  | * - Lam
%%[[12
    LamImpl
%%]]
                loc         .   (lamInstToLHere,lamInstToL)
                                            =   instToSplitQu @lhs.lamInstToL
%%]

%%[(8 codegen)
SEM Expr
  | Lam         
%%[[12
    LamImpl
%%]]
                loc         .   (ctyTyLamArgL,ctyLamArg,ctyLamRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_ArgAfter @lamInstToLHere @lhs.ctyTopDown
                            .   ctyLamArgHere
                                            =   @tcSubstLamSpine `C.cSubstApp` C.unTySeq @ctyLamArg
  | * - Lam
%%[[12
    LamImpl
%%]]
                loc         .   (ctyTyLamArgL,_,ctyTyLamRes)
                                            =   C.tyArrowInstQuArgsRes C.ArrowDecompose_InstOnly @lamInstToLHere @lhs.ctyTopDown
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: matching, in relation to type inference'd types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the instantiation of a lambda
ATTR Expr [ | | tcSubstAppSpine: {C.CSubst} ]
%%]

%%[(8 codegen)
SEM Expr
  | Var Con     loc         .   ctyForMatch =   ctyBareFromTy @lhs.finTyVarMp @ty_g_
%%]

%%[(8 codegen)
SEM Expr
  | Var Con     loc         .   moutFun     =   C.tyMatchBind @ctyForMatch $ ctyBareFromTy @lhs.finTyVarMp @ty
                            .   tcSubstAppSpine
                                            =   C.moutCSubst @moutFun
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcSubstAppSpine
                                            =   @func.tcSubstAppSpine
  | * - Var Con App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcSubstAppSpine
                                            =   C.emptyCSubst
%%]

%%[(8 codegen)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the abstraction of a lambda
ATTR Expr [ tcSubstLamSpine: {C.CSubst} | | ]
%%]

%%[(8 codegen)
SEM Decl
  | Val         loc         .   ctyExprKnTy =   ctyBareFromTy @lhs.finTyVarMp @exprKnTy
                            .   ctyExprTy   =   ctyBareFromTy @lhs.finTyVarMp @expr.ty
                            .   moutExpr    =   C.tyMatchBind @ctyExprKnTy @ctyExprTy
                            .   tcSubstLamSpine
                                            =   C.moutCSubst @moutExpr
%%]

%%[(8 codegen)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstLamSpine
                                            =   @lhs.tcSubstLamSpine
  | * - Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstLamSpine
                                            =   C.emptyCSubst
%%]

%%[(8 codegen)
-- the CSubst binding Ty tvars to TyCore Ty vars, to propagate the @lhs.ctyTopDown over constituents
ATTR AllPatExpr [ tcSubstPatSpine: {C.CSubst} | | ]
%%]

%%[(8 codegen)
SEM CaseAlt
  | Pat         loc         .   tcSubstPatSpine
                                            =   C.emptyCSubst
SEM Decl
  | Val         loc         .   tcSubstPatSpine
                                            =   C.emptyCSubst
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcSubstPatSpine
                                            =   C.emptyCSubst
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop Rec  loc         .   moutPat     =   C.tyMatchBind @ctyPat $ C.tyUnThunkTySeq @lhs.ctyTopDown
                            .   tcSubstPatSpine
                                            =   C.moutCSubst @moutPat
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% TyCore's Ty: defaults
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM AGItf
  | AGItf       expr        .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst

SEM CaseAlt
  | Pat         expr        .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst

SEM DataFieldExpr RecExpr
  | Expr Upd    expr        .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst

SEM RecExpr
  | Ext         expr        .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst

%%[[9
SEM Decl
  | InstanceIntro
%%[[94
    FFE
%%]]
                expr        .   ctyTopDown  =   C.tyErr "Decl.InstanceIntro.ctyTopDown"
                            .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst
%%]]

%%[[97
SEM PatExpr
  | Expr        expr        .   ctyTopDown  =   C.tyErr "PatExpr.Expr.ctyTopDown"
                            .   lamInstToL  =   []
                            .   tcSubstLamSpine
                                            =   C.emptyCSubst
%%]]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Strictness
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllDecl [ isStrict: Bool | | ]

SEM Expr
  | Let         loc         .   howToValBind=   if @isStrict then C.ValBindCateg_Strict else C.ValBindCateg_Rec
                decls       .   isStrict    =   @isStrict
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Code substitution
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen hmtyinfer)
ATTR NTCode [ | tcSubst: {C.CSubst} | ]

SEM AGItf
  | AGItf       loc         .   tcSubst             =   C.emptyCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Generation of core
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AGItf [ | | tcmodule: {C.Module} ]
%%]

For now:

%%[(8 codegen)
SEM AGItf
  | AGItf       lhs         .   tcmodule    =   let -- b = if @insertMainUse then Expr_Var hsnMain else @expr.letTCBody
                                                    -- d = if @insertMainDef then mkExprLet C.ValBindCateg_Plain [C.mkValBind1 hsnMain @expr.letTCBody] else id
                                                    tyBindL = concatMap snd $ @expr.letTyBindL
                                                in  C.Module_Mod @lhs.moduleNm
                                                      [] -- [ (tn,Map.toList m) | (tn,dgi) <- gamToAssocL @expr.gathDataGam, not (dgiIsNewtype dgi), let m = Map.map dtiCTag $ dgiConstrTagMp dgi ]
                                                      ( tyBindL ++
                                                        map
                                                          (C.cSubstAppValBind True @expr.tcSubst)
                                                          (concatMap snd $
                                                             (@extraValBindL ++ @expr.frontValBindL ++ @expr.letValBindL
%%[[94
                                                             ++ @expr.backValBindL
%%]]
                                                      )   )  )
                loc         .   extraValBindL
                                            =   []
%%]

%%[(9 codegen)
SEM AGItf
  | AGItf       loc         .   extraValBindL
                                            :=  [(C.ValBindCateg_Rec,@chrScopeMainBindLTC)]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% C.Expr
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | tcexpr: {C.Expr} ]
%%]

%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst      loc         .   tcexprBase  =   C.Expr_Int (toInteger @int) @cty
  | CConst      loc         .   tcexprBase  =   C.Expr_Char @char @cty
  | Var         loc         .   tcexprBase  =   C.mkExprUnThunk $ C.Expr_Var @nm
  | Con         loc         .   tcexprBase  =   C.mkExprUnThunk $ C.Expr_Var @nm
  | SConst      loc         .   tcexprBase  =   C.tcString @lhs.opts @str
%%[[97
  | IIConst     loc         .   tcexprBase  =   C.tcInteger @lhs.opts @integer
%%]]
%%]

%%[(8 codegen noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
                loc         .   (tcexpr,tcexprCSubst)
                                            =   foAppLRTCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @lhs.tcSubst $ @tcTyArgLamWrap $ @tcTyArgAppWrap @tcexprBase
                lhs         .   tcSubst     =   C.cSubstApp @lhs.tcSubst @tcexprCSubst
  | Let         loc         .   frontValBindL
                                            =   [(C.ValBindCateg_FFI,@decls.ffiValBindL)]
%%[[94
                            .   backValBindL=   [(C.ValBindCateg_FFE,@decls.ffeValBindL)]
%%]
                            .   letTyBindL  =   [(@howToValBind,@decls.tyBindL)]
                            .   letValBindL =   [(@howToValBind,@decls.valBindL)]
                            .   letValBindOtherL
                                            =   []
                            .   tcexpr      =   foldr (\(c,b) e -> C.mkExprLet c b e) @letTCBody @letTCValBindRemL
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   tcexprArg   =   @arg.tcexpr
                            .   tcexprThArg =   C.mkExprThunk @tcexprArg
                            .   (tcexprapp,tcexprappCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @arg.tcSubst @appImplsCoeLTC []
                                                    (f ,s2)   = C.coeEvalOnAsSubst u2 ww @func.tcexpr
                                                in  (@tcTyArgLamWrap $ @tcTyArgAppWrap $ C.mkExprApp1 f @tcexprThArg, s1 `C.cSubstApp` s2)
                            .   tcexpr      =   if @func.isNewtype then @tcexprArg else @tcexprapp
                lhs         .   tcSubst     =   C.cSubstApp @arg.tcSubst @tcexprappCSubst
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   tcArgWrap   =   \e -> C.rceMatch @rceEnvTC [(@arg.topNm,@ctyLamArgHere)] [C.RAlt_Alt [@arg.rpatTC] e Set.empty] -- @body.caseFailS]
                            .   (tcexpr,tcexprlamCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @body.tcSubst @lamBodyCoeLTC @lamArgCoeLTC
                                                    (b ,s2)   = C.coeEvalOnAsSubst u2 ww @body.appFunExprTC
                                                in  (@tcTyArgLamWrap b, s1 `C.cSubstApp` s2)
                lhs         .   tcSubst     =   C.cSubstApp @body.tcSubst @tcexprlamCSubst
  | AppTop      loc         .   tcexprtop   =   @expr.tcexpr
                            .   tcSubstTop  =   @expr.tcSubst
  | Rec         loc         .   tcexprtop   =   @rtcexpr
                            .   tcSubstTop  =   @recExpr.tcSubst
  | AppTop Rec  loc         .   (tcexpr,tcexprapptopCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (ww,s1)   = C.coeWipeWeaveAsSubst2 @lhs.opts u1 @lhs.finTyVarMp @tcSubstTop [] @lamArgCoeLTC
                                                    (e ,s2)   = C.coeEvalOnAsSubst u2 ww @tcexprtop
                                                in  (e, s1 `C.cSubstApp` s2)
  | AppTop      lhs         .   tcSubst     =   C.cSubstApp @expr.tcSubst @tcexprapptopCSubst
  | Rec         lhs         .   tcSubst     =   C.cSubstApp @recExpr.tcSubst @tcexprapptopCSubst
  | Ann         loc         .   tcexpr      =   @tcTyArgLamWrap $ @tcTyArgAppWrap @expr.tcexpr
  | TypeAs      loc         .   (tcexpr,tcexprtypeasCSubst)
                                            :=  let (_,u1,u2) = mkNewLevUID2 @lUniq_cexpr
                                                    (e1,s1)   = foAppLRTCoeAsSubst @lhs.opts u1 @fo_fitDown @lhs.finTyVarMp @expr.tcSubst @expr.tcexpr
                                                    (e2,s2)   = foAppLRTCoeAsSubst @lhs.opts u2 @fo_        @lhs.finTyVarMp @expr.tcSubst e1
                                                in  (e2, s1 `C.cSubstApp` s2)
                lhs         .   tcSubst     =   C.cSubstApp @expr.tcSubst @tcexprtypeasCSubst
  | Case        loc         .   tcexpr      =   let (ns,bs,as)
                                                      = if @isTupOfArg
                                                        then let ns = [ (n, ty "1" n) | (C.Expr_Var n) <- C.fuL2ExprL (reverse @expr.tcfuExprL) ]
                                                             in  (ns,[],@alts.raltTCL')
                                                        else let n = uidHNm @lUniq2
                                                             in  ([(n, ty "2" n)],[C.mkValBind1 n (ty "3" n) @expr.tcexpr],@alts.raltTCL)
                                                    ty m n = C.tyErr ("Expr.Case.tcexpr." ++ m ++ ": " ++ show n)
                                                in  C.mkExprLet C.ValBindCateg_Plain bs (C.rceMatch @rceEnvTC ns as)
  | CaseAltFail loc         .   tcexpr      =   C.Expr_CaseAltFail @caseId (C.tcError @lhs.opts ("FAIL " ++ show @caseId))
  | Undefined   loc         .   tcexpr      =   C.tcUndefined @lhs.opts
  | Parens      loc         .   tcexpr      =   @expr.tcexpr
%%]

%%[(9 codegen)
SEM Expr
  | Let         loc         .   letValBindOtherL
                                            :=  [ (C.ValBindCateg_Rec,@chrScopeBindLTC) ]
%%]

%%[(10 codegen)
SEM Expr
  | DynVar      loc         .   tcexpr      =   C.tcUndefined @lhs.opts
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   tcexprBaseEq=   C.Expr_Var @eqFldNm
                            .   (tcexpr,tcexprpatCSubst)
                                            =   let (e,s) = foAppLRTCoeAsSubst @lhs.opts @lUniq_cexpr @fo_ @lhs.finTyVarMp @expr.tcSubst @tcexprBaseEq
                                                in  (C.mkExprApp e [@expr.tcexpr], s)
                lhs         .   tcSubst     =   C.cSubstApp @expr.tcSubst @tcexprpatCSubst
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr: lam arg code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | tcLamArgs: {[(HsName,C.Expr->C.Expr)]} ]
ATTR Expr [ | | tcLamBody: {C.Expr} ]

SEM Expr
  | Lam         lhs         .   tcLamArgs   =   (@arg.topNm,@tcArgWrap) : @body.tcLamArgs
                            .   tcLamBody   =   @body.tcLamBody
  | * - Lam     lhs         .   tcLamArgs   =   []
                            .   tcLamBody   =   @tcexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Expr: CExpr stuff: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   tcexpr      =   Expr_Int  @int
  | CConst      loc         .   tcexpr      =   Expr_Char @char
  | Var         loc         .   tcexpr      =   Expr_Var  @nm
  | Con         loc         .   tcexpr      =   Expr_Var  @nm
%%[(8888 codegen)

SEM Expr
%%]

-- generated from ruler rules into EHRulerRules
  | IConst      loc         .   tcexprBase  :=  Expr_Int @int
  | CConst      loc         .   tcexprBase  :=  Expr_Char @char
  | Var         loc         .   tcexprBase  :=  Expr_Var @nm
  | Var IConst CConst
                loc         .   tcexpr      :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @tcexprBase
  | Con         loc         .   tcexprBase  :=  Expr_Var @nm
                            .   tcexpr      :=  foAppCoe @lhs.opts @fo_ @lhs.finTyVarMp @lhs.cSubst @tcexprBase

-- between variant 5 .. 99, reconstruction of AG rules, getting rid of ruler3 until Arie's ruler4 can be used
%%[(8888 codegen noHmTyRuler)
SEM Expr
%%]

%%[(8888 codegen noHmTyRuler)
SEM Expr
  | IConst CConst SConst Var Con
%%[[97
    IIConst
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]]
%%]

%%[(9999 codegen)
SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | AppTop      loc         .   lUniq_cexpr :   UNIQUEREF gUniq
  | TypeAs      loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%[(99997 codegen)
SEM PatExpr
  | Expr        loc         .   lUniq_cexpr :   UNIQUEREF gUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | Rec         loc         .   rtcexpr         =   
%%[[10  
                                                    if  not (@recExpr.isExtFromEmpty)
                                                    then  C.fuMkExpr @lhs.opts @lUniq3 (reverse @recExpr.tcfuExprL) @recExpr.tcrecExpr
                                                    else
%%]]                                                    
                                                          C.Expr_Node {- CTagRec -} $ C.fuL2ExprNodeFldL True Just $ tyRowCanonOrder @recExpr.tcfuExprL
%%]
                                                          foldl C.mkExprApp1 (C.Expr_Tup CTagRec)
                                                            $ C.fuL2ExprL $ tyRowCanonOrder $ @recExpr.tcfuExprL

%%[(8888 codegen)
SEM Expr
  | Rec         
%%[[10
                loc         .   lUniq3          :   UNIQUEREF gUniq
%%]]
%%]

%%[(8 codegen)
ATTR RecExpr [ | | tcrecExpr: {C.Expr} ]
ATTR RecExpr Expr [ | | tcfuExprL: {C.FieldUpdateL C.Expr} ]

SEM RecExpr
  | Empty       loc         .   tcrecExpr       =   C.mkExprTuple []
                lhs         .   tcfuExprL       =   []
  | Expr        loc         .   tcrecExpr       =   @expr.tcexpr
                lhs         .   tcfuExprL       =   []
  | Ext         loc         .   rtcexpr         =   C.Expr_TupIns @recExpr.tcrecExpr CTagRec @nm @tcoffset @expr.tcexpr
  | Upd         loc         .   rtcexpr         =   C.Expr_TupUpd @recExpr.tcrecExpr CTagRec @nm @tcoffset @expr.tcexpr
  | Ext Upd     lhs         .   tcfuExprL       =   if @knRecHasLab
                                                    then (@nm,(@rtcexpr,Nothing)) : @recExpr.tcfuExprL
                                                    else @recExpr.tcfuExprL

SEM Expr
  | * - Rec     lhs         .   tcfuExprL       =   []
%%]

%%[(8888 codegen)
ATTR RecExpr [ | | isExtFromEmpty: Bool ]

SEM RecExpr
  | Empty       lhs         .   isExtFromEmpty  =   True
  | Expr        lhs         .   isExtFromEmpty  =   False
  | Upd         lhs         .   isExtFromEmpty  =   not @knRecHasLab && @recExpr.isExtFromEmpty
  | Ext         lhs         .   isExtFromEmpty  =   @recExpr.isExtFromEmpty
%%]

%%[(8 codegen)
SEM RecExpr
  | Ext Upd     loc         .   tcoffset        =   C.tcInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @nm @recExpr.ty)
%%]

%%[(1010 codegen)
SEM RecExpr
  | Ext Upd     loc         .   offset          :=  C.cSubstApp @expr.tcSubst $ C.mkExprPrHole @lhs.opts @prUid
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data based records, construction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | DataFields  loc         .   tcdfexpr    =   let mkTup dti mkDflt con
                                                      = C.Expr_Node {- (dtiCTag dti) -}
                                                        . C.fuL2ExprNodeFldL True (const Nothing)
                                                        . listSaturateWith 0 (ctagArity (dtiCTag dti) - 1) (\(_,(_,Just o)) -> o) dflt
                                                        . C.fuMap (\l mke -> let o = dtiOffsetOfFld l dti in (mke dti o,o))
                                                      where dflt = [ (o,(f,(C.Expr_TupIns (C.tcUndefined @lhs.opts) (dtiCTag dti) f (C.tcInt o) (mkDflt f),Just o)))
                                                                   | (f,i) <- Map.toList $ dtiFldMp dti, let o = dfiOffset i
                                                                   ]
                                                    ty m x = C.tyErr ("Expr.DataFields." ++ m ++ ": " ++ show x)
                                                in  if dgiIsNewtype @dgi
                                                    then C.mkExprLet C.ValBindCateg_Plain @dataFieldExpr.dfeValBindL
                                                         $ head $ C.fuL2ExprL $ C.fuMap (\_ f -> (f emptyDataTagInfo 0,0)) $ @dataFieldExpr.tcfuExprL
                                                    else case @dataFieldExpr.mbConNm of
                                                           Just conNm
                                                             -> C.mkExprLet C.ValBindCateg_Plain @dataFieldExpr.dfeValBindL
                                                                  (mkTup (dgiDtiOfCon conNm @dgi) (const $ C.tcUndefined @lhs.opts) @dataFieldExpr.tcdfeExpr @dataFieldExpr.tcfuExprL)
                                                           _ -> C.mkExprLet C.ValBindCateg_Plain (err ++  @dataFieldExpr.dfeValBindL)
                                                                  (C.mkExprSatSelsCases (C.rceUpdEnv (C.Expr_Var en) @rceEnvTC) (Just (mkHNm @lUniq,ty "1" @lUniq)) @dataFieldExpr.tcdfeExpr alts)
                                                             where alts = [ ( dtiCTag dti
                                                                            , [ (f,{-f,-}dfiOffset i) | (f,i) <- Map.toList $ dtiFldMp dti ]
                                                                            , Nothing
                                                                            , mkTup dti C.Expr_Var (C.mkExprTuple' (dtiCTag dti) (C.tyErr "Expr.DataFields.mkExprTuple")) @dataFieldExpr.tcfuExprL
                                                                            )
                                                                          | dti <- @dtiInFldL
                                                                          ]
                                                                   err = [C.mkValBind1 en (ty "error" en) (C.tcError @lhs.opts ("has no field update '" ++ show @fldL ++ "'"))]
                                                                   en = mkHNm "_upd_error"
                            .   tcexpr      =   @tcdfexpr
%%]

%%[(8 codegen)
ATTR
  DataFieldExpr
    [ | | tcdfeExpr: {C.Expr}
          dfeValBindL: {C.ValBindL}
          tcfuExprL: {C.FieldUpdateL (DataTagInfo -> Int -> C.Expr)}
    ]

SEM DataFieldExpr
  | Upd         lhs         .   tcfuExprL   =   let mke dti o = C.Expr_TupIns @dataFieldExpr.tcdfeExpr (dtiCTag dti) @nm (C.tcInt o) (C.Expr_Var @fldExprNm)
                                                in  (@nm,(mke,Nothing)) : @dataFieldExpr.tcfuExprL
                            .   dfeValBindL =   let ty n = C.tyErr ("DataFieldExpr.Upd.fld: " ++ show n)
                                                in  C.mkValBind1 @fldExprNm (ty @fldExprNm) @expr.tcexpr : @dataFieldExpr.dfeValBindL
  | Con         lhs         .   tcdfeExpr   =   C.Expr_Tup (dtiCTag @dti)
                            .   tcfuExprL   =   []
                            .   dfeValBindL =   []
  | Expr        loc         .   tcdfeExpr   =   @expr.tcexpr
                            .   tcfuExprL   =   []
                            .   dfeValBindL =   []
%%]

%%[(8888 codegen)
SEM DataFieldExpr
  | Upd         loc         .   fldExprNm   =   mkHNm @lUniq
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Row based records, dissection
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | Sel         loc         .   tcoffset    =   C.tcInt (tyRecOffsetWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @lbl @expr.ty)
                            .   tcexpr      =   let  [n1,n2] = map uidHNm . mkNewUIDL 2 $ @lUniq_fresh
                                                     ty n = C.tyErr ("Expr.Sel.fld: " ++ show n)
                                                in   C.mkExprSelCase @rceEnvTC (Just (n1,ty n1)) @expr.tcexpr CTagRec n2 {- @lbl -} @tcoffset Nothing
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data constr wrapper
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM DataConstr
  | Constr      loc         .   ctyDataCon  =   C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) @finDataConTy
                lhs         .   valBindL    =   let len = length @fields.fldTyL
                                                    nms = map (\i -> hsnFromString ("x" ++ show i)) [1..len]
                                                in  [ C.mkValThunkBind1 @conNm @ctyDataCon
                                                         (let (mk,(args,res)) = C.tcMergeLamTySeqAndArgNms @ctyDataCon nms
                                                          in  mk (if @lhs.isNewtype
                                                                  then C.mkCast (C.tyUnThunkTySeq $ head args) res
                                                                       $ C.mkExprUnThunk $ C.Expr_Var $ head nms
                                                                  else -- C.mkCast (C.mkTySeq $ C.Expr_Node @ctag [ C.ExprSeq1_L0Val a Nothing | a <- args ] ) res
                                                                       C.mkInject @ctag res
                                                                       $ C.Expr_Node {- @ctag -} $ C.fuL2ExprNodeFldL False (const Nothing) [ (n,(C.Expr_Var n,Nothing)) | n <- nms ]
                                                                   -- C.mkExprApp (C.Expr_Tup @ctag) (map C.Expr_Var nms)
                                                         )       )
                                                    ]
%%]
                
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data field selector
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
SEM Decl
  | Data        loc         .   fldSelValBindL
                                            =   let (xn1:xn2:_) = hsnLclSupply
                                                    tgSels f i = [ (t,[(f,o)],Nothing,C.Expr_Var f) | (t,o) <- Map.toList $ dficInTagMp i ]
                                                    dataTy = C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam) @dataTy
                                                in  if @isNewtype
                                                    then [ [ C.mkValThunkBind1 f (C.Expr_Var $ ehbnId $ ehcOptBuiltinNames @lhs.opts)
                                                           | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         ] ]
                                                    else [ [ C.mkValThunkBind1 f
                                                               (mkExprLam [xn1]
                                                                 (mkExprSatSelsCases (C.rceUpdEnv (C.Expr_Var en) @rceEnvTC) (Just xn2) (C.Expr_Var xn1) (tgSels f i)))
                                                           , C.mkValBind1 en (cerror @lhs.opts ("has no field selection '" ++ show f ++ "'"))
                                                           ]
                                                         | (f,i) <- Map.toList $ dgiFldInConstrMp @dgi
                                                         , let en = hsnUniqifyStr HsNameUniqifier_New "datafield_sel_error" f -- hsnSuffix f "_datafield_sel_error"
                                                         ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: all bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
SEM Decl
  | Data        lhs         .   valBindL    =   concat @fldSelValBindL ++ @constrs.valBindL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Data: type bindings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Decl
  | Data        loc         .   ctyData     =   let t = if @isNewtype
                                                        then snd (snd (tyRecExts2 @dataAltTy !! 0) !! 0)
                                                        else @dataAltTy
                                                in  C.tyToTyCore fitsInForToTyCore (tyKiGamLookupKi @lhs.finTyKiGam)
                                                    $ ((assocTyLToVarMp $ zipWith (\t n -> (tyVar t, semCon n)) @tyVars.tyL @tyVars.nmL) |=>)
                                                    $ t
                lhs         .   tyBindL     =   let nms = @tyVars.nmL
                                                    (mk,_) = C.tcMergeLamTySeq1AndArgNms @cki nms
                                                in  [ C.mkTyBind1 @tyNm @cki (mk @ctyData)
                                                    ]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR PatExpr [ | | rpatTC: {C.RPat} ]

SEM PatExpr
  | IConst      loc         .   rpatTC      =   C.RPat_Int @tcpNm C.tyInt (toInteger @int)
  | CConst      loc         .   rpatTC      =   C.RPat_Char @tcpNm C.tyChar @char
  | SConst      loc         .   rpatTC      =   C.RPat_Int @tcpNm C.tyInt (-1) -- for now
  | Var         loc         .   rpatTC      =   C.RPat_Var @tcpNm @cty
  | VarAs       loc         .   rpatTC      =   @patExpr.rpatTC {C.rcpPNm = @tcpNm}
  | Con         loc         .   rpatTC      =   C.RPat_Con @tcpNm (C.tyErr "PatExpr.Con.rpatTC") @tag (C.RPatConBind_One C.PatRest_Empty [])
  | AppTop      loc         .   rpatTC      =   C.RPat_Con @tcpNm @cty {- (C.tyErr "PatExpr.AppTop.rpatTC") -} @tag (C.RPatConBind_One @tcrest (map fst @rpatValBinds))
  | Rec         loc         .   rpatTC      =   case @tcrest of
                                                    C.PatRest_Empty
                                                      ->  C.RPat_Con @tcpNm (C.tyErr "PatExpr.Rec.Empty.rpatTC") @tag (C.RPatConBind_One @tcrest (map fst @rpatValBinds))
                                                    C.PatRest_Var r
                                                      ->  C.RPat_Con @tcpNm (C.tyErr "PatExpr.Rec.Var.rpatTC") @tag (C.RPatConBind_One @tcrest pbL)
                                                          where  pbL = map fst $ C.fsL2PatOffsetL $ C.fsLReorder @lhs.opts $ reverse $ @tcfsRPatL
  | DataFields  loc         .   rpatTC      =   C.RPat_Con @tcpNm (C.tyErr "PatExpr.DataFields.rpatTC") @tag
                                                    (C.rpatConBindUnFlatten (C.RPatConBind_One @tcrest $ map fst @rpatValBind0)
                                                     $ map (C.RPatConBind_One @tcrest . map fst)
                                                           @rpatValBindss
                                                    )
  | Irrefutable loc         .   rpatTC      =   C.RPat_Irrefutable @tcpNm (C.tyErr "PatExpr.Irrefutable.rpatTC") @patExpr.valBindL
%%]

%%[(97 codegen)
SEM PatExpr
  | Expr        loc         .   rpatTC      =   C.RPat_BoolExpr @tcpNm (C.tyErr "PatExpr.Expr.rpatTC") @tcexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rest of Pat (for extensible records)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllPatExpr [ | | patTCRest: {C.PatRest} ]

SEM RecPatExpr
  | Empty       lhs         .   patTCRest   =   C.PatRest_Empty
  | Ext         lhs         .   patTCRest   =   @recPatExpr.patTCRest

SEM DataFieldPatExpr
  | Con         lhs         .   patTCRest   =   C.PatRest_Empty
  | Ext         lhs         .   patTCRest   =   @dataFieldPatExpr.patTCRest

SEM PatExpr
  | Var         lhs         .   patTCRest   =   C.PatRest_Var @nm
  | * - Var     lhs         .   patTCRest   =   C.PatRest_Empty
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tcrest      =   C.PatRest_Empty
  | Rec         loc         .   tcrest      =   @recPatExpr.patTCRest
  | DataFields  loc         .   tcrest      =   @dataFieldPatExpr.patTCRest
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat tag
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
SEM PatExpr
  | AppTop Con  loc         .   tag         =   let  (c,_)  = tyAppFunArgs @finKnPatTy -- tyAppFunArgsWithLkup (varmpTyLookupCyc2 @lhs.finTyVarMp) @knPatTy
                                                     dgi    = panicJust ("PatExpr.{AppTop,Con}.dgi: " ++ show (tyConNm c))
                                                              $ dataGamLookup (tyConNm c) $ @lhs.dataGam
                                                in   dtiCTag
                                                     $ panicJust ("PatExpr.{AppTop,Con}.tag: " ++ show (tyConNm c) ++ "." ++ show @appFunNm)
                                                     $ Map.lookup @appFunNm $ dgiConstrTagMp dgi
  | Rec         loc         .   tag         =   CTagRec
  | DataFields  loc         .   tag         =   dtiCTag @dataFieldPatExpr.dti
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Offset/label description of pattern
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllPatExpr [ | | tcfsRPatL: {C.FieldSplitL} ]

SEM DataFieldPatExpr
  | Con         lhs         .   tcfsRPatL   =   []
  | Ext         lhs         .   tcfsRPatL   =   (C.FldKnownOffset @nm @ioffset,@patExpr.rpatTC) : @dataFieldPatExpr.tcfsRPatL

SEM RecPatExpr
  | Empty       lhs         .   tcfsRPatL   =   []
  | Ext         lhs         .   tcfsRPatL   =   (C.FldComputeOffset @nm @tcoffset,@patExpr.rpatTC) : @recPatExpr.tcfsRPatL

SEM PatExpr
  | App         lhs         .   tcfsRPatL   =   (C.FldImplicitOffset,@arg.rpatTC) : @func.tcfsRPatL
  | AppTop      loc         .   tcfsRPatL   =   @patExpr.tcfsRPatL
  | Rec         loc         .   tcfsRPatL   =   @recPatExpr.tcfsRPatL
  | DataFields  loc         .   tcfsRPatL   =   @dataFieldPatExpr.tcfsRPatL
  | Con         loc         .   tcfsRPatL   =   []
  | * - App Con Rec
                lhs         .   tcfsRPatL   =   []
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Offsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM DataFieldPatExpr
  | Ext         loc         .   tcoffset    =   C.tcInt @ioffset

SEM RecPatExpr
  | Ext         loc         .   tcoffset    =   C.tcInt @ioffset
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat bindings based on offsets
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   rpatValBinds=   C.fsL2PatOffsetL $ reverse                   $ @tcfsRPatL
  | Rec         loc         .   rpatValBinds=   C.fsL2PatOffsetL $ tyRowCanonOrderBy compare $ @tcfsRPatL
  | DataFields  loc         .   (rpatValBindss,rpatValBindsNonSat,rpatValBind0)
                                            =   let fsL = reverse @tcfsRPatL
                                                    grp = groupByOn (\o1 o2 -> (C.foffOffset o1 `compare` C.foffOffset o2) /= GT) fst
                                                    max = ctagArity @tag - 1
                                                    sat = listSaturateWith 0 max (C.foffOffset . fst)
                                                            (zipWith (\o n -> (o,(C.FldKnownOffset n o,C.RPat_Var (C.RPatNmOrig n) (ty n)))) [0..max] hsnLclSupply)
                                                    ty n = C.tyErr ("PatExpr.DataFields.fld: " ++ show n)
                                                in  ( map (C.fsL2PatOffsetL . sat) $ grp fsL      -- groups of bindings which can be dealt with simultaneously
                                                    , C.fsL2PatOffsetL fsL                        -- bindings
                                                    , C.fsL2PatOffsetL $ sat []                   -- 0 binding
                                                    )
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in (recursive) let bindings (lazy unpacking)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR AllPatExpr [ | | valBindL USE {++} {[]}: {C.ValBindL} ]

SEM PatExpr
  | AppTop Rec  loc         .   valBindL      =   C.rpatBindL2ValBindL @rceEnvTC (not $ null @valBindLSub) @lhs.ceParentNm @tag (Just (@tcrest,length @tcfsRPatL)) @rpatValBinds 
  | DataFields  loc         .   valBindL      =   C.rpatBindL2ValBindL @rceEnvTC (not $ null @valBindLSub) @lhs.ceParentNm @tag (Just (@tcrest,ctagArity @tag)) @rpatValBindsNonSat 
  | AppTop Rec DataFields
                lhs         .   valBindL      =   @valBindL ++ @valBindLSub
%%]

%%[(8 codegen)
SEM PatExpr
  | AppTop      loc         .   valBindLSub   =   @patExpr.valBindL
  | Rec         loc         .   valBindLSub   =   @recPatExpr.valBindL
  | DataFields  loc         .   valBindLSub   =   @dataFieldPatExpr.valBindL
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat name
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR PatExpr [ | | tcpNm: {C.RPatNm} ]

SEM PatExpr
  | Var VarAs AppTop Rec DataFields Con IConst CConst SConst Irrefutable
%%[[97
    Expr
%%]]
                loc         .   tcpNm       =   maybe (C.RPatNmUniq @topNm) C.RPatNmOrig @mbTopNm
  | App         loc         .   tcpNm       =   @arg.tcpNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Pat for use in case alt: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
SEM DataFieldPatExpr

SEM RecPatExpr
%%]
  | Ext         loc         .   offset      =   Expr_Int (tyRecOffset @nm (@lhs.finTyVarMp |=> @recPatExpr.ty))

%%[(1010 codegen)
SEM RecPatExpr
  | Ext         loc         .   offset      :=  C.cSubstApp @patExpr.tcSubst $ mkExprPrHole @lhs.opts @prUid
%%]

%%[(8888 codegen)
ATTR AllPatExpr [ ceParentNm: HsName | | ]

SEM PatExpr
  | App         arg         .   ceParentNm  =   rpatNmNm @arg.tcpNm

SEM RecPatExpr
  | Ext         patExpr     .   ceParentNm  =   rpatNmNm @patExpr.tcpNm

SEM Decl
  | Val         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM CaseAlt
  | Pat         patExpr     .   ceParentNm  =   @patExpr.topNm

SEM Expr
  | Lam         arg         .   ceParentNm  =   @arg.topNm
%%]

%%[(1212 codegen)
SEM Expr
  | LamImpl     arg         .   ceParentNm  =   @arg.topNm
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Coercions resulting from pred usage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
SEM Expr
  | App AppImpred
%%[[8
                loc         .   appImplsCoeLTC      =   []
%%][9
                loc         .   appImplsCoeLTC      =   (C.mkPoisAppCoe @lhs.opts $ map poPoi @prOccL) ++ [C.Coe_ImplApp $ ipoId @imPrvOcc]
%%]]
%%]

%%[(12 codegen)
SEM Expr
  | AppImpl     loc         .   appImplsCoeLTC      =   []
%%]

%%[(8 codegen)
SEM Expr
  | Lam
%%[[12
    LamImpl
%%]]
                loc         .   lamBodyCoeLTC       =   C.mkLamBodyCoe (C.mkCoe (@tcArgWrap . @closeExistsWrap)) @body.appArgCoeLTC
%%]

%%[(8 codegen)
SEM Expr
  | Lam         loc         .   lamArgCoeLTC        =
%%[[9
                                                        C.mkPoiLLamCoe
                                                            (C.mkLetRecCoe @poiBindLTC)
                                                            (zip @poiL (repeat (C.tyErr "Expr.Lam.mkPoiLLamCoe")))
                                                        ++
%%]]
                                                        [C.mkLamCoe1 @arg.topNm @ctyLamArgHere]
  | AppTop Rec
%%[[8
                loc         .   lamArgCoeLTC        =   []
%%][9
                loc         .   lamArgCoeLTC        =   C.mkPoiLLamCoe
                                                            (C.mkLetRecCoe @poiBindLTC)
                                                            (zip @poiL (repeat (C.tyErr "Expr.AppTop.mkPoiLLamCoe")))
%%]]
%%]

%%[(12 codegen)
SEM Expr
  | LamImpl     loc         .   lamArgCoeLTC        =   [C.mkLamCoe1 @arg.topNm @ctyLamArgHere `C.coeCompose` C.mkLetRecCoe @poiBindLTC]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Gathering coercions/cexpr for app args for optimization by weaving above apptop
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR Expr [ | | appArgCoeLTC: {[C.Coe]}  appFunExprTC: {C.Expr} ]

SEM Expr
  | App AppImpred
%%[[12
    AppImpl
%%]]
                lhs         .   (appArgCoeLTC,appFunExprTC)
                                                =   if @func.isNewtype
                                                    then ([],@tcexprArg)
                                                    else (@func.appArgCoeLTC ++ @appImplsCoeLTC ++ [C.mkAppCoe1 @tcexprThArg],@func.appFunExprTC)
  | AppTop      lhs         .   (appArgCoeLTC,appFunExprTC)
                                                =   if null @lamArgCoeLTC
                                                    then (@expr.appArgCoeLTC,@expr.appFunExprTC)
                                                    else ([],@tcexpr)
  | * - App AppImpred AppTop
%%[[12
    AppImpl
%%]]
                lhs         .   appArgCoeLTC   =   []
                            .   appFunExprTC   =   @tcexpr
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR
  Decls Decl AllDataConstr
    [ | | valBindL
        , tyBindL
        , ffiValBindL
%%[[94
        , ffeValBindL
%%]]
          USE {++} {[]}: {C.ValBindL}
    ]
%%]

%%[(8 codegen)
SEM Decl
  | Val         loc         .   tcVal           =   (if @lhs.isStrict then id else C.mkExprThunk) @expr.tcexpr -- $ C.tcMergeArgTypeSeqAndCode @ctyLam2ArgL @expr.tcLamArgs @expr.tcLamBody
                lhs         .   valBindL        =   [C.mkValBind1 @patExpr.topNm @ctyBind @tcVal] ++ @patExpr.valBindL
%%]

%%[(9 codegen)
SEM Decl
  | Val         lhs         .   valBindL        :=  [ C.mkValBind1 @patExpr.topNm @ctyBind $ C.mkExprLet' True C.ValBindCateg_Rec @chrScopeValBindLTC @tcVal
                                                    ] ++ @patExpr.valBindL   -- '
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Decl: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
%%]

%%[(8888 codegen)
SEM Decl
  | TySig       lhs         .   valBindL        =   []
  | FFI         lhs         .   ffiValBindL     =   [ValBind_FFI @callconv @safety @impEnt @nm @ty_sig_expanded]
%%]

%%[(99994 codegen)
  | FFE         loc         .   nmCoerced       =   mkHNmPrefix "coerced_" @nm
                lhs         .   valBindL        =   [C.mkValBind1 @nmCoerced @expr.tcexpr]
                            .   ffeValBindL     =   [ValBind_FFE @nm @callconv @expEnt @nmCoerced @ty_sig_expanded]
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Front/back bindings are inserted before/after the other bindings, though only on top level.
Meant for global defs like FFI/FFE.
Merging is done to group all mutual recursive stuff together, in particular instances which are out of order declared.
Reordering and splitting up in smaller groups is then done later by a Core transformation.

%%[(8 codegen) hs
mkLetTCBodyBindL :: Bool -> C.ValBindCateg -> [(C.ValBindCateg,C.ValBindL)] -> [(C.ValBindCateg,C.ValBindL)] -> [(C.ValBindCateg,C.ValBindL)] -> C.Expr -> ([(C.ValBindCateg,C.ValBindL)],C.Expr)
mkLetTCBodyBindL isStrict howToBind locBindL locOthBindL bodyBindL body
  = if isStrict
    then (locOthBindL,foldr (\(c,b) e -> C.mkExprLet c b e) body (merge $ locBindL ++ bodyBindL))
    else (merge $ locOthBindL ++ locBindL ++ bodyBindL, body)
  where merge (cb1@(c1,b1) : tl)
          = case merge tl of
              (c2,b2) : tl' | c1 == c2 && c1 == C.ValBindCateg_Rec
                  -> (c1,b1++b2) : tl'
              tl' -> cb1 : tl'
        merge [] = []
%%]

%%[(8 codegen)
ATTR
  Expr
    [ | | letValBindL
        , letTyBindL
        , frontValBindL
%%[[94
        , backValBindL
%%]]
            : {[(C.ValBindCateg,C.ValBindL)]}
          letTCBody: {C.Expr}
    ]
%%]

For now: 

%%[(8 codegen)
SEM Expr
  | Let         (loc.letTCValBindRemL,loc.letTCBody)
                                                =   mkLetTCBodyBindL @isStrict @howToValBind @letValBindL @letValBindOtherL @body.letValBindL @body.letTCBody
                lhs         .   letTyBindL      =   @letTyBindL ++ @body.letTyBindL
                            .   letValBindL     =   @letTCValBindRemL
                            .   frontValBindL   =   @frontValBindL ++ @body.frontValBindL
%%[[94
                            .   backValBindL    =   @backValBindL ++ @body.backValBindL
%%]]
  | * - Let     lhs         .   letTCBody       =   @tcexpr
                            .   letTyBindL      =   []
                            .   letValBindL     =   []
                            .   frontValBindL   =   []
%%[[94
                            .   backValBindL    =   []
%%]]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Let bindings + front bindings + body separately: old stuff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Class
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(9999 codegen) hs
cdictOffset :: HsName -> Ty -> Int
cdictOffset n r = tyRecOffset n $ r
%%]

%%[(9999 codegen)
SEM Decl
  | Class       lhs         .   valBindL      =   let  x = mkHNm "x"
                                                     vx = Expr_Var x
                                                     xStrict = hsnUniqifyEval x
                                                     vxStrict = Expr_Var xStrict
                                                     mkSel n = mkExprSatSelsCaseMeta
                                                                 ((emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}) (Just xStrict) (CMetaVal_Dict Nothing) vx @dictTag
                                                                 [(n,n,cdictOffset n @clsTyRec)] Nothing (Expr_Var n)
                                                     mkApp = if ehcCfgInstFldHaveSelf @lhs.opts
                                                             then (\f -> C.mkExprApp1Meta f vx (CMetaVal_Dict Nothing))
                                                             else id
                                                     dDflt
                                                       = [C.mkValBind1 nDflt (mkExprLam1Meta nD (CMetaVal_Dict Nothing) d)] 
                                                       where nDflt = clgiDfltDictNm @clgi2
                                                             d = mkExprApp (Expr_Tup @dictTag) (replicate (length $ snd $ tyRecExts $ @clsTyRec) (cundefined @lhs.opts))
                                                             nD = hsnUniqify HsNameUniqifier_SelfDict nDflt
                                                in   (maybe dDflt (const []) @mbDefaultInstNm)
                                                     ++ [ C.mkValBind1 n $ mkExprLam1Meta x (CMetaVal_Dict Nothing) $ mkApp $ mkSel n
                                                        | (n,_) <- @clsFldL
                                                        ]
%%]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Three Haskell-constructs give rise to an instance-declaration in EH.
In EH, they can be dicerned by inspecting @instVariant:
* InstNormal:   a normal HS instance-declaration
* InstDefault:  the default definitions of a HS class-declaration
* InstDeriving: a deriving-annotation in a data-declaration
The attribute below generates Core code for these.

As an example we show the processing of a simplified form of a HS class "Eq" 
and "Boolean" as an instance of it:

  class Eq a where
    eq :: a -> a -> Bool
    ne :: a -> a -> Bool
    ne x y = not (eq x y)   -- a default definition
                            -- To show how missing definitions are treated, we do not give a default definition for eq here, as in the Prelude
  instance Eq Boolean where
    eq x y = cond x y (not y)  -- the implementation of equality on booleans
                               -- For the "ne" function, it falls back on the default implementation

In the transformation below, before the actual Core code is generated, we have two auxiliary functions:
  * mkNormalD:  generates the dictionary for an instance definition (either from code supplied by the HS programmer, or generated because of "deriving")
  * mkDefaultD: generates the dictionary for a default definition
Also there are some local values:
  * some fresh variable names to be used in the Core code
  * some auxiliary lists, which hold transformations of the original member definitions
Some of these local values are local to mkNormalD or mkDefaultD, others can be definied generically for both.

The elements of the lists correspond to class members. The correspondence can be encode in two ways:
  * as an association list (either 2-tuples, or ValBinds)
  * positional: a fixed number of elements in a fixed order
We explain their meaning by showing example values during processing of the Eq code mentioned above.
Part of the processing is generating fresh names for members.
In the example, "03" is a prefix specific for the default definitions of class Eq, and "05" for the instance definition Eq Boolean.

We use a few notational conventions in the example:
 * what is shown as a string is really an HsName, thus "eq" really is HNm "eq"
 * we use => to denote a ValBind, thus  a=>b  means  ValBind a m b 
 * we omit the meta-annotation m in ValBinds.

 
memberNames          =  [       "eq",       "ne" ]  positional
memberNewNames       =  [     "03eq",     "03ne" ]  positional
      or, respectively, [     "05eq",     "05ne" ]  positional
memberNewVars        =  [ Var "03eq", Var "03ne" ]  positional
      or, respectively, [ Var "05eq", Var "05ne" ]  positional

defaultBindings      =  [                                               "ne"   => \xy.not(eq x y) ]  association
defaultBindingPairs  =  [                                              ("ne"   ,  \xy.not(eq x y))]  association
defaultMbBodies      =  [ Nothing                                , Just           \xy.not(eq x y) ]  positional
defaultMbNewNames    =  [ Nothing                                , Just "03ne"                    ]  positional
defaultBodies        =  [                   cundef               ,                \xy.not(eq x y) ]  positional
defaultNewBindings   =  [         "03eq" => cundef               ,      "03ne" => \xy.not(eq x y) ]  association, and also positional

instanceBindings     =  [         "eq" =>   \xy.cond x y (not y)                                  ]  association
instanceBindingPairs =  [        ("eq" ,    \xy.cond x y (not y))                                 ]  association
instanceMbBodies     =  [ Just              \xy.cond x y (not y) , Nothing                        ]  positional
instanceMbNewNames   =  [ Just    "05eq"                         , Nothing                        ]  positional
instanceMbNames      =  [ Just    "eq"                           , Nothing                        ]  positional
instanceNameMapping  =  [        ("eq"  ,   Var "05eq")                                           ]  association
instanceNewBindings  =  [         "05eq" => \xy.cond x y (not y)                                  ]  association


The primary use of these lists is generating the ...NewBindings.
But for the meta-annotation, also the ...MbNewNames lists are needed.
The other lists are auxiliary.


%%[(9999 codegen)


SEM Decl
  | Instance    lhs         .   valBindL      =   let  (generatedDictionary, generatedMeta)
                                                       = case @instVariant of
                                                            InstNormal   -> mkNormalD  @decls.valBindL
                                                            InstDefault  -> mkDefaultD @decls.valBindL
%%[[95                                                            
                                                            InstDeriving -> mkNormalD  [ @loc.mkf dcf | dcf <- dclFldL @derivDCL ]
%%]]


                                                     memberNames     = [ n 
                                                                       | (n,_) <- tyRowCanonOrder @recTyExts 
                                                                       ]
                                                     memberNewNames  = [ hsnUniqifyStr HsNameUniqifier_DictField (show n) @dictNm -- hsnSuffix @dictNm ('~':show n)
                                                                       | n <- memberNames
                                                                       ]
                                                     memberNewVars   = map Expr_Var memberNewNames

                                                     rsltNm   = @dictBuildNm
                                                     rsltVar  = Expr_Var rsltNm
                                                                                                                                                                                       
                                                     mkNormalD instanceBindings
                                                       = let dfltNm       = clgiDfltDictNm @clgi
                                                             rsltNmStrict = hsnUniqifyEval rsltNm
                                                             dfltNmStrict = hsnUniqifyEval dfltNm
                                                             dfltVar      = Expr_Var dfltNm
                                                             rsltVarStrict= Expr_Var rsltNmStrict
                                                             dfltVarStrict= Expr_Var dfltNmStrict

                                                             instanceBindingPairs= [ (nm,v)
                                                                                   |  ValBind_Bind nm _ v <- instanceBindings
                                                                                   ]
                                                             instanceMbBodies    = map (flip lookup instanceBindingPairs) memberNames
                                                             instanceMbNewNames  = let f _ Nothing  = Nothing
                                                                                       f n (Just e) = Just n
                                                                                   in zipWith f memberNewNames instanceMbBodies
                                                             instanceMbNames     = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNames instanceMbNewNames
                                                             instanceNameMapping = [ (nm, CMetaVal_Val, v)
                                                                                   | (Just nm,v) <- zip instanceMbNames memberNewVars
                                                                                   ]
                                                             instanceNewBindings = [ C.mkValBind1Meta nm CMetaVal_Val v
                                                                                   | (nm,Just v) <- zip memberNewNames instanceMbBodies
                                                                                   ]
                                                                                   
                                                             superNewVars        = map Expr_Var @chrSuperProveNmL
                                                             superNameMapping    = zip3 @supClsFldL
                                                                                        (repeat (CMetaVal_Dict Nothing))
                                                                                        superNewVars

                                                             superNameMapping2   = zip @supClsFldL
                                                                                       @chrSuperProveNmL
                                                             superPairs          = map getBindLeftAndRightVar @chrScopeSuperBindL
                                                             
                                                             doubleLookup :: HsName -> Maybe HsName
                                                             doubleLookup nm   =  do { nm2 <- lookup nm superNameMapping2
                                                                                     ; nm3 <- lookup nm2 superPairs
                                                                                     ; return nm3
                                                                                     }
                                                             
                                                             superMbNewNames   =  map doubleLookup memberNames

                                                             instanceAndSuperMbNewNames = let f (Just x) _ = Just x
                                                                                              f _ (Just y) = Just y
                                                                                              f _ _        = Nothing
                                                                                          in zipWith f instanceMbNewNames superMbNewNames

                                                             instanceCHRBindings = -- C.cSubstApp @decls.tcSubst
                                                                                                (  @chrAssumeSuperBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL 
                                                                                                ++ @chrAssumeDeclsCtxtBindL 
                                                                                                ++ @chrScopeSuperBindL 
                                                                                                ++ @chrScopeDeclsBindL
                                                                                                )

                                                             dict1     = C.mkExprApp1Meta dfltVar rsltVar (CMetaVal_Dict Nothing)
                                                             dict2     = Expr_Let C.ValBindCateg_Strict [bind1] (@loc.mkSetFlds superNameMapping    dfltVarStrict)
                                                             dict3     = Expr_Let C.ValBindCateg_Strict [bind2] (@loc.mkSetFlds instanceNameMapping rsltVarStrict)
                                                             dict4     = mkExprLetRec ([bind3] ++ instanceNewBindings ++ instanceCHRBindings) rsltVar
                                                             
                                                             bind1     = C.mkValBind1Meta dfltNmStrict (CMetaVal_Dict Nothing) dict1
                                                             bind2     = C.mkValBind1Meta rsltNmStrict (CMetaVal_Dict Nothing) dict2
                                                             bind3     = C.mkValBind1Meta rsltNm       (CMetaVal_Dict Nothing) dict3
                                                             contextArguments = cmetaLiftDict @chrCtxtArgNmL
                                                         in  ( mkExprLamMeta contextArguments dict4   
                                                             , CMetaVal_DictInstance (Just (ctagTyNm @dictTag) : Just dfltNm : instanceAndSuperMbNewNames)
                                                             )

                                                     mkDefaultD defaultBindings
                                                       = let selfNm    = @dictSelfNm
                                                       
                                                             lookupMeta n = if n `elem` @supClsFldL then (CMetaVal_Dict Nothing) else CMetaVal_Val
                                                       
                                                             defaultBindingPairs = [ (nm,v)
                                                                                   |  ValBind_Bind nm _ v <- defaultBindings
                                                                                   ]
                                                             defaultMbBodies     = map (flip lookup defaultBindingPairs) memberNames
                                                             defaultMetas        = map lookupMeta                        memberNames
                                                             defaultBodies       = map (maybe (cundefined @lhs.opts) id) defaultMbBodies
                                                             defaultMbNewNames   = let f _ Nothing  = Nothing
                                                                                       f n (Just _) = Just n
                                                                                   in zipWith f memberNewNames defaultMbBodies
                                                             
                                                             defaultNewBindings  = zipWith3 C.mkValBind1Meta memberNewNames 
                                                                                                         defaultMetas
                                                                                                         defaultBodies
                                                             defaultCHRBindings  = -- C.cSubstApp @decls.tcSubst
                                                                                                (  @chrScopeDeclsBindL 
                                                                                                ++ @chrAssumeDeclsInstBindL
                                                                                                )
                                                             dict5     = mkExprAppMeta (Expr_Tup @dictTag)
                                                                                        (zip memberNewVars defaultMetas)
                                                             dict6     = mkExprLetRec ([bind5] ++ defaultNewBindings ++ defaultCHRBindings) rsltVar
                                                             
                                                             bind5     = C.mkValBind1Meta rsltNm (CMetaVal_Dict Nothing) dict5
                                                             
                                                         in  ( mkExprLam1Meta selfNm (CMetaVal_Dict (Just (-1))) dict6
                                                             , CMetaVal_DictClass defaultMbNewNames
                                                             )

                                                in   [C.mkValBind1Meta @dictNm generatedMeta (generatedDictionary)]
  | InstanceIntro
                lhs         .   valBindL      =   [C.mkValBind1Meta @dictNm (CMetaVal_Dict Nothing) @expr.tcexpr]
%%]

%%[(9999 codegen) hs

getBindRightVar :: ValBind -> Maybe HsName

getBindRightVar (ValBind_Bind _ _ (Expr_Var nm)) = Just nm
getBindRightVar _ = Nothing


getBindLeftAndRightVar :: ValBind -> (HsName,HsName)

getBindLeftAndRightVar (ValBind_Bind nm1 _ (Expr_Var nm2)) = (nm1,nm2)
getBindLeftAndRightVar _ = error "getBindLeftAndRightVar: not a bind"



%%]



An auxiliary local attribute that decides (based on an option) how
to set fields in a dictionary:
- by updates of a record
- by matching and rebuilding a datatype 

%%[(9999 codegen)
SEM Decl
  | Instance    loc         .   mkSetFlds   =   let  off n = cdictOffset n @recTy
                                                     mkSetFldsRec ts d0
                                                       = foldl (\d (n,_,v) -> mkSet d n v) d0 ts
                                                       where mkSet d n v = Expr_TupUpd d @dictTag n (Expr_Int $ off n) v

                                                     mkSetFldsData ts d0
                                                       = mkExprSatSelsCaseMeta env Nothing (CMetaVal_Dict Nothing) d0 @dictTag nmLblOffL Nothing sel
                                                       where env = (emptyRCEEnv @lhs.opts) {rceDataGam = @lhs.dataGam}
                                                             fullListWithTrivialValues = [ (o, (o, (Expr_Var n,CMetaVal_Val) ) ) 
                                                                                         | (n,_,o) <- nmLblOffL 
                                                                                         ]
                                                             sparseListWithInterestingValues = [ (off n, (v,m) ) 
                                                                                               | (n,m,v) <- ts
                                                                                               ]
                                                             arity = length @recTyExts
                                                             ns = take arity hsnLclSupply
                                                             nmLblOffL = zip3 ns ns [0..]
                                                             sel = mkExprAppMeta (Expr_Tup @dictTag) 
                                                                                  (map snd $ listSaturateWith 0 
                                                                                                              (arity-1) 
                                                                                                              fst 
                                                                                                              fullListWithTrivialValues
                                                                                                              sparseListWithInterestingValues
                                                                                  )
                                                   in  if   ehcCfgClassViaRec @lhs.opts  
                                                       then mkSetFldsRec  
                                                       else mkSetFldsData

%%]


An auxiliary local attribute that generates thee bindings for a DERIVED instance

%%[(99995 codegen)
SEM Decl
  | Instance    loc         .   mkf         =   let   rsltNm   = @dictBuildNm
                                                      rsltVar  = Expr_Var rsltNm
                                                      
                                                      mkf :: DerivClsFld -> ValBind
                                                      mkf dcf
                                                       = C.mkValBind1 (dcfNm dcf)
                                                           (if fArity == 0
                                                            then mkExprLam (dcfInitialArgL dcf)
                                                                 $ dcfNoArgSubsExpr dcf @rceEnvTC
                                                                     [ (dti,mkcSubs dti (repeat []) altPrOccL) | (dti,altPrOccL) <- zip dtis @derivAltsPrOcc ]
                                                                     nrOfAlts rsltVar extraCxL (dcfInitialArgL dcf)
                                                            else mkExprLam (dcfInitialArgL dcf ++ take fArity nsA)
                                                                   (dcfWrapCase dcf @lhs.opts @derivDataDGI nrOfAlts n1 (dcfInitialArgL dcf)
                                                                    $ mkExprStrictSatCase @rceEnvTC (Just $ hsnUniqifyEval n1) n1v
                                                                      [ CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just $ n1subs ctag))
                                                                                 (mkc splDTI altInx (fArity - 1) n1s [n1subs ctag] altPrOccL)
                                                                      | (ctag,altPrOccL) <- zip (map dtiCTag dtis) @derivAltsPrOcc
                                                                      , let splDTI@(dtisLT,_,_) = splitDTIs ctag dtis
                                                                            altInx = length dtisLT
                                                                      ]
                                                           )       )
                                                       where n1v = Expr_Var n1
                                                             nsA@(n1:n1s) = hsnLclSupplyWith (mkHNm "x")
                                                             dtis  = panicJust "Decl.Instance.Deriving.dataGamDTIsOfTy" $ dataGamDTIsOfTy @derivHdDataTy @lhs.dataGam
                                                             nrOfAlts = length dtis
                                                             splitDTIs t ts -- in (lt,eq,gt), according to list ordering
                                                               = (l,e,g)
                                                               where (l,(e:g)) = span ((/= t) . dtiCTag) ts
                                                             fArity = (length $ tyArrowArgs $ dcfTy dcf) - dcfNrOmitTailArg dcf - length (dcfInitialArgL dcf) - 1 {- dictionary -}
                                                             n1subs t = nsubs t n1
                                                             nsubs t n = take (ctagArity t) $ hsnLclSupplyWith n
                                                             extraCxL = [ mkExprPrHole @lhs.opts (poPoi prOcc) | prOcc <- @derivExtraPrOcc ]
                                                             mkcSubs dti nmFldLL altPrOccL
                                                               = [ mkExprAppMeta
                                                                     (Expr_Var (dcfNm dcf))
                                                                     (cmetaLiftDict [mkExprPrHole @lhs.opts (poPoi prOcc)]
                                                                       ++ cmetaLift (dcfInitialSubArgL dcf dti ++ map Expr_Var nmFldL))
                                                                 | (nmFldL,prOcc) <- zip nmFldLL altPrOccL
                                                                 ]
                                                             mkc tg@(dtisLT,dti,dtisGT) altInx arity nms nmFldLL altPrOccL
                                                               = case nms of
                                                                   (n:ns) | arity > 0
                                                                     -> mkExprStrictSatCase @rceEnvTC (Just $ hsnUniqifyEval n) (Expr_Var n)
                                                                          (   [ mka (dtiCTag dti) tsubs (mkc tg altInx (arity - 1) ns (nmFldLL ++ [tsubs]) altPrOccL) ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagLtExpr dcf) | t <- map dtiCTag dtisLT ]
                                                                           ++ [ mka t (nsubs t n) (dcfAllTagGtExpr dcf) | t <- map dtiCTag dtisGT ]
                                                                          )
                                                                     where tsubs = nsubs (dtiCTag dti) n
                                                                           mka ctag nsubs e = CAlt_Alt (dcfMkCPat dcf altInx ctag (ctagArity ctag) (Just nsubs)) e
                                                                   _ -> dcfFoldSubsExpr dcf @lUniq @rceEnvTC dti (altInx, nrOfAlts) (dcfInitialArgL dcf)
                                                                        $ mkcSubs dti (transpose nmFldLL) altPrOccL
                                                in  mkf
%%]




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Case
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8 codegen)
ATTR CaseAlt [ | | raltTC: {C.RAlt}  raltTC': {C.RAlt} ]
ATTR CaseAlts [ | | raltTCL: {[C.RAlt]}  raltTCL': {[C.RAlt]} ]

SEM CaseAlt
  | Pat         lhs         .   raltTC      =   C.RAlt_Alt [@patExpr.rpatTC] @expr.tcexpr @expr.caseFailS
                            .   raltTC'     =   C.RAlt_Alt (C.fsL2PatL $ reverse @patExpr.tcfsRPatL) @expr.tcexpr @expr.caseFailS

SEM CaseAlts
  | Nil         lhs         .   raltTCL     =   []
                            .   raltTCL'    =   []
  | Cons        lhs         .   raltTCL     =   @hd.raltTC  : @tl.raltTCL
                            .   raltTCL'    =   @hd.raltTC' : @tl.raltTCL'
%%]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Can a Expr fail, that is, has a guard which can fail? Indicated by non-emptyness of caseId's
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%[(8888 codegen)
ATTR Expr [ | | caseFailS USE {`Set.union`} {Set.empty}: UIDS ]

SEM Expr
  | Case        lhs         .   caseFailS   =   @caseFailS
%%]
  | CaseAltFail lhs         .   caseFailS   =   Set.singleton @caseId

