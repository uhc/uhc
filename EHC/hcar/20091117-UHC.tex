\begin{hcarentry}[section]{UHC, Utrecht Haskell Compiler}
\report{Atze Dijkstra}%05/09
\status{active development}
\participants{Jeroen Fokker,
 Doaitse Swierstra,
 Arie Middelkoop,
 Luc\'ilia Camar\~ao de Figueiredo,
 Carlos Camar\~ao de Figueiredo},
 Vincent van Oostrum, Clemens Grabmayer,
 Tom Lokhorst, Jeroen Leeuwestein, Atze van der Ploeg, Paul van der Ende
\label{uhc}
\label{ehc}
\makeheader

\paragraph{UHC, what is new?}
UHC is the Utrecht Haskell Compiler, supporting almost all Haskell 98 features plus
experimental extensions.
The first release of UHC was announced on April 18, 2009, at the 5th Haskell Hackathon, held in Utrecht.

Since then we have been working on:
\begin{itemize}
\item A new garbage collector (GC) to replace the Boehm GC we have been using. The new GC is constructed
relatively independent of the UHC runtime system, as to allow multiple backends to plugin backend specific info, e.g. about
the memory layout of memory cells.
The new GC is used by the bytecode interpreter backend
(Atze Dijkstra).
\item Making nofib testsuite examples run.
This also has been the driving force and testbed for the new GC
(Jeroen Fokker).
\item Typed core, which combines GHC's core language with Henk and recent work on types as calling conventions
(Atze Dijkstra).
\end{itemize}

\paragraph{UHC, what do we plan?}
Soon we start working on the research grant for ``Realising Optimal Sharing'', based on work by Vincent van Oostrum and Clemens Grabmayer.

We plan a next release of UHC with the new garbage collector and various bugfixes.
We had hoped to offer a complete Haskell98 library and Cabal support,
but likely this will have to wait for a subsequent release.

Furthermore, the following student projects are underway or soon start:

\begin{itemize}
\item Various static analyses on typed core (Tom Lokhorst).
\item Incrementalization of whole program analysis (Jeroen Leeuwestein).
\item Lazy closures (Atze van der Ploeg).
\item GC \& LLVM (Paul van der Ende).
\end{itemize}

Finally, still going on are the following:

\begin{itemize}
\item
  GRIN backend, whole program analysis (Jeroen Fokker).
\item
  Type system formalization and automatic generation from type rules
  (Luc\'ilia Camar\~ao de Figueiredo, Arie Middelkoop).
\end{itemize}

%% UHC in its current state still very much is work in progress.
%% Although we feel it is stable enough to offer the public,
%% much work needs to be done to make it usable for serious development work.
%% By design its strong point is the internal aspectwise organization which we started as EHC.
%% UHC also offers more advanced and experimental features like higher-ranked polymorphism, partial type signatures,
%% and local instances.

\paragraph{Background info}

UHC actually is a series of compilers of which the last is UHC, plus
an aspectwise organized infrastructure for facilitating experimentation and extension.
The end-user will probably only be aware of UHC as a Haskell compiler,
whereas compiler writers will be more
aware of the internals of UHC.

For the description of UHC an Attribute Grammar system (AG) is used as well as other
formalisms allowing compact notation like parser combinators.  For the
description of type rules, and the generation of an AG implementation for
those type rules, we use the Ruler system.
For source code management we use Shuffle, which allows partitioning the system into a sequence of steps and aspects.
(Both Ruler and Shuffle are included in UHC).

The implementation of UHC also tackles other issues:
\begin{itemize}
\item
  To deal with the inherent complexity of a compiler the implementation of UHC is organized as a series of
  increasingly complex steps.
  Each step corresponds to a Haskell subset which itself is an extension
  of the previous step.
  The first step starts with the essentials, namely typed lambda
  calculus; the last step corresponds to UHC.

\item
 Independent of each step the implementation is organized into a set of aspects.
  Currently the type system and code generation are defined as aspects,
  which can then be left out so the remaining part can be used as a barebones starting point.

\item
  Each combination of step + aspects corresponds to an actual, that is, an executable compiler.
  Each of these compilers is a compiler in its own right.

\item
  The description of the compiler uses code fragments which are
  retrieved from the source code of the compilers.
  In this way the description and source code are kept synchronized.
\end{itemize}

Part of the description of the series of EH compilers is available
as a PhD thesis.

%% \paragraph{What will happen with UHC in the near future?}
%% We plan to do the following:
%% 
%% \begin{itemize}
%% \item
%%  Improving installation of UHC and its use as a Haskell compiler: use of Cabal, adding missing Haskell 98 features.
%% \item
%%  Work on adding static analyses (such as strictness analysis), to enable optimizations.
%% \end{itemize}
%% 
\FurtherReading
\begin{compactitem}
\item UHC Homepage:
\url{http://www.cs.uu.nl/wiki/UHC/WebHome}

\item Attribute grammar system:
\url{http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem}

\item Parser combinators:
\url{http://www.cs.uu.nl/wiki/HUT/ParserCombinators}

\item Shuffle:
\url{http://www.cs.uu.nl/wiki/Ehc/Shuffle}

\item Ruler:
\url{http://www.cs.uu.nl/wiki/Ehc/Ruler}
\end{compactitem}
\end{hcarentry}

