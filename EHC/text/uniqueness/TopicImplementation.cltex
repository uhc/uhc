%%[main

\chapter{Implementation}

This appendix provides some information concerning the implementation of the uniqueness typing as discussed in this master's thesis. Actually, we made two
prototype implementations:

\begin{itemize}
\item A version for EH 7 or 8. This is an extensive version that goes into detail in annotating data types, enriching the type language with exposed annotations
      and expanded types. It deals with records, pattern matches, higher-ranked types, existential types, and impredicative types. It is created to support all aspects of the EH 7
      language, since one of our research questions is how to deal with the language constructs of Haskell. The implementation uses a general architecture that can be instantiated
      for a whole range of analyses, such as polarity, uniqueness, and strictness inference. We used this version as research vehicle for the later chapters of this master's thesis.
\item A version for EH 2. Since EH 2 is a simple language, with less complications around each corner. This version allows us to focus and experiment with the main concepts of the uniqueness inference.
      It is easier to experiment with. For example, the concept of |beta| annotations was discovered near the end of the project. Adding |beta| annotations to EH 7 or EH 9 is rather
      hard, since it interferes with unification. It requires changes in the unification function of EH, called |fitsIn|, and in the construction of types for data
      types. Given our experience with annotating types with |delta| annotations, we expect integrating |beta| annotations in EH 7 to take a couple of weeks, instead of the
      two days for EH 2. We used this version for the construction of the Chapter~\ref{chapt.NoBindings} and Chapter~\ref{chapt.Polyvariant}. This version also uses a whole different
      graph representation.
\end{itemize}

The architecture of the EH 2 version is basically the same as the EH 7 version, so we ignore the differences for the remainder of this appendix.

\section{Installation}

The implementation is currently on a separate branch (named @uniqueness@) of the EH project. Checkout the repository using:

\begin{verbatim}
svn checkout https://svn.cs.uu.nl:12443/repos/EHC/branches/uniqueness/EHC/
\end{verbatim}

Build the compiler by running @make bin/7_2/ehc@. After compilation, there is an executable named @ehc@ available in the @bin/7_2@ directory. For example, create a file
named @Test.eh@:

%%[[wrap=code
  let  id = \x -> x
  in   id 3
%%]

Running the compiler over @Test.eh@ using @ehc Test.eh@ results into an @.html@ file being generated named @Test.eh.html@. This @.html@ file contains a pretty print
of the above program, displaying annotated types that indicate that |3| is used at most once.

\section{Files and architecture}

The uniqueness typing implementation consists of several components. There is one distinct component which is the constraint solving backend. All other components are
modifications and additions to existing components of EHC. All backend related code is located in the folder @src/ehc/Annotations/@. The following
files are of interest:
\begin{itemize}
\item The file @Annotations.chs@ contains all utility code related to annotation trees, graph rewriting and fixpoint iterations.
\item The file @ConstraintSolver.chs@ provides utility functions to construct constraint solvers parameterized by solve functions for a specific analysis.
\item The solve functions for different analyses can be found by their corresponding name in this folder.
\item The file @AnnSolvers.cag@ instantiates all solvers and pushes a uniqueness substitution throughout the abstract syntax tree.
\end{itemize}

Consult the implementation and corresponding inline documentation for more information regarding these topics.

The other components are situated throughout the EHC source. For example, a large amount of annotation related utility functions can be found in the
@src/ehc/Ty@ folder. These include functions for annotating types, expanding types (for type constructors for example), kind inferencing on annotated
types, and pretty printing.

The code for inferencing constraint set is located in the @src/ehc/EH@ folder. Part of the code is generated by @ruler@, but a large portion is just
@AG@ code. Of particular interest in this folder are @ConstrInferData.cag@, @ConstrInferExpr.cag@, and @ConstrInferTy.cag@. These are the files that
generate constraints for expressions and types. The parts generated by ruler are located in @ehc/rules/EhcRulesOrig.rul@.

%%]
