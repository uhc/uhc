%%[title
\begin{frame}
\titlepage
\end{frame}

%%]

%%[intro
\begin{frame}
\frametitle{Views on UHC}
\begin{itemize}
\item {\color{uured} From input to output}\\
      \uncover<2->{{\large\hspace*{5mm}Pipeline of transformations on internal representations}}
\item {\color{uured} Specification of ``From input to output''}\\
      \uncover<2->{{\large\hspace*{5mm}Aspectwise organisation of code}}\\
      \uncover<2->{{\large\hspace*{5mm}Tools}}
\end{itemize}
\end{frame}



%%]

%%[pipeline




\begin{frame}
\frametitle{UHC pipeline}
\begin{center}


\begin{tikzpicture}
  [ blok/.style={rectangle, draw=black, line width=0.6pt, minimum height=5mm, text centered},
    eenhoog/.style={minimum height=5mm},
    eenplushoog/.style={minimum height=6.5mm},
    eenbreed/.style={minimum width=12mm},
    tweebreed/.style={minimum width=26mm},
    bron/.style={fill=green!50},
    lib/.style={fill=green!50},
    uitvoer/.style={fill=yellow!50},
    doel/.style={fill=yellow!80},
  ]

\draw[help lines,white] (-1mm,1mm) grid[step=5mm] (111mm,70mm);
  
\node<1->[blok,bron,eenbreed] at (48mm,67mm) (hs1) {HS} ;  
\node<4->[blok,bron,eenbreed](hs2) at (62mm,67mm) {HS} ;  
  
\node<2->[blok,uitvoer,eenbreed](eh1)   at (48mm,58mm) {EH};  
\node<4->[blok,uitvoer,eenbreed](eh2)   at (62mm,58mm) {EH};  
  
\node<2->[blok,uitvoer,eenbreed](core1) at (48mm,49mm) {Core};  
\node<4->[blok,uitvoer,eenbreed](core2) at (62mm,49mm) {Core};

\node<5->[blok,uitvoer,tweebreed](core0) at (13mm,40mm) {Core};
\node<8->[blok,uitvoer,eenbreed](jvm1)  at (90mm,40mm) {Jvm};
\node<8->[blok,uitvoer,eenbreed](jvm2)  at (104mm,40mm){Jvm};

\node<5->[blok,uitvoer,eenbreed](grin00) at (20mm,31mm) {Grin} ;
\node<5->[blok,uitvoer,tweebreed](grin0) at (13mm,31mm) {Grin};
\node<2->[blok,uitvoer,eenbreed](grin1) at (48mm,31mm) {Grin} ; 
\node<4->[blok,uitvoer,eenbreed](grin2) at (62mm,31mm) {Grin} ;

\node<6->[blok,uitvoer,eenbreed](silly00)at (20mm,22mm) {Silly};
\node<6->[blok,uitvoer,tweebreed](silly0)at (13mm,22mm) {Silly};
\node<2->[blok,uitvoer,eenbreed](bc1)   at (48mm,22mm) {BC} ; 
\node<4->[blok,uitvoer,eenbreed](bc2)   at (62mm,22mm) {BC} ;  
  
\node<6->[blok,uitvoer,minimum width=6mm](cil) at ( 3mm,13mm) {...};
\node<6->[blok,uitvoer,minimum width=18mm](c0) at (17mm,13mm) {C};
\node<3->[blok,lib,eenbreed](crts)      at (34mm,13mm) {C}; 
\node<2->[blok,uitvoer,eenbreed](c1)    at (48mm,13mm) {C}; 
\node<4->[blok,uitvoer,eenbreed](c2)    at (62mm,13mm) {C};  
\node<3->[blok,lib,eenbreed](cbci)      at (76mm,13mm) {C};   
  
\node<7->[blok,doel,minimum width=25mm](exe0) at (20.5mm,4mm) {Exe};
\node<3->[blok,doel,minimum width=41mm](exe1) at (55.5mm,4mm) {Exe};
\node<9->[blok,doel,minimum width=26mm](jar1) at (97mm,4mm) {Jar};
  
\node<9->[blok,lib,minimum width=12mm, anchor=west, xshift=9mm](java) at (cbci.east) {Java};




\node<3->[anchor=south east] at (41.5mm,15mm){{\tiny\shortstack[r]{runtime\\system}}};
\node<3->[anchor=south west] at (69mm,15mm)  {{\tiny\shortstack[l]{bytecode\\interpreter}}};
\node<3-3>[anchor=west]      at (c1.east)    {{\tiny\shortstack[l]{bytecode\\tables}}};
\node<9->[anchor=south]      at (98mm,15mm)  {{\tiny\shortstack{graph\\interpreter}}};



\path<2-> [draw, line width=1.5pt, -> ] (hs1.south) -- (eh1.north) ;
\path<4-> [draw, line width=1.5pt, -> ] (hs2.south) -- (eh2.north) ;
\path<2-> [draw, line width=1.5pt, -> ] (eh1.south) -- (core1.north);
\path<4-> [draw, line width=1.5pt, -> ] (eh2.south) -- (core2.north);

\path<2-> [draw, line width=1.5pt, -> ] (core1) edge [in=180,out=150,loop] (core1) ;
\path<4-> [draw, line width=1.5pt, <- ] (core2) edge [in=0,out=30,loop] (core2) ;

\path<2-> [draw, line width=1.5pt, -> ] (core1.south) -- (grin1.north);
\path<4-> [draw, line width=1.5pt, -> ] (core2.south) -- (grin2.north);

\path<2-> [draw, line width=1.5pt, -> ] (grin1) edge [in=195,out=165,loop] (grin1) ;
\path<4-> [draw, line width=1.5pt, <- ] (grin2) edge [in=345,out=15,loop] (grin2) ;

\path<5-> [draw, line width=1.5pt, -> ] (grin00) edge [in=345,out=15,loop] (grin0) ;
\path<6-> [draw, line width=1.5pt, -> ] (silly00) edge [in=345,out=15,loop] (silly0) ;

\path<2-> [draw, line width=1.5pt, -> ] (grin1.south) -- (bc1.north);
\path<4-> [draw, line width=1.5pt, -> ] (grin2.south) -- (bc2.north);
\path<2-> [draw, line width=1.5pt, -> ] (bc1.south) -- (c1.north);
\path<4-> [draw, line width=1.5pt, -> ] (bc2.south) -- (c2.north);


\path<5-> [draw, line width=1.5pt, -> ] (core1.235) -- (core0.north east);
\path<5-> [draw, line width=1.5pt, -> ] (core2.235) -- (core0.north east);

\path<8-> [draw, line width=1.5pt, -> ] (core1.305) -- (jvm1.north west);
\path<8-> [draw, line width=1.5pt, -> ] (core2.305) -- (jvm2.north west);

\path<5-> [draw, line width=1.5pt, -> ] (core0.south)  -- (grin0.north);
\path<6-> [draw, line width=1.5pt, -> ] (grin0.south)  -- (silly0.north);
\path<6-> [draw, line width=1.5pt, <- ] (cil.north)    -- +(  up:3.4mm);
\path<6-> [draw, line width=1.5pt, -> ] (silly0.south) -- +(down:3.4mm);

\path<7-> [draw, line width=1.5pt, -> ] (c0.south)     -- +(down:3.7mm);
\path<7-> [draw, line width=1.5pt, -> ] (crts.225)     -- +(down:3.7mm);
\path<3-> [draw, line width=1.5pt, -> ] (crts.315)     -- +(down:3.7mm);
\path<3-> [draw, line width=1.5pt, -> ] (c1.south)     -- +(down:3.7mm);
\path<4-> [draw, line width=1.5pt, -> ] (c2.south)     -- +(down:3.7mm);
\path<3-> [draw, line width=1.5pt, -> ] (cbci.225)     -- +(down:3.7mm);

\path<9-> [draw, line width=1.5pt, -> ] (jvm1.235)     -- +(down:30.6mm);
\path<9-> [draw, line width=1.5pt, -> ] (jvm2.305)     -- +(down:30.6mm);
\path<9-> [draw, line width=1.5pt, -> ] (java.south)   -- +(down:3.7mm);

\end{tikzpicture}
\end{center}
\end{frame}




\begin{frame}
\frametitle{Tools for UHC implementation}

\begin{itemize}
\item {\color{uured} Functional programming}\\
      \uncover<2->{{\large\hspace*{5mm}GHC: Haskell compiler}}
\item {\color{uured} Tree-oriented programming}\\
      \uncover<2->{{\large\hspace*{5mm}UUAG: Attribute Grammar preprocessor}}
\item {\color{uured} Rule-oriented programming}\\
      \uncover<2->{{\large\hspace*{5mm}Ruler: Type rule preprocessor}}
\item {\color{uured} Aspect-oriented programming}\\
      \uncover<2->{{\large\hspace*{5mm}Shuffle: Source fragmentation preprocessor}}
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Tools for UHC implementation}

\begin{itemize}
\item {\color{black!30}Functional programming}\\
      {\color{black!30}{\large\hspace*{5mm}GHC: Haskell compiler}}
\item {\color{uured} Tree-oriented programming}\\
      {\color{black}{\large\hspace*{5mm}UUAG: Attribute Grammar preprocessor}}
\item {\color{black!30}Rule-oriented programming}\\
      {\color{black!30}{\large\hspace*{5mm}Ruler: Type rule preprocessor}}
\item {\color{uured} Aspect-oriented programming}\\
      {\color{black}{\large\hspace*{5mm}Shuffle: Source fragmentation preprocessor}}
\end{itemize}

\end{frame}



%%]

%%[toolsAG


\begin{frame}
\frametitle{Tree-oriented programming}

\setlength{\mathindent}{0pt}

\begin{tikzpicture}
[ codebox/.style={}]

\setlength{\linewidth}{32mm}


%% Eerste kolom

\draw[help lines,white] (0,0) grid[step=5mm] (110mm,70mm);


\draw<3-16> (34mm,70mm) -- (34mm,20mm);
\draw<3-16> (66mm,70mm) -- (66mm,20mm);

\node<16-18>[anchor=south west,minimum width=40mm, minimum height=5mm,draw,fill=yellow!50] at (68.5mm,43.5mm) {};
\node<19->[rectangle callout,callout absolute pointer={(90mm,17mm)},anchor=south west,minimum width=40mm, minimum height=5mm,draw,fill=yellow!50] at (68.5mm,43.5mm) {};
\node<19->[anchor=north west,minimum width=77mm, minimum height=15mm,fill=yellow!50] at (34mm,17mm) {};


\node<1->[codebox, anchor=north west] at (0mm,70mm) {|data Expr|};

\node<1-7>[codebox, anchor=north west] at(0mm,64mm) {
%%[[wrap=safecode
=  
   Con  Int
|  Add  Expr  Expr
|  Mul  Expr  Expr
%%]]
};

\node<8-16>[codebox, anchor=north west] at(0mm,64mm) {
%%[[wrap=safecode
=  
   Con  Int
|  Add  Expr  Expr
|  Mul  Expr  Expr
|  Var  Name
%%]]
};


\node<17->[codebox, anchor=north west] at(0mm,64mm) {
%%[[wrap=safecode
=  
   Con  con:Int
|  Add  lef:Expr  rit:Expr
|  Mul  lef:Expr  rit:Expr
|  Var  name:Name
%%]]
};





%% Tweede kolom


\node<3-5>[codebox, anchor=north west] at (34mm,70mm) {|fold|};

\node<3-5>[codebox, anchor=north west] at(34mm,64mm) {
%%[[wrap=safecode
::  
    ( Int   -> b  )
->  ( b->b  -> b  )
->  ( b->b  -> b  )
->  Expr    -> b
%%]]
};


\node<6-16>[codebox, anchor=north west] at (34mm,70mm) {|type Sem b|};

\node<6-8>[codebox, anchor=north west] at(34mm,64mm) {
%%[[wrap=safecode
=  
(  ( Int   -> b  )
,  ( b->b  -> b  )
,  ( b->b  -> b  )
)
%%]]
};

\node<9-16>[codebox, anchor=north west] at(34mm,64mm) {
%%[[wrap=safecode
=  
(  ( Int   -> b  )
,  ( b->b  -> b  )
,  ( b->b  -> b  )
,  ( Name  -> b  )
)
%%]]
};


\node<6-16>[codebox, anchor=north west]  at(34mm,30mm) {
%%[[wrap=safecode
fold ::  Sem b ->
         Expr -> b
%%]]
};




%% Derde kolom



\setlength{\linewidth}{45mm}

\node<2-6>[codebox, anchor=north west] at (66mm,70mm) {|calc :: Expr -> Int|};

\node<4-4>[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calc = fold id (+) (*)
%%]]
};

\node<5-6>[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calc = fold
(  \  n    ->  n     )
(  \  x y  ->  x+y   )
(  \  x y  ->  x*y   )
%%]]
};


\node<7-11>[codebox, anchor=north west] at (66mm,70mm) {|calcsem :: Sem Int|};

\node<12->[codebox, anchor=north west] at (66mm,70mm) {|calcsem :: Sem (Env->Int)|};



\node<7-9>[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calcsem =
(  \  n    ->  n
,  \  x y  ->  x+y
,  \  x y  ->  x*y
)
%%]]
};

\node<10-10>[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calcsem =
(  \  n    ->  n
,  \  x y  ->  x+y
,  \  x y  ->  x*y
,  \  s    ->  lookup s e
)
%%]]
};

\node<11-12>[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calcsem =
(  \  n    ->  n
,  \  x y  ->  x+y
,  \  x y  ->  x*y
,  \  s    ->  \e  ->  lookup s e
)
%%]]
};

\node<13->[codebox, anchor=north west] at(66mm,64mm) {
%%[[wrap=safecode
calcsem =
(  \  n    ->  \e  ->  n
,  \  x y  ->  \e  ->  x e + y e
,  \  x y  ->  \e  ->  x e * y e
,  \  s    ->  \e  ->  lookup s e
)
%%]]
};





\node<7-13>[codebox, anchor=north west] at(66mm,30mm) {
%%[[wrap=safecode
calc  ::  Expr -> Int
calc  =   fold calcsem
%%]]
};

\node<14-16>[codebox, anchor=north west] at(66mm,30mm) {
%%[[wrap=safecode
calc  ::  Expr -> Int
calc  =   fold calcsem testenv
%%]]
};


\node<15->[anchor=north,rectangle callout,fill=green!50,callout absolute pointer={(19mm,38mm)}] at (10mm,30mm) {Fields};

\node<15->[anchor=north,rectangle callout,fill=green!50,callout absolute pointer={(98mm,65mm)}] at (78mm,62mm) {\shortstack{Inherited\\attribute}};

\node<15->[anchor=north,rectangle callout,fill=green!50,callout absolute pointer={(108mm,65mm)}] at (105mm,60mm) {\shortstack{Synthesized\\attribute}};

\node<17->[anchor=north,rectangle callout,fill=green!50,callout absolute pointer={(19mm,38mm)}] at (10mm,30mm) {\shortstack{Named\\fields}};

\node<18->[anchor=north west,rectangle callout,fill=green!50,callout absolute pointer={(62mm,28mm)}] at (47mm,44mm) {\shortstack{Named\\attributes}};



%% AG Oplossing

%format THIS = "\mathbf{lhs}"


\node<18->[codebox, anchor=north west]  at(34mm,30mm) {
%%[[wrap=safecode
ATTR Expr   INH   env : Env
            SYN   val : Int
%%]]
};

\node<19->[codebox, anchor=north west]  at(34mm,18mm) {
%%[[wrap=safecode
SEM  Expr |  Mul   THIS.val  =  @lef.val * @rit.val
                   lef.env   =  @THIS.env
                   rit.env   =  @THIS.env
%%]]
};



\end{tikzpicture}
\end{frame}







\begin{frame}
\frametitle{Attribute Grammar processor}

UUAG Attribute Grammar preprocessor lets you
\begin{itemize}
\item have named fields and attributes
\item define semantics by defining attributes
\end{itemize}
and automatically
\begin{itemize}
\item generates the |fold|-function
\item generates the semantic functions to instantiate it
\item inserts trivial rules
\end{itemize}
\end{frame}







\begin{frame}
\frametitle{AG applied in UHC}
Desired Core transformation:

\begin{center}
\begin{tikzpicture}
\matrix[ampersand replacement=\&,column sep=1em]
{ \node(from){
   \begin{minipage}{.25\linewidth}
%%[[wrap=safecode
let  y  =  z  in
let  x  =  y  in
     x + y
%%]]
   \end{minipage}
  } ; \&
  \node(to){
   \begin{minipage}{.25\linewidth}
%%[[wrap=safecode
let  y  =  z  in
let  x  =  y  in
     redOn ^ z ^ blackOn ^ + redOn ^ z ^ blackOn
%%]]
   \end{minipage}
  } ; \\
} ;
\draw [->,thick] (from.east) -- (to.west) ;
\end{tikzpicture}
\end{center}

Inline name aliases

\uncover<2->{
\begin{itemize}
\item Gather introduced bindings bottom up
\item Distribute gathered bindings top down
\item Compute transformed tree bottom up, \\variable occurrences possibly replaced
\end{itemize}
}

\end{frame}







%format mapsto = "\mapsto"
%format emptymap = "\O"



\begin{frame}
\frametitle<1-7>{Example Core transformation}
\frametitle<8>{Example Core transformation: Name alias}
\frametitle<9->{Example Core transformation: Name alias inlining}


\begin{tikzpicture}
  [ synnt/.style={rectangle,                              inner sep=1pt, minimum height=4mm, minimum width=10mm, fill=blue,    text centered, text=white, font=\small, anchor=north},
    synco/.style={rectangle, draw=blue, line width=0.3pt, inner sep=1pt, minimum height=3mm, minimum width=10mm, fill=blue!20, text centered, text=blue,  font=\small, anchor=north},
    attrSynth/.style={yshift=1mm,xshift=0.3mm, rectangle, draw=green, line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=green!30, text centered, text=black,  font=\small, anchor=west},
    attrInh/.style={yshift=-1mm,xshift=-0.3mm, rectangle, draw=red,    line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=red!30,   text centered, text=black,  font=\small, anchor=east},
    attrLoc/.style={rectangle, draw=black,  line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=black!30, text centered, text=black,  font=\small},
    synline/.style={draw=blue, line width=1.6pt},
    attrDep/.style={draw=black, line width=1pt, ->},
    codebox/.style={anchor=north west}
  ]

\setlength{\linewidth}{80mm}
\setlength{\mathindent}{0pt}



\draw[help lines,white] (-2mm,-3mm) grid[step=10mm] (116mm,70mm);


\node<8-11>[rounded corners, minimum width=32mm, minimum height=37mm, anchor=north west, fill=red!20,   draw=red,   line width=0.6pt, text centered](box1) at(-1mm,52mm) {};
\node<8-11>[anchor=south] at (box1.south) {Name alias};
\node<9-11>[rounded corners, minimum width=32mm, minimum height=10mm, anchor=north west, fill=green!20, draw=green, line width=0.6pt, text badly ragged](box2)   at(79mm,41mm) {};
\node<9-11>[anchor=west] at (box2.west) {Inlining};



\node<4->[synnt](nt1a) at(65mm,70mm)  {Expr};
\node<4->[synco](co1a) at(nt1a.south) {Let};

\node<4->[synnt](nt2a) at(35mm,60mm)  {[Bind]};
\node<5->[synco](co2a) at(nt2a.south) {:};

\node<3->[synnt](nt2b) at(95mm,60mm)  {Expr};
\node<3->[synco](co2b) at(nt2b.south) {App};

\node<5->[synnt](nt3a) at(15mm,50mm)  {Bind};
\node<6->[synco](co3a) at(nt3a.south) {Bind};

\node<5->[synnt](nt3b) at(55mm,50mm)  {[Bind]};
\node<5->[synco](co3b) at(nt3b.south) {:};

\node<3->[synnt](nt3c) at(85mm,50mm)  {Expr};
\node<3->[synco](co3c) at(nt3c.south) {};

\node<2->[synnt](nt3d) at(105mm,50mm) {Expr};
\node<2->[synco](co3d) at(nt3d.south) {Var};

\node<6->[synnt](nt4a) at(5mm,40mm)   {Name};
\node<6->[synco](co4a) at(nt4a.south) {"x"};

\node<6->[synnt](nt4b) at(25mm,40mm)  {Expr};
\node<7->[synco](co4b) at(nt4b.south) {Var};

\node<5->[synnt](nt4c) at(45mm,40mm)  {Bind};
\node<6->[synco](co4c) at(nt4c.south) {};

\node<5->[synnt](nt4d) at(65mm,40mm)  {[Bind]};
\node<5->[synco](co4d) at(nt4d.south) {};

\node<2->[synnt](nt4e) at(105mm,40mm) {Name};
\node<2->[synco](co4e) at(nt4e.south) {"x"};
\node<10-10>[synco,xshift=1mm,yshift=-1mm](co4ee) at(co4e.north) {"y"};

\node<7->[synnt](nt5a) at(25mm,30mm)  {Name};
\node<7->[synco](co5a) at(nt5a.south) {"y"};


\path<4->[synline] (co1a.south west)  -- (nt2a.north east);
\path<4->[synline] (co1a.south east)  -- (nt2b.north west);

\path<5->[synline] (co2a.south west)  -- (nt3a.north east);
\path<5->[synline] (co2a.south east)  -- (nt3b.north west);
\path<3->[synline] (co2b.south west)  -- (nt3c.north);
\path<3->[synline] (co2b.south east)  -- (nt3d.north);

\path<6->[synline] (co3a.south west)  -- (nt4a.north);
\path<6->[synline] (co3a.south east)  -- (nt4b.north);
\path<5->[synline] (co3b.south west)  -- (nt4c.north);
\path<5->[synline] (co3b.south east)  -- (nt4d.north);
\path<2->[synline] (co3d.south)  -- (nt4e.north);
\path<7->[synline] (co4b.south)  -- (nt5a.north);


\node<12->[attrSynth](syn3a) at(nt3a.south east)   {als};
\node<12->[attrSynth](syn4c) at(nt4c.south east)   {als};

\node<13->[attrSynth](syn2a) at(nt2a.south east)   {als};
\node<13->[attrSynth](syn3b) at(nt3b.south east)   {als};
\node<13->[attrSynth](syn4d) at(nt4d.south east)   {als};

\path<14->[attrDep] (syn4c.north)  -- (syn3b.south);
\path<14->[attrDep] (syn4d.north)  -- (syn3b.south);
\path<14->[attrDep] (syn3a.north)  -- (syn2a.south);
\path<14->[attrDep] (syn3b.north)  -- (syn2a.south);

\node<15->[attrInh](inh1a) at(nt1a.south west)   {env};
\node<15->[attrInh](inh2b) at(nt2b.south west)   {env};
\node<15->[attrInh](inh3c) at(nt3c.south west)   {env};
\node<15->[attrInh](inh3d) at(nt3d.south west)   {env};
\node<15->[attrInh](inh4b) at(nt4b.south west)   {env};

\path<16-22>[attrDep] (inh1a.south)  -- (inh2b.north);
\path<16->[attrDep] (inh2b.south)  -- (inh3c.north);
\path<16->[attrDep] (inh2b.south)  -- (inh3d.north);

\node<17->[attrInh](inh2a) at(nt2a.south west)   {env};
\node<17->[attrInh](inh3b) at(nt3b.south west)   {env};
\node<17->[attrInh](inh4d) at(nt4d.south west)   {env};
\node<17->[attrInh](inh3a) at(nt3a.south west)   {env};
\node<17->[attrInh](inh4c) at(nt4c.south west)   {env};

\path<18-22>[attrDep] (inh1a.south)  -- (inh2a.north);
\path<18->[attrDep] (inh2a.south)  -- (inh3a.north);
\path<18->[attrDep] (inh2a.south)  -- (inh3b.north);
\path<18->[attrDep] (inh3a.south)  -- (inh4b.north);
\path<18->[attrDep] (inh3b.south)  -- (inh4c.north);
\path<18->[attrDep] (inh3b.south)  -- (inh4d.north);

\node<19->[attrSynth](syn3c) at(nt3c.south east)   {trf};
\node<19->[attrSynth](syn3d) at(nt3d.south east)   {trf};
\node<19->[attrSynth](syn2b) at(nt2b.south east)   {trf};
\node<19->[attrSynth](syn1a) at(nt1a.south east)   {trf};

\path<19->[attrDep] (syn3c.north)  -- (syn2b.south);
\path<19->[attrDep] (syn3d.north)  -- (syn2b.south);
\path<19->[attrDep] (syn2b.north)  -- (syn1a.south);

\path<20->[attrDep,out=315,in=225] (inh3d.south) to (syn3d.south);
\path<20->[attrDep]                (nt4e.north east)  -- (syn3d.south);

\node<21->[attrSynth](syn4b) at(nt4b.south east)   {mbal};
\path<21->[attrDep] (syn4b.north)  -- (syn3a.south);

\path<22->[attrDep]                (nt5a.north east)  -- (syn4b.south);

\node<23->[attrLoc](loc1a) at(nt1a.south)   {env};
\path<23->[attrDep] (inh1a.east)  -- (loc1a.west);
\path<23->[attrDep] (syn2a.north)  -- (loc1a.south);
\path<24->[attrDep] (loc1a.south west)  -- (inh2a.north);
\path<24->[attrDep] (loc1a.south east)  -- (inh2b.north);




\node[fill=yellow!50, draw, line width=0.4pt, minimum width=80mm, minimum height=30mm, anchor=north west](codeback) at(35mm,30mm) {};

\node<1-2>[codebox] at(codeback.north west) {
%%[[wrap=safecode
DATA  Expr  =  Var nm:Name
%%]]
};

\node<3-3>[codebox] at(codeback.north west) {
%%[[wrap=safecode
DATA  Expr  =  Var nm:Name
            |  App f:Expr a:Expr
%%]]
};

\node<4-5>[codebox] at(codeback.north west) {
%%[[wrap=safecode
DATA  Expr  =  Var nm:Name
            |  App f:Expr a:Expr
            |  Let defs:[Bind] body:Expr
%%]]
};

\node<6-10>[codebox] at(codeback.north west) {
%%[[wrap=safecode
DATA  Expr  =  Var nm:Name
            |  App f:Expr a:Expr
            |  Let defs:[Bind] body:Expr
DATA  Bind  =  Bind Name Expr
%%]]
};

\node<11-11>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
%%]]
};

\node<12-12>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN  als : Env
%%]]
};

\node<13-13>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN als : Env
ATTR  [Bind] SYN als : Env
%%]]
};

\node<14-14>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN als : Env
ATTR  [Bind] SYN als USE {`union`} {emptymap}: Env
%%]]
};

\node<15-16>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN als : Env
ATTR  [Bind] SYN als USE {`union`} {emptymap}: Env
ATTR  Expr INH env : Env
%%]]
};

\node<17-18>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN als : Env
ATTR  [Bind] SYN als USE {`union`} {emptymap}: Env
ATTR  Expr INH env : Env
ATTR  Bind [Bind] INH env : Env
%%]]
};

\node<19-19>[codebox] at(codeback.north west) {
%%[[wrap=safecode
TYPE  Env   =  Map Name Expr
ATTR  Bind  SYN als : Env
ATTR  [Bind] SYN als USE {`union`} {emptymap}: Env
ATTR  Expr INH env : Env
ATTR  Bind [Bind] INH env : Env
ATTR  Expr Bind [Bind] SYN trf : SELF
%%]]
};


\node<20-20>[codebox] at(codeback.north west) {
%%[[wrap=safecode
SEM  Expr | Var  
    lhs.trf = findWithDefault  (Var @nm) 
                               @nm 
                               @lhs.env
%%]]
};


\node<21-21>[codebox] at(codeback.north west) {
%%[[wrap=safecode
SEM  Bind | Bind  
    lhs.als = maybe emptymap (@nm mapsto) @body.mbal
%%]]
};


\node<22-22>[codebox] at(codeback.north west) {
%%[[wrap=safecode
SEM  Bind | Bind  
    lhs.als = maybe emptymap (@nm mapsto) @body.mbal
ATTR  Expr SYN mbal:Maybe Expr
SEM  Expr | Var
    lhs.mbal  =  Just (Var @nm)
%%]]
};


\node<23->[codebox] at(codeback.north west) {
%%[[wrap=safecode
SEM  Expr | Let
    loc.env =  @lhs.env `union` @defs.als
%%]]
};

%TODO: shortcut repeated aliases



\end{tikzpicture}
\end{frame}







\begin{frame}
\frametitle{Multi-pass tree traversal}


\begin{tikzpicture}
  [ synnt/.style={rectangle,                              inner sep=1pt, minimum height=4mm, minimum width=10mm, fill=blue,    text centered, text=white, font=\small, anchor=north},
    synco/.style={rectangle, draw=blue, line width=0.3pt, inner sep=1pt, minimum height=3mm, minimum width=10mm, fill=blue!20, text centered, text=blue,  font=\small, anchor=north},
    attrSynth/.style={yshift=1mm,xshift=0.3mm, rectangle, draw=green, line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=green!30, text centered, text=black,  font=\small, anchor=west},
    attrInh/.style={yshift=-1mm,xshift=-0.3mm, rectangle, draw=red,    line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=red!30,   text centered, text=black,  font=\small, anchor=east},
    attrLoc/.style={rectangle, draw=black,  line width=0.3pt, inner sep=1pt, minimum height=3mm, fill=black!30, text centered, text=black,  font=\small},
    synline/.style={draw=blue, line width=1.6pt},
    attrDep/.style={draw=black, line width=1pt, ->},
  ]

\draw[help lines,white] (0mm,-10mm) grid[step=10mm] (32mm,35mm);

\node[synnt](nt1a) at(15mm,25mm)  {Expr};
\node[synco](co1a) at(nt1a.south) {Let};
\node[synnt](nt2a) at(15mm,5mm)  {Expr};
\node[synco](co2a) at(nt2a.south) {Var};
\path[synline] (co1a.south)  -- (nt2a.north);


\node<2->[attrSynth](syn2a) at(nt2a.south east)   {als};
\node<2->[attrSynth](syn1a) at(nt1a.south east)   {als};
\path<2->[attrDep] (syn2a.north)  -- (syn1a.south);

\node<3->[attrInh](inh1a) at(nt1a.south west)   {env};
\path<3->[attrDep,out=100,in=80,looseness=1.8] (syn1a.north) to (inh1a.north);
\node<3->[attrInh](inh2a) at(nt2a.south west)   {env};
\path<3->[attrDep] (inh1a.south)  -- (inh2a.north);

\node<4->[attrSynth](syn2aa) at(syn2a.east)   {trf};
\path<4->[attrDep,out=300,in=240] (inh2a.south) to (syn2aa.south);
\node<4->[attrSynth](syn1aa) at(syn1a.east)   {trf};
\path<4->[attrDep] (syn2aa.north)  -- (syn1aa.south);

\end{tikzpicture}%
~%
\raisebox{2cm}{
\begin{minipage}{8cm}
Name alias inlining is a two-pass traversal:
\begin{itemize}
\item {\color{uured} First pass}\\
      \uncover<2->{Bottom-up gather |aliases|}
\item {\color{uured} Second pass}\\
      \uncover<3->{Top-down distribute |environment|}\\
      \uncover<4->{Bottom-up generate |transformed tree|}\\
\end{itemize}

\uncover<5->{Either rely on lazyness\\
Or let UUAG schedule the passes\\
~~~(and do cycle check)}
\end{minipage}
}

\end{frame}






%%]

%%[agInUHC

%% \begin{frame}
%% \frametitle{Test}
%% 
%% \begin{tikzpicture}[node distance=5mm,
%% every node/.style=draw,every join/.style=->]
%% \draw [help lines] (0,0) grid (3,2);
%% \node[red] (existing) at (0,2) {existing};
%% { [start chain]
%% \node [draw,on chain,join] {Hello};
%% \node [draw,on chain,join] {World};
%% \chainin (existing) [join];
%% \node [draw,on chain,join] {this};
%% \node [draw,on chain,join] {is};
%% }
%% \end{tikzpicture}
%% 
%% 
%% \begin{tikzpicture}
%%   [tree/.style={uured},
%%    attr/.style={draw=green!50}]
%% \node[anchor=north west,tree] (top) {|Expr_Let|}
%%   child{ node[tree](bindl){|BindL|}
%%     child{ node[tree](bind){|Bind|}
%%       child{
%%         node[tree](lbot){|String|}
%%       }
%%       child{
%%         node[tree](rbot){|Expr|}
%%       }
%%     }
%%   };
%% {
%% [start chain,every on chain/.style={join=by ->}]
%%  \node[anchor=west,attr,on chain,join] (bindenvG)  {|envG|};
%%  \node[anchor=west,attr,on chain,join] (bindlenvG)  at (bindenvG.south) {|envG|};
%% }
%% \end{tikzpicture}
%% \end{frame}
%% 

%% \begin{frame}
%% \frametitle{AG applied in UHC}
%% \begin{tikzpicture}
%% \matrix
%%   [ampersand replacement=\&,
%%    tree/.style={uured},
%%   ]
%% {
%% \node[anchor=north]
%% {
%% \begin{minipage}{.6\linewidth}
%% {\color{uured}Core}:
%% 
%% %%[[wrap=safecode
%% DATA Expr
%%   | Let         binds           :  BindL            ^^ ^^ body            : Expr
%%   | Var         nm              :  String
%%   | App         func            :  Expr             ^^ ^^ arg             : Expr
%%   ...
%% 
%% DATA Bind
%%   | Bind        nm              :  String           ^^ ^^ expr            : Expr
%% 
%% TYPE BindL      =   [Bind]
%% %%]]
%% \\[1ex]
%% 
%% \uncover<2->{
%% {\color{uured}Auxiliary Haskell}:
%% 
%% %%[[wrap=safecode
%% type Env = Map String Expr
%% %%]]
%% }
%% \end{minipage}
%% };
%% \&
%% \uncover<3->{
%% \node[anchor=north west,tree] (top) {|Expr_Let|}
%%   child[thick,uured]{ node[tree](bindl){|BindL|}
%%     child{ node[tree](bind){|Bind|}
%%       child{
%%         node[tree](lbot){|String|}
%%       }
%%       child{ node[tree](app){|Expr_App|}
%%         child{
%%           node[tree]{|Expr|}
%%         }
%%         child{
%%           node[tree](var){|Expr_Var|}
%%         }
%%       }
%%     }
%%   };
%% }
%% \\
%% };
%% %\draw[fill=uuyellow!50,semitransparent] (top.south) -- (lbot.south west) -- (rbot.south east) -- cycle ;
%% \end{tikzpicture}
%% \end{frame}
%% 
%% \begin{frame}
%% \frametitle{AG applied in UHC}
%% \begin{center}
%% \begin{tikzpicture}
%%   [scale=.8,
%%    level 3/.style={sibling distance=12em},
%%    start chain=envG,
%%    start chain=expenv,
%%    start chain=env,
%%    start chain=exptrf,
%%    start chain=trf,
%%    tree/.style={uured},
%%    attr/.style={draw=green!50},
%%    every on chain/.style={join=by {green,->}}]
%% \node[anchor=north west,tree] (top) {|Expr_Let|}
%%   child[thick,uured]{ node[tree](bindl){|BindL|}
%%     child{ node[tree](bind){|Bind|}
%%       child{
%%         node[tree](lbot){|String|}
%%       }
%%       child{ node[tree](app){|Expr_App|}
%%         child{
%%           node[tree](exp){|Expr|}
%%         }
%%         child{
%%           node[tree](var){|Expr_Var|}
%%         }
%%       }
%%     }
%%   };
%% \uncover<2->{
%%  \node[anchor=west,attr] (bindenvG) at (bind.east) {|envG|};
%%  \node[anchor=west,attr] (bindlenvG) at (bindl.east) {|envG|};
%%  \chainin(bindenvG)[on chain=envG,join];
%%  \chainin(bindlenvG)[on chain=envG,join];
%% }
%% \uncover<3->{
%%  \node[anchor=east,attr] (topenv) at (top.west) {|env|};
%%  \node[anchor=east,attr] (bindlenv) at (bindl.west) {|env|};
%%  \node[anchor=east,attr] (bindenv) at (bind.west) {|env|};
%%  \node[anchor=east,attr] (appenv) at (app.west) {|env|};
%%  \node[anchor=east,attr] (varenv) at (var.west) {|env|};
%%  \node[anchor=east,attr] (expenv) at (exp.west) {|env|};
%%  \chainin(bindlenvG)[on chain=env,join];
%%  \chainin(topenv)[on chain=env,join];
%%  \chainin(bindlenv)[on chain=env,join];
%%  \chainin(bindenv)[on chain=env,join];
%%  \chainin(appenv)[on chain=env,join];
%%  \chainin(varenv)[on chain=env,join];
%%  \chainin(appenv)[on chain=expenv,join];
%%  \chainin(expenv)[on chain=expenv,join];
%% }
%% \uncover<4->{
%%  \node[anchor=west,attr] (exptrf) at (exp.east) {|trf|};
%%  \node[anchor=west,attr] (vartrf) at (var.east) {|trf|};
%%  \node[anchor=west,attr] (apptrf) at (app.east) {|trf|};
%%  \node[anchor=west,attr] (bindtrf) at (bindenvG.east) {|trf|};
%%  \node[anchor=west,attr] (bindltrf) at (bindlenvG.east) {|trf|};
%%  \node[anchor=west,attr] (toptrf) at (top.east) {|trf|};
%%  \chainin(vartrf)[on chain=trf,join];
%%  \chainin(apptrf)[on chain=trf,join];
%%  \chainin(bindtrf)[on chain=trf,join];
%%  \chainin(bindltrf)[on chain=trf,join];
%%  \chainin(toptrf)[on chain=trf,join];
%%  \chainin(exptrf)[on chain=exptrf,join];
%%  \chainin(apptrf)[on chain=exptrf,join];
%% }
%% \end{tikzpicture}
%% \end{center}
%% \end{frame}
%% 
%% 
%% 
%% % \node<3->[shape border rotate=90,fit=(top) (lbot) (rbot),fill=uuyellow!50,semitransparent] {};
%% % isosceles triangle,
%% 
%% %{
%% %format empty = "\epsilon"
%% \begin{frame}
%% \frametitle{AG applied in UHC}
%% %%[[wrap=safecode
%% ATTR Bind BindL SYN envG USE {`union`} {empty}: Env
%% %%]]
%% 
%% \uncover<2->{
%% %%[[wrap=safecode
%% SEM Bind  | Bind        lhs         .   envG        =   maybe empty (singleton @nm) @expr.alias
%% 
%% ATTR Expr SYN alias: {Maybe Expr}
%% %%]]
%% }
%% 
%% \uncover<3->{
%% %%[[wrap=safecode
%% SEM Expr
%%   | Var         lhs         .   alias       =   Just @trf
%%   | * - Var     lhs         .   alias       =   Nothing
%% %%]]
%% }
%% 
%% %%[[wrap=safecode
%% ATTR Expr Bind BindL INH env: Env
%% %%]]
%% 
%% \uncover<4->{
%% %%[[wrap=safecode
%% SEM Expr
%%   | Let         loc         .   env'        =   map  (\(Expr_Var n) ->  findWithDefault
%%                                                                           (Expr_Var n) n @lhs.env)
%%                                                      @binds.envG
%%                             .   env         =   @env' `union` @lhs.env
%% %%]]
%% }
%% 
%% %%[[wrap=safecode
%% ATTR Expr Bind BindL SYN trf: SELF
%% %%]]
%% 
%% \uncover<5->{
%% %%[[wrap=safecode
%% SEM Expr  | Var         lhs         .   trf         =   findWithDefault @trf @nm @lhs.env
%% %%]]
%% }
%% \end{frame}
%% %}
%% 
%%]

%%[aspectsAndVariants
\begin{frame}
\frametitle{AG programming in UHC}

Attribute Grammar descriptions for
\begin{itemize}
\item {\color{uured}Analyses} \\
 ~~HS: Name dependency\\
 ~~EH: Typing\\
 ~~Grin: Heap Points To, Call Graph
\item {\color{uured}Transformations} \\
 ~~Core: Lambda Lifting\\
 ~~Grin: Drop Unreachable Bindings
\item {\color{uured}Generation} \\
 ~~Next language, Pretty Printing
\end{itemize}
\vspace{1.5em}

\uncover<2->{
|DATA|s, |ATTR|s, and |SEM|s grouped as aspects

\vspace{1.5em}

\begin{flushright}
and actually...
\end{flushright}
}

\end{frame}



%% \begin{frame}
%% \frametitle{AG programming in UHC}
%% 
%% Attribute Grammar descriptions for
%% \begin{itemize}
%% \item {\color{uured}Transformations}: Core \textit{Name Alias Elimination},\\
%%       and many others on Core, Grin, ...
%% \item<2-> {\color{uured}Analyses}: EH typing, Grin whole program analysis, ...
%% \item<2-> {\color{uured}Simplifications}: Core \textit{Lambda Lifting}, ...
%% \item<2-> {\color{uured}Generation}: Core from EH, using results from type analysis
%% \end{itemize}
%% \vspace{2em}
%% 
%% \uncover<3->{
%% |DATA|s, |ATTR|s, and |SEM|s grouped as aspects
%% 
%% \vspace{2em}
%% 
%% \begin{flushright}
%% and actually...
%% \end{flushright}
%% }
%% 
%% \end{frame}



\begin{frame}
\frametitle{Aspectwise organisation}

{\Large\textit{\color{uured}All code} grouped as aspects}

\vspace{2em}

Along two dimensions:

\begin{itemize}
\item {\color{uured}Variant}: a step in the stepwise growth in language features
\item {\color{uured}Aspect}: a set of attributes and its resulting computation
\end{itemize}

\vspace{2em}

\uncover<2->{
{\Large\textit{Shuffle} extracts code fragments} \\
tagged with the required variant/aspect
}

\end{frame}


\begin{frame}
\frametitle{Variants and aspects}

E.g. aspect \textit{typing} for the first variants of UHC:

\begin{itemize}
\item variant {\color{uured}1}: simply typed |lambda|-calculus

%%[[wrap=safecode
i  ::  Int
i  =   5
%%]]

\item<2-> variant {\color{uured}3}: polymorphic type inference
\visible<2->{

%%[[wrap=safecode
id x  =   x
%%]]

infers |id :: forall ^ a . a -> a|
}

\item<3-> variant {\color{uured}4}: higher ranked types
\visible<3->{

%%[[wrap=safecode
f :: (forall ^ a . a -> a) -> (Char,Int)
f i = (i 'x', i 5)

v = f id
%%]]

allows polymorphic use of argument |i| inside |f|
}


\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Variants}

In UHC

\begin{enumerate}
\item[~]<2-> \makebox[50mm][l]{{\color{uured}plain Haskell}}                  {\color{uured}experiments}
\item<1-> \makebox[50mm][l]{$\lambda$-calculus, type checking}
\item<1-> \makebox[50mm][l]{type inference}
\item<1-> \makebox[50mm][l]{polymorphism}
\item<1-> \makebox[50mm][l]{}                                  \visible<1->{higher ranked types, existentials}
\item<1-> \makebox[50mm][l]{data types}
\item<2-> \makebox[50mm][l]{kind inference}                    kind signatures
\item<2-> \makebox[50mm][l]{records}                           tuples as records
\item<2-> \makebox[50mm][l]{code generation}                   full program analysis
\item<2-> \makebox[50mm][l]{classes, type-synonyms}            extensible records
\setcounter{enumi}{19}
\item<3-> \makebox[50mm][l]{modules}
\setcounter{enumi}{94}
\item<3-> \makebox[50mm][l]{`deriving'}                      exceptions
\setcounter{enumi}{98}
\item<3-> \makebox[50mm][l]{prelude, I/O}
\end{enumerate}

\end{frame}



\frametitle{Variants and aspects}

\begin{itemize}
\item Two dimensions for partitioning the description of UHC
\item Combination of variant and aspects can be build as a compiler
 \begin{itemize}
 \item Isolation of language feature and aspect
 \item For debugging, experimentation, explanation
 \end{itemize}
\item Code is partitioned in small chunks
 \begin{itemize}
 \item Tagged with variant number and aspect name
 \item Processed by tool (Shuffle) to generate AG and/or Haskell input
 \end{itemize}
\item Last variant + all aspects = UHC
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Variants and aspects}

\begin{center}
\begin{tikzpicture}
  [minimum height=1.5em,
   column 1/.style={anchor=east},
   column 2/.style={anchor=east},
   column 3/.style={minimum width=4em},
   column 4/.style={minimum width=4em},
   column 5/.style={minimum width=7em},
   row 10/.style={anchor=north},
   row 11/.style={anchor=north},
   row 12/.style={anchor=north},
   block/.style={rectangle,  fill=uured!20, text centered},
   valida/.style={rectangle,  fill=uured!20, text centered},
   validb/.style={rectangle,  fill=uured!40, text centered},
  ]

\def\valid{\node<4->[valida]{\(\checkmark\)}}
\def\valida{\node<4>[valida]{\(\checkmark\)}}
\def\validb####1{\node<5>(####1)[validb]{\(\checkmark\)}}
\matrix[ampersand replacement=\&]
{

    \& \node[red]{\textit{variants}} ;
    \& 
    \&
    \& \node(topright){} ;
\\
\node{99:} ;
    \& \node(topleft){libraries} ;
    \& \valid ;
    \& \node<2->[block](uhc){UHC} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{20:} ;
    \& \node{modules} ;
    \& \valid ;
    \& \valid ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \& \valid ;
    \&
\\
\node{9:} ;
    \& \node{classes} ;
    \& \valid ;
    \& \valid ;
    \& \node<3->[block]{Ext Recs} ;
\\
\node(variantx){8:} ;
    \& \node{primitives} ;
    \& \valid ;
    \& \valida ; \validb{calloutaloc} ; % node<5>(calloutaloc)[validb]{\(\checkmark\)} ;
    \&
\\
%% \node{\(\cdots\)} ;
    \& \node{\(\cdots\)} ;
    \& \valid ;
    \&
    \&
\\
\node{1:} ;
    \& \node{|lambda|-calculus} ; 
    \& \valid ;
    \&
    \&
\\

    \& \node(botleft)[anchor=north east]{} ;
    \& \node{typing} ;
    \& \node(aspectx){codegen} ;
    \& \node(botright){experiment} ;
\\

    \& 
    \& 
    \&
    \& \node[red]{\textit{aspects}} ;
\\

    \& 
    \& 
    \&
    \& \node[red]{\textit{(accumulative)}} ;
\\
};
\draw [thick]
  (botleft.north east) -- (topleft.north east)
  (botleft.north east) -- (botright.north east);
%% \node<2->[anchor=south] at (uhc.north) {bla} ;

\node<5>(callouta)[anchor=north east,rectangle callout, drop shadow, fill=black!15, callout absolute pointer={(calloutaloc)}] at (topright.north east) {\parbox{.235\linewidth}{
\begin{verbatim}
%%%[(8 typing codegen)
...
%%%]
\end{verbatim}
}} ;
%\draw<5>[->] (callouta) -- (variantx) ;
%\draw<5>[->] (callouta) -- (aspectx) ;

\end{tikzpicture}
\end{center}

\end{frame}



%%]

%%[conclusions
\begin{frame}
\frametitle{Metrics}

We use {\color{uured} Attribute Grammar}s a lot!

\def\hsColor{yellow!50}
\def\agColor{green!50}
\def\cColor{blue!30}
\gdef\bar####1(####2)(####3){\draw[black,fill=####1] (####2) rectangle (####3)}
\gdef\barHS(####1)(####2){\bar{\hsColor}(####1)(####2)}
\gdef\barAG(####1)(####2){\bar{\agColor}(####1)(####2)}
\gdef\barC(####1)(####2){\bar{\cColor}(####1)(####2)}

\begin{center}
\begin{tikzpicture}[yscale=0.2,xscale=0.7]
%\draw [help lines] grid (11,30);
\foreach \x/\lbl/\ys in
   {0/Utility/{1.7,18.3,0},
    1/Haskell/{6.7,3.3,0},
    2/EH/{11.2,0.6,0},
    3/Typing/{8.0,7.5,0},
    4/Core/{7.1,1.0,0},
    5/ByteCode/{2.1,0,0},
    6/Grin/{11.3,1.6,0},
    7/Silly/{2.8,0,0},
    8/Exp Backends/{2.5,0.4,0},
    9/Runtime/{0,0,8.1},
    10/GC/{0,0,6.0,}}
 {
  %\pgfmathsetmacro{yaccum}{0}
  \foreach \y in \ys
  {
   %\draw (\x,\y) circle (0.1cm);
   %\pgfmathsetmacro{yaccum}{\y + \yaccum}
  } ;
  \node[rotate=-45,anchor=north west] at (\x+0.4,0) {\lbl} ;
 } ;

\foreach \y/\lbl in {0/0,5/5000,10/10000,15/15000,20/20000}
 {
  \node[anchor=east] at (0,\y) {\lbl} ;
 };

%%% 0:
\barAG(0,0)(1,1.7) ;
\barHS(0,1.7)(1,20) ;

%%% 1:
\barAG(1,0)(2,6.7) ;
\barHS(1,6.7)(2,10) ;

%%% 2:
\barAG(2,0)(3,11.2) ;
\barHS(2,11.2)(3,11.8) ;

%%% 3:
\barAG(3,0)(4,8.0) ;
\barHS(3,8.0)(4,15.5) ;

%%% 4:
\barAG(4,0)(5,7.1) ;
\barHS(4,7.1)(5,8.1) ;

%%% 5:
\barAG(5,0)(6,2.1) ;

%%% 6:
\barAG(6,0)(7,11.3) ;
\barHS(6,11.3)(7,12.9) ;

%%% 7:
\barAG(7,0)(8,2.8) ;

%%% 8:
\barAG(8,0)(9,2.5) ;
\barHS(8,2.5)(9,2.9) ;

%%% 9:
\barC(9,0)(10,8.1) ;

%%% 10:
\barC(10,0)(11,6) ;

\matrix[ampersand replacement=\&, anchor=north west] at (11,21)
{
\node[black,fill=\agColor] {AG}; \& \node{53.4\%};  \\
\node[black,fill=\hsColor] {HS}; \& \node{32.5\%};  \\
\node[black,fill=\cColor] {C}; \& \node{14.1\%};  \\
};

\end{tikzpicture}
\end{center}

%% \begin{tabular}{l||rrrr||rr}
%% subsystem    & \multicolumn{4}{c||}{All variants and aspects}    & \multicolumn{2}{c}{UHC only} \\
%%              &    AG      &    HS      &     C      &    total   &    total   &  fract.  \\\hline
%% utility/general&   1.7    &    18.3    &            &    20.0    &    14.0    &    70\%  \\
%% Haskell      &     6.7    &     3.3    &            &     9.9    &     6.9    &    70\%  \\
%% EH           &    11.2    &     0.6    &            &    11.8    &     6.7    &    57\%  \\
%% EH typing    &     8.0    &     7.5    &            &    15.5    &     7.0    &    45\%  \\
%% Core         &     7.1    &     1.0    &            &     8.0    &     4.7    &    58\%  \\
%% ByteCode     &     2.1    &            &            &     2.1    &     1.7    &    82\%  \\
%% Grin         &    11.3    &     1.6    &            &    12.9    &     8.5    &    66\%  \\
%% Silly        &     2.8    &            &            &     2.8    &     2.6    &    93\%  \\
%% exp.backends &     2.5    &     0.4    &            &     2.9    &     0.8    &    26\%  \\
%% runtime system&           &            &     8.1    &     8.1    &     6.2    &    77\%  \\
%% garb.collector&           &            &     6.0    &     6.0    &     0.7    &    11\%  \\\hline
%% total        &    53.4    &    32.5    &    14.1    &   100.0    &    59.8    &    60\%  \\
%% \end{tabular}

\end{frame}



\begin{frame}
\frametitle{Summary}

\def\xa{0}
\def\xb{4}
\def\xc{8}
\def\xlshft{0}
\def\boxw{.31\linewidth}

\def\ya{6.5}
\def\yb{5}
\def\yc{2}

\begin{center}
\begin{tikzpicture}

\draw[help lines,white] (-1mm,-1mm) grid[step=5mm] (12,\ya);

\node[anchor=north west] at (\xa,\ya) {
  \begin{minipage}{\boxw}
   \raggedright
   Tree orientation:\\
   Attribute Grammar
  \end{minipage}
} ;
\node<2->[anchor=north west] at (\xb,\ya) {
  \begin{minipage}{\boxw}
   \raggedright
   Aspect orientation:\\
   Shuffle
  \end{minipage}
} ;
\node<3->[anchor=north west] at (\xc,\ya) {
  \begin{minipage}{\boxw}
   \raggedright
   General
  \end{minipage}
} ;

\node[anchor=north west,fill=green!20,draw=green] at (\xa-\xlshft,\yb) {
  \begin{minipage}{\boxw}
   \raggedright
   Conciseness \\
   Attribute specification \\
   Boilerplate generation \\
    - trivial copies \\
    - fold \\
  \end{minipage}
} ;
\node<2->[anchor=north west,fill=green!20,draw=green] at (\xb-\xlshft,\yb) {
  \begin{minipage}{\boxw}
   \raggedright
   Variant:\\
   ~~feature isolation \\
   Aspect:\\
   ~~experimentation \\
  \end{minipage}
} ;
\node<3->[anchor=north west,fill=green!20,draw=green] at (\xc-\xlshft,\yb) {
  \begin{minipage}{\boxw}
   \raggedright
   Simpler design and coding
  \end{minipage}
} ;

\node[anchor=north west,fill=uured!20,draw=uured,minimum height=1cm] at (\xa-\xlshft,\yc) {
  \begin{minipage}{\boxw}
   \raggedright
   New idiom
  \end{minipage}
} ;
\node<2->[anchor=north west,fill=uured!20,draw=uured,minimum height=1cm] at (\xb-\xlshft,\yc) {
  \begin{minipage}{\boxw}
   \raggedright
   Fixed order
  \end{minipage}
} ;
\node<3->[anchor=north west,fill=uured!20,draw=uured,minimum height=1cm] at (\xc-\xlshft,\yc) {
  \begin{minipage}{\boxw}
   \raggedright
   Complex build system
  \end{minipage}
} ;

%% %% box
%% \draw (0,0) -- (\xc+3.5,0) -- (11.5,\ya+.1) -- (0,\ya+.1) -- cycle ;
%% %% hlines
%% \draw (0,\yb+.1) -- (\xc+3.5,\yb+.1) ;
%% \draw (0,\yc+.1) -- (\xc+3.5,\yc+.1) ;
%% %% vlines
%% \draw (\xb-.1,0) -- (\xb-.1,\ya+.1) ;
%% \draw (\xc-.1,0) -- (\xc-.1,\ya+.1) ;

\end{tikzpicture}
\end{center}

\end{frame}

%% 
%% 
%% \begin{frame}
%% \frametitle{Conclusions}
%% 
%% Use of {\color{uured} Attribute Grammar} is essential for dealing with description \& coding complexity:
%% 
%% \begin{itemize}
%% \item Much boilerplate code for treewalks is avoided
%% \item Aspects can be described separately
%% \item Separately described aspects are combined by the AG compiler
%% \item AG compiler takes care of plumbing all code as one fold and ordering of attribute computations
%% \item Scales up in the number of combined aspects
%% \end{itemize}
%% 
%% But
%% 
%% \begin{itemize}
%% \item You have to learn it  %%%, and other used domain specific languages as well
%% \end{itemize}
%% \end{frame}
%% 
%% 
%% \begin{frame}
%% \frametitle{Conclusions}
%% 
%% Use of {\color{uured} variants and aspects} is essential for dealing with design complexity:
%% 
%% \begin{itemize}
%% \item Language features are isolated in a variant
%% \end{itemize}
%% 
%% But
%% 
%% \begin{itemize}
%% \item Inherent language \& implementation complexity is not decreased, only made more manageable
%% \item Chosen partitioning into variants is difficult to adapt
%% \end{itemize}
%% 
%% \end{frame}
%% 
%% 
%% 
%% 
%% \begin{frame}
%% \frametitle{Conclusions}
%% 
%% %% {\color{uured} include this????}
%% 
%% Use of {\color{uured} domain specific languages} and {\color{uured} generation} is essential for dealing with maintenance complexity:
%% 
%% \begin{itemize}
%% \item Avoids duplicates consistency pitfall by generating from shared description
%% \end{itemize}
%% 
%% But
%% 
%% \begin{itemize}
%% \item More complex build system
%% \end{itemize}
%% 
%% \end{frame}



%% \begin{frame}
%% \frametitle{Questions?}
%% 
%% 
%% \end{frame}



%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]

%%[XX
%%]
