

\title{EHC Architecture}
\author{Jeroen Fokker}
\date{September 6th, 2006}
\maketitle


This report describes the architecture of EHC,
the Extensible Haskell Compiler as developed
by the Software Technology group of Utrecht University.

In section~\ref{sec.toolchain} we introduce the tools which are used to build the compiler:
ghc, shuffle, uuagc and ruler.

In section~\ref{sec.dataflow} we describe the main data flow of EHC,
as a program is transformed from Haskell to executable code.

In section~\ref{sec.source} we enumerate the source files and their dependencies.

In section~\ref{sec.files} we describe the layout of the file system organization.

\clearpage
\section{Tool chains}\label{sec.toolchain}

EHC is a Haskell compiler which itself is written in Haskell.
Although in the future we might be able to bootstrap the compiler
to compile itself, for the moment we use {\em ghc} to compile the compiler.

Only a few modules of the EHC source are actually written directly in Haskell.
Most of the source is preprocessed by one or more tools.
Figure~\ref{fig.toolchain} shows the way in which the tools generate intermediate files,
which ultimately are linked together to build the EHC executable.

A short description of the tools follows.
\begin{itemize}

\item {\bf ghc}\\
The Glasgow Haskell compiler takes a Haskell module (file extension {\em hs})
and generates standard binary object code (file extension {\em o}).
Many object code modules can be linked together with {\bf ln}, but this
is normally done automatically by ghc.
Also, ghc generates files containing information for other modules that
want to import the module (file extension {\em hi}).

\item {\bf shuffle}\\
There are many views of EHC, each of which adds new features to its predecessor.
Instead of maintaining the source code of each view separately,
code for all views of a module is put together in a single file,
known as a `chunked Haskell script' (file extension {\em chs}).
A chunked file contains meta information as to which chunks 
are needed for which view.

A tool named `shuffle' extracts the chunks that belong to any desired view
and generates a normal Haskell script containing only those chunks.

When invoked with different options, shuffle is also able to 
generate documentation from the source files, thus enable
a `literate programming' style of documentation.

\item {\bf uuagc}\\
Recursive treewalks over an abstract data structure can be elegantly modeled
using attribute grammars. Information passes down the tree as {\em inherited} attributes,
and one or more semantic values can be derived as {\em synthesized} attributes.

The `Utrecht University Attribute Grammar Compiler' (uuagc) takes a description
of an abstract syntax tree and its semantics, and generates Haskell functions
that perform the necessary treewalks.
Source code for uuagc is stored in files with extension {\em ag}.

In the same way as for Haskell modules, different views of an AG compilation unit
can be stored in a single, `chunked' file.
The shuffle tool is used to extract the desired chunks
from a chunked attribute grammar files (file extension {\em cag}) to a file that 
subsequently is processed by uuagc.

\item {\bf ruler}\\
The derivation of the type of an expression can be described as a treewalk
over the expression, and therefore the AG-language can be used to describe
typing algorithms.
However, in the literature typing rules are often described in an even more
high level language, involving judgements separated by horizontal rules.

A tool named `ruler' takes a description in this style, and generates the
corresponding attribute grammar.
As the ruler language contains a built-in mechansim for different views, 
no need for `chunked' ruler programs is needed.

When invoked with different options, ruler is also able to
generate typeset descriptions of the rules, which are not only
beautifully laid out, but also guaranteed to be consistent with
the generated compiler modules.
 
\end{itemize}

\newpage
Figure~\ref{fig.toolchain} also shows the directories in which various files can be found:
\begin{itemize}
\item {\bf Source files} (shown shaded yellow)
are kept in a separate directory for each product:
\begin{subitize}
\item chunked Haskell and chunked AG sources for the EHC frontend are in directory {\sf ehc}
\item chunked Haskell and chunked AG sources for the EHC backend are in directory {\sf grinc}
\item Ruler sources for EHC are in subdirectory {\sf ehc/rules}
\item chunked Haskell and chunked AG sources for the Grin interpreter are in directory {\sf grini}
\item library (non-chunked) Haskell modules written for, but not specific to this project are in directory {\sf libutil}
\end{subitize}

\item {\bf Intermediate files} (shown shaded blue)
are generated by the described tools, in a separate directory for each view
as extracted by shuffle:
\begin{subitize}
\item all intermediate files 
(un-chunked AG and HS files generated by shuffle and ruler, 
HS files generated by uuagc,
HI and O files as generated by ghc)
for view {\em n}
are stored in directory {\sf build/}{\em n} (for {\em n} between 1 and 12)
\item compiled views of the library modules are also stored in directory {\sf libutil}
\end{subitize}

\item {\bf Output files} (shown shaded green)
\begin{subitize}
\item all output files 
(executable for EHC compiler, Grin interpreter and compiler)
for view {\em n}
are stored in directory {\sf bin/}{\em n}
\end{subitize}

A detailed description of the file system layout is given in section~\ref{sec.files}.


\end{itemize}




\begin{figure}[tbp]
\raisebox{-10mm}[100mm][0mm]{\simplepicture{0.6}{toolchain}}
\caption{Tools in the EHC project}
\label{fig.toolchain}
\end{figure}


\clearpage

\section{EHC Main dataflow}\label{sec.dataflow}

Figure~\ref{fig.dataflow} shows the main data flow of EHC.
The compilation process consists of various stages in which the
program is transformed. 
There are multiple entry- and exit-points:
\begin{itemize}
\item 
Input can either be a Haskell program, a program in the custom EH notation,
or a more low-level program in the Grin language.
Input type is recognized by file extension (\verb"hs", \verb"eh" or \verb"grin").
\item
Output can either be pretty printed Haskell, 
pretty printed EH with derived type annotations,
pretty printed Core,
pretty printed Grin,
or ready-to-compile C code.
Output type is selected by the \verb"-c" compiler option.
\end{itemize}

The picture shows various intermediate data types in green boxes,
and transformations between them.
\begin{itemize}
\item {\bf HS:}{\em Module}
represents a Haskell module.
There is a parser for it, and a single transformation 
which in one traversal performs both pretty printing and
conversion to EH.

\item {\bf EH:}{\em Expr}
represents an expression in the EH custom language.
In fact, this can be a program, as a program is just the expression
from the body of \verb"main" with many local definitions.
There is a parser for it, and a single transformation
which in one traversal does the typing, pretty printing, 
and conversion to Core.

\item {\bf Core:}{\em CModule}
represents a module in the Core language.
Many conversions are available as a Core-to-Core transformation
(e.g. lambda lifting, constant propagation).
There are separate conversions to pretty printed output, 
input to a simulator written in Java,
and a Grin datastructure.

\item {\bf GrinCode:}{\em GrinModule}
represents a module in Grin, a Graph Reduction Intermediate Notation.
Many conversions are available as a Grin-to-Grin transformation
(e.g. inlining of eval, pruning sparse case distinctions).
There are separate conversions to pretty printed output, 
and a Silly datastructure.


\item {\bf Silly:}{\em SilModule}
represents a module in a generic imperative language,
that can be converted to C 
(and in the future possibly to other imperative languages).

\end{itemize}






\begin{figure}[bp]
\raisebox{-30mm}[30mm][0mm]{\simplepicture{0.6}{ehc-dataflow}}
\caption{EHC main data flow}
\label{fig.dataflow}
\end{figure}



\clearpage

\section{Source file dependencies}\label{sec.source}

Figure~\ref{fig.ag-import} shows all source files of EHC.
The files are organized in columns based on whether they describe syntax,
describe semantics, or contain auxiliary functions.
The files are organized in rows based on the subsystem they belong to.
Arrows indicate inclusion as done by the AG-compiler.

The ordering in {\bf columns} is as follows:
\begin{itemize}

\item 
Column {\em syntax, AG-unit}
shows AG-units that describe the data structures for various tree structures.
These units are compiled by the AG-compiler using the {\tt -dr} option.
The output of the AG-compiler is a Haskell module containing only data declarations.
The files contain merely headers, and for the actual data structure
import a corresponding file from the next column.

\item
Column {\em syntax, import}
shows files that contain the actual data structure definitions.
These files are not standalone AG-units, and thus no corresponding Haskell files
are generated.
They are imported by the syntax AG-units in the first column,
but also by the semantics AG-units in the third column.

The data types that are defined in these files are enumerated in the green box
above the file name. List types are conventionally named by appending `s' or 'L'
to the base type name.

\item
Column {\em semantics, AG-unit}
shows AG-units that contain attribute definitions for the various tree structures.
These units are compiled by the AG-compiler using the {\tt -cfspr} option.
The output of the AG-compiler is a Haskell module containing 
catamorphisms for the data structures,
semantic functions and their signatures,
and (in comment) a pretty printed list of all attributes.

\item
Column {\em semantics, import}
shows files that are imported by the semantics AG-units.
The files themselves are not standalone AG-units, and thus no corresponding Haskell files
are generated.
Import is handled by the AG-compiler as textual inclusion.
This mechanism is used for two purposes:
\begin{subitize}
\item (e.g., in the `HS' and `EH' subsystems:) 
      to split up a large file in multiple files, each describing a few attributes
\item (e.g., in the `Type' and `Core' subsystems:)
      to use an attribute definition in more than one AG-unit.
      Note that in this case, the code for the attribute definitions is
      duplicated in the semantic function for each AG-unit in which is is imported.
\end{subitize}

\item
Column {\em auxiliary}
shows files containing auxiliary Haskell functions.
These functions will normally be:
\begin{subitize}
\item a {\tt main} function, and any function that is called from there
\item functions that are used in the attribute definitions
\end{subitize}
As the AG-compiler does not interpret Haskell code in attribute definitions,
files in this column are ignored by the AG-compiler.

\end{itemize}

\newpage
The ordering in {\bf rows} is according to subsystem.
Some of these (shown in bold face in the list below) are 
a chain in the main data flow, the others are auxiliary.
\begin{itemize}

\item
Row {\em Base}
shows a few auxiliary files common to the whole system.

\item
Row {\em Scanner}
shows files that perform the tokenization of input into symbols,
that can be parsed by other subsystems.

\item
Row {\em Gam}
shows an auxiliary file for manipulating environments (commonly denoted as $\Gamma$).

\item
Row {\bf HS}
shows files for reading and storing Haskell programs,
and transforming them to the custom EH language.

\item
Row {\bf EH}
shows files for reading and storing programs
in the EH custom language, checking and/or infering their types,
and transforming them to the EH Core language.

\item
Row {\em Type}
shows files for storing and manipulating types.

\item
Row {\bf Core}
shows files for storing programs
in the EH Core language,
doing transformations on them,
and transforming them to a more imperative language Grin.


\item
Row {\em Error}
shows files for manipulating error messages.
An abstract syntax for (lists of) error messages is defined,
and a semantic function to pretty print it.

\item
Row {\em libutil}
shows some auxiliary Haskell files that are written for this project,
but not specific to EHC.
These files are ordinary (non-chunked) Haskell files.


\item
Row {\em grini}
shows files for a stand-alone Grin interpreter, that
can read and execute Grin programs.

\item
Row {\bf GrinCode}
shows files for reading and storing programs in Grin,
doing transformations on them as described by Boquist,
and transforming them to an imperative language.

\item
Row {\bf Silly}
shows files for storing and manipulate programs in
a Simple Imperative little Language,
which can be easily converted to C and other imperative languages.


\item
Row {\em CmmCode}
shows an alternative back-end to Grin, generating C$--$ programs
(this subsystems is not maintained anymore).


\end{itemize}



\begin{figure}[tbp]
%\simplepicture{0.45}{ag-import1}

%\simplepicture{0.45}{ag-import2}

%\simplepicture{0.45}{ag-import3}


\raisebox{10mm}[70mm][0mm]{\simplepicture{0.45}{ag-import1}}

\raisebox{0mm}[60mm][0mm]{\simplepicture{0.45}{ag-import2}}

\raisebox{0mm}[80mm][0mm]{\simplepicture{0.45}{ag-import3}}

\caption{EHC source files, and their inclusion by the AG-compiler}
\label{fig.ag-import}
\end{figure}



\clearpage


\clearpage

\section{File system layout}\label{sec.files}


Figure~\ref{fig.files} shows the organization of the EHC files in directories.
Files shown in {\em yellow} are the original source files that you get when you download the system.
Files shown in {\em blue} are intermediate files that are generated when you type \verb"make".
Files shown in {\em green} are the final products that are generated.

The source directory {\bf src} is structured as follows.
The twelve subsystems described in section~\ref{sec.source} are stored
in three subdirectories {\em ehc}, {\em grinc} and {\em grini}.
This is a historical remain from the time that the frontend and the backend
were separate products. Hence, these directories are summarized by {\bf P} (for `product')
in the picture.
The {\em ehc} and {\em grinc} product directories have subdirectories for the twelve subsystems, 
summarized by {\bf S} (for `subsystem') in the picture.
Note that the {\em GrinCode} subsystem is split over the two products.
This is not very logical, and a reason to merge the two product directories in the future.
Furthermore, there are subdirectories for the two tools that are packed with the
EHC project: {\em shuffle} and {\em ruler}.
Their directories are summarized by {\bf T} (for `tool') in the picture. 
Finally, there is a separate directory for the {\em libutil} utilities.

The binary directory {\bf bin} is structured as follows.
There is a subdirectory for each view of the compiler (1 to 12, and some experimental ones).
Remember that these views correspond with the subsequent extensions of the compiler.
Each numbered subdirectory contains the executable products ({\em ehc}, {\em grini} and the obsolescent {\em grinc})
for that view.
Also, both tools ({\em shuffle} and {\em ruler}) reside in this directory.

The intermediate directory {\bf build} is most complex of all,
but will seldomly be visited by human readers.
It contains all the intermediate files resulting from the tool chains described in section~\ref{sec.toolchain}.

The installation directory {\bf install} contains a copy of the binary products
once they are installed.
Also, it contains the Cabal libraries (and their interface files) that can be used to separately compile parts of the system.
Note that a separate library is build for each view/version combination.

All subdirectories are grouped in one super directory {\bf EHC}.
There is a copy of the entire tree in the {\em trunk}, and in each author's personal {\em branch}.
From time to time we might freeze the trunk in a verison in directory {\em tags}.
The trunk, each author's branch and each tagged version are collected in a main directory {\bf ehc}
which is stored in a public repository.

\begin{figure}[bp]
\raisebox{0mm}{\simplepicture{0.7}{ehc-directories}}
\caption{EHC file system layout}
\label{fig.files}
\end{figure}

















