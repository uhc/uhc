%%[chapter
\chapter{The Low Level Virtual Machine Compiler Infrastructure}
\label{cha:llvm}
In the introductory chapter of this thesis, the Low Level Virtual Machine (LLVM) assembly language is mentioned as the typed assembly language that is used as the backend target. The LLVM assembly language is part of the LLVM compiler infrastructure project, a free and open source project offering a compiler backend infrastructure. This chapter discusses the motivation for choosing LLVM (\refS{sec:llvm-motivation}) and 2 key elements of the LLVM compiler infrastructure: the life long optimization compilation strategy (\refS{sec:llvm-life-long-optimization}) and the LLVM assembly language (\refS{sec:llvm-assembly-language}).

\section{Motivation}
\label{sec:llvm-motivation}
LLVM is very attractive as a backend for the Essential Haskell Compiler (EHC), due to the following reasons:
\begin{itemize}
  \item The executables generated by EHC are too inefficient for production quality when compared to executables produced by the Glasgow Haskell Compiler (GHC). LLVM provides aggressive intraprocedural and interprocedural optimizations, which are expected to improve the efficiency of the EHC executables.
  \item For a production compiler, it is important that EHC is able to produce executables for many architectures. LLVM supports the x86, x86-64, PowerPC 32/64, ARM, Thumb, IA-64, Alpha, SPARC, MIPS and CellSPU architectures. Currently, EHC supports the x86, x86-64 and PowerPC architectures, based on compilation to C.
  \item The LLVM project has a large user base and is actively maintained. This is an important selection criteria, as the native code generator needs to keep up with the developments of platforms and operating systems. It would be a shame if we have a fast Haskell compiler that is unusable by many users because LLVM is not supported on a new architecture or operating system. 
\end{itemize}

There are many alternatives for the use of LLVM, such as GCCs GIMPLE~\cite{merrill:03} and C{-}{-}~\cite{jones99}. We prefer LLVM over GIMPLE as it is very hard to use without integrating EHC in GCC. C{-}{-} is less attractive than LLVM due to the lack of active development and maintenance of the platform.

\section{Life long optimization}
\label{sec:llvm-life-long-optimization}
Traditionally, static compilers perform nearly all of their optimizations at compile time. This in contrast to just-in-time (JIT) compilers, which focus on runtime optimization. LLVM adopts the life long optimization strategy, which supports optimizing during the five moments in the life time of a program: compile time, link time, install time, runtime and idle time.
\begin{enumerate}
  \item At compile time, a selection of intraprocedural optimizations are performed on each LLVM assembly module. This allows for separate compilation and fast recompilations. The standard selection of optimizations contains many well known optimizations such as dead code elimination, constant propagation, and common sub-expression elimination. The result of this phase is an intraprocedurally optimized LLVM assembly module.
  \item Link time is the first time most application code is available and is the natural time to apply aggressive interprocedural optimizations. As with compile time optimizations, the standard selection of optimizations supplies many well known optimizations. After link time, all LLVM assembly modules are combined in one big optimized LLVM assembly module.
  \item At install time, the characteristics of the architecture are known and machine dependent optimizations are performed. Good examples are aligning loads and stores, branch reordering, and allocating registers efficiently. The result of this phase is native code. When using static offline code generation, this translates to a native executable. If JIT compilation is used, install time is scheduled simultaneous with runtime and basic blocks of native code are produced.
  \item Runtime optimizations are only performed when the linked LLVM assembly module is executed by a JIT compiler. The JIT compiler profiles the program during execution and it aggressively applies runtime optimizations on often executed code. Specialization is an optimization which is typically performed during runtime.
  \item In between runs of the application, there is an opportunity to optimize the program even more. During this idle time, the program is optimized with profiling information gathered from past runs. This technique optimizes the program for the behaviour that the actual user requests and not for expected behaviour. The profiling information is used to optimise the native executable in a similar way as the JIT engine does during runtime. In the current version of LLVM, version 2.3, the idle time optimizer is not available and thus this part of the strategy is not applicable when compiling.
\end{enumerate}

A crucial aspect of this strategy is the availability of the LLVM assembly language. During the whole life time of the program, the LLVM assembly language is available for optimizing.

With EHC, we generate static executables offline, so we optimize only during compile, link, and install time.

\section{LLVM assembly language}
\label{sec:llvm-assembly-language}

\subsection{Comparing LLVM assembly to native assembly}
Typed assembly languages abstract over machine properties to provide an architecture neutral assembly language. This is also the case for the LLVM assembly language, as it resembles a typical native assembly language enriched with some high level features. There are five differences between LLVM assembly and native assembly languages: the Reduced Instruction Set Computer (RISC) format, unlimited virtual registers, no stack management, typed values, overloaded operations, and static single assignment form. 
\begin{itemize}
  \item Registers in LLVM are virtual and infinite in amount and size. These virtual registers are mapped to one or more physical machine registers or memory when executable code is generated.
  \item The LLVM assembly language is in the RISC format. All parameters of operations are passed via registers. Operations do not perform memory access, but only operate on virtual registers. The separation of memory access and computations allows for easy generation of code for both RISC and Complex Instruction Set Computer (CISC) based architectures. An additional advantage of a RISC representation is that operations have simpler semantics, and thus the analysis and optimizations are simpler too.
  \item Stack management issues related to function parameter passing, automatic variables and alignment are abstracted over by the language. Calling functions in LLVM assembly is similar to function calling in C. By means of attributes one can control the calling convention and linkage properties of function calls. For example, tail calls are performed, when the programmer annotates the call with the keyword \texttt{tail} and the LLVM assembler can prove that the call is tail call eligible.
Stack allocation of automatic variables is available via a LLVM instruction that has similar form of C's \texttt{alloca()} function. These and other LLVM assembly language instructions are discussed in \refS{sec:llvm-as-lang-instructions}.
  \item All values and operations in the LLVM assembly language are typed in contrast to untyped values in native assembly. The type system consists of integers, floats, pointers, arrays, vectors, structures and the special void type. The integer and float types are parametrized with their size in bits which can be an arbitrary positive number. Types in LLVM are low level but powerful enough to represent types of high level languages. Apart from adding type safety to the LLVM language, the type system enables more aggressive optimizations.
  \item There are few operations in the language because most operations are overloaded. In native assembly language, the programmer has to select a different operation for addition of different operand types. The LLVM assembly compiler is able to infer the correct semantics for the instruction because all parameters are typed and there are no implicit type coercions in LLVM.
  \item A LLVM assembly program must be in static single assignment (SSA) form. Assignments to a virtual register are allowed exactly once in the program. The purpose of this requirement is to facilitate optimizations by not allowing aliases. 
\end{itemize}

Although the LLVM assembly language has high level features compared to native assembly, it still is very verbose. The language is designed for fast and flexible code generation, not for ease of writing and reading.

\subsection{Language structure}
\refF{fig:fib-ll} shows an example of a LLVM assembly module. The module, when compiled and executed, computes the $33^{th}$ fibonacci recursively. Semantically equal C code is shown in \refF{fig:fib-c} as a reference.
\begin{figure}[htbp]
  \subfigure[LLVM assembly implementation\label{fig:fib-ll}]{\lstinputlisting[style={figureLstFootnote}, language={LLVM}]{LLVMExample.ll}}
  \\
  \subfigure[C implementation\label{fig:fib-c}]{\lstinputlisting[style={figureLstFootnote}, language={[ANSI]C}]{LLVMExample.c}}
  \caption{Recursive Fibonacci function in C and LLVM Assembly}
 \label{fig:fib-c-ll}
\end{figure}

A LLVM module is divided in 4 parts: meta information, global variables, external function declarations and function definitions.
Meta information, if needed, is declared at the top of the module. Currently, information stored in the meta declarations defines the endiannes of the module and mappings between LLVM types and the physical machine registers. Such a mapping specifies the physical register size and alignment of a LLVM type. This information is needed for code generation and is only known during install time. This explains why the example in \refF{fig:fib-ll} has no meta information attached to it. 

The definitions of the global variables follow after the meta information. A global variable is a reference to statically allocated memory. Global variables are allowed to be flagged constant, making the data stored at the memory immutable; the value of the variable must then be provided together with the declaration. In order to distinguish global variables from virtual registers, global variables are prefixed with a \texttt{@@} symbol. A typical example of a global constant is the variable \texttt{str.res} in the example module. This variable stores a global constant string which is used as the first argument of \texttt{printf()}. Because \texttt{str.res} refers to a memory location, its type is a pointer to an array of 4 bytes, it must be loaded before it is used. The added keyword \texttt{internal} is a linkage modifier, which informs the linker that the variable is only used in the module itself.

The third section of a LLVM module is the declaration of external functions. All functions that are called from the module, but are not defined by the module itself, must be declared. A declaration begins with the keyword \texttt{declare} followed by the type signature of the external function. The example module shows the declaration of the standard C library function \texttt{printf()}. The function expects a pointer to a C null terminated string as first argument plus a variable amount of additional arguments and it returns a integer with the amount of characters printed. The variable amount of arguments makes it type correct to pass any number of arguments with any type to the function. LLVM function declarations are similar to C functions declared \texttt{extern}. The actual resolving of the function implementation address is done by the linker.

The section with function definitions form the actual body of the module. A function definition starts with a declaration of the parameter types and the return value. Additionally, one can specify a calling convention (for example, the C calling convention or the fast calling convention), linkage modifiers and several other attributes. The body of the function consists of a list of basic blocks. A basic block is a sequence of instructions and ends with a terminator instruction (\refS{sec:llvm-as-instr-term}). A basic block is optionally preceded by a label, allowing instructions to jump to the start of the block. 

The example module defines 2 functions, \texttt{fib} and \texttt{main}. The \texttt{fib} function receives a 32 bit integer as parameter and returns an integer of the same size. The fast calling convention (\texttt{fastcc}) results in passing the only parameter in a register. The \texttt{nounwind} annotation indicates the absence of exceptions. 

The body of \texttt{fib} consists of 4 basic blocks, one anonymous block, \texttt{nEq0}, \texttt{nEq1} and \texttt{default}. The anonymous block is only one instruction in size, the switch instruction, which transfers control to block \texttt{nEq0} if \texttt{n} equals 0, to \texttt{nEq1} if \texttt{n} equals 1 and to block \texttt{default} for any other value of \texttt{n}. Both \texttt{nEq0} and \texttt{nEq1} directly return the 32 bit integer 0 and 1 respectively. More interesting is the block \texttt{default}. In this example, 1 line of C expands to 6 LLVM instructions. Each sub-expression is stored in a virtual register and the addition of both \texttt{fib} calls is stored in virtual register \texttt{\%tmp5}, which is returned at the end of the block.

The body of the function \texttt{main} starts with a call to \texttt{fib}, followed by an indirect cast of the global string \texttt{str.res}. As stated before, the type of \texttt{str.res} is a pointer to an array of 4 bytes. The instruction \texttt{getelementptr} is used to navigate into arrays and structures via indexes (\refS{sec:llvm-as-instr-misc}). By selecting the $0^{th}$ position in the array twice, we obtain a pointer to the first element of the string. This pointer and the result of the call to \texttt{fib} are passed as parameters to \texttt{printf()}. This call is annotated as a tail call as there is no need to keep the stack frame of the \texttt{main} function.

\subsection{LLVM instructions}
\label{sec:llvm-as-lang-instructions}
In this section, we give an overview of a selection of LLVM assembly instructions. The overview is detailed enough to read and understand the generated LLVM assembly examples presented in this thesis, and is not meant to be a complete reference for the language. We partition LLVM instructions according to the following classification: terminator instructions, binary instructions, bitwise binary instructions, memory related instructions, conversion operations and miscellaneous instructions.

\subsubsection{Terminator instructions}
\label{sec:llvm-as-instr-term}
Terminator instructions transfer control flow from the one basic block to another.
\begin{itemize}
  \item \texttt{br}: perform a unconditional or conditional jump. 
  \item \texttt{ret}: return a value from a function.
  \item \texttt{switch}: branch to a label is the scrutinee is equal to the constant given to that label. If no given constants match the value of the scrutinee, a branch to a default label is taken.
  \item \texttt{unreachable}: has no runtime semantics, informs the optimizer that the code is unreachable.
\end{itemize}
 
\subsubsection{Binary instructions}
Binary operators compute a value from 2 other values. Both arguments must have the same type and the type of the result value is the same as the argument types. The binary operators defined in LLVM are mathematical operations: addition, subtraction, multiplication, quotient (signed and unsigned) and remainder (signed and unsigned).

\subsubsection{Bitwise binary instructions}
Bit manipulation is performed by the bitwise binary instructions. Just as binary instructions, the binary bitwise instructions expect 2 arguments with equal types. The produced result is from the same type. The available instructions are bitshifts to the left or the right and the bitwise logical operators and, or and xor.

\begin{figure}[htbp]
  \lstinputlisting[style={figureLstFootnote}, language={LLVM}]{GetElementPtrExample.ll}
  \caption{Selecting a sub-element of a structure via \texttt{getelementptr}}
 \label{fig:llvm-getelementptr}
\end{figure}

\subsubsection{Memory related instructions}
The operations in this section allocate, free, read and write values from memory.
\begin{itemize}
  \item \texttt{alloca}: allocate memory in the stack frame of the current executing function. The memory is automatically released when the stack frame is disposed of.
  \item \texttt{free}: free memory which was allocated from the heap.
  \item \texttt{getelementptr}: navigate through a memory by using a index in order to obtain the address of a sub-element. 

\refF{fig:llvm-getelementptr} illustrates the usage of \texttt{getelementptr}. \texttt{\%reg1} is a pointer to a structure which contains a byte, a 32 bit integer and a nested structure containing two booleans. The first index, 0, will select the structure with offset $0^{th}$ from the address stored in \texttt{reg1}. The second index, 2, selects the address of the nested structure. Finally, the last index, 1, returns the address of the second boolean in the nested structure.

The operation \texttt{getelementptr} performs only address computations and does not read from memory. To obtain the value of the selected address, one has to load the pointer explicitly.
  \item \texttt{load}: load a value from memory into a virtual register.
  \item \texttt{malloc}: allocate memory from the heap.
  \item \texttt{store}: store the content of a virtual register into memory.
\end{itemize}

\subsubsection{Conversion instructions}
Conversion instructions cast a value of one type to a given type. There are two in conversion flavours: bit changing conversions that change the bits of the value as well as its type, and bit neutral conversions that leave the bits untouched and only change the type. The bit changing conversions include actions as truncation and extension of types. The bit neutral conversions are discussed below.
\begin{itemize}
  \item \texttt{bitcast}: converts a value to a value of a different type leaving the bits of the value untouched. A \texttt{bitcast} is the only way to escape the LLVM type system and perform type unsafe operations.
  \item \texttt{inttoptr}: converts a integer to a pointer value. If the bit size of the integer and the pointer are not equal, the value is either truncated or zero extended.
  \item \texttt{ptrtoint}: converts a pointer to a integer value. This operation is the exact opposite of \texttt{inttoptr}.
\end{itemize}

When \texttt{inttoptr} and \texttt{ptrtoint} operations are used on integers which have an equal bit size as pointers have equal bit size, than no data is lost during conversion and both types are interchangeable.

\begin{figure}[htbp]
  \lstinputlisting[style={figureLstFootnote}, language={LLVM}]{PhiExample.ll}
  \caption{Example of the \texttt{phi} instruction, computing an absolute value}
 \label{fig:llvm-phi}
\end{figure}

\subsubsection{Miscellaneous instructions}
\label{sec:llvm-as-instr-misc}
Operations that do not fit in one of the above mentioned classifications are classified as miscellaneous instructions.
\begin{itemize}
  \item \texttt{call}: calls a function with the given parameters.
  \item \texttt{getresult}: extract individual elements from a \texttt{call} instruction that has multiple return values.
  \item \texttt{icmp}: compare two integer values and return a boolean, a 1 bit integer, indicating the result. The instruction is able to compare the arguments on equality, inequality, greater than and less than (both signed and unsigned). Often the result to the comparison is used as argument for a conditional branch. 
  \item\texttt{phi}: implements the $\phi$ node of the SSA graph notation, that is, evaluate to a value depending on the control flow. The result of \texttt{phi} depends on the predecessor of the current basic block. An example is shown in \refF{fig:llvm-phi}, in an implementation of a function that returns the absolute value of its parameter. First the parameter of the function is compared to zero. If the value is less than zero, the control flow transfers to the basic block labeled \texttt{true}. In this block, the parameter is multiplied by -1, making it a positive value. If the parameter was equal or greater than 0, the branch is taken to the block labeled \texttt{false}. Both basic blocks branch unconditionally to the label \texttt{return}. The value of the \texttt{phi} instruction depends on the previous basic block. If the previous basic block was the \texttt{true} block, then \texttt{phi} would return the multiplied value. Otherwise if the previous basic block was the \texttt{false} block, the instruction returns the original parameter.
\end{itemize}

\section{Summary}
The LLVM compiler infrastructure is an attractive target for EHC, as it provides various optimizations, supports many platforms and is actively maintained.

In this chapter we discussed the 2 key components of the infrastructure: the life long optimization strategy and the LLVM assembly language. 

The life long optimization strategy allows for optimization during the whole life time of the program. With EHC, we generate static executables offline, so we optimize only during compile, link, and install time.

The LLVM assembly languages abstracts over machine properties to provide an architecture neutral assembly language. The five differences most noticeable difference between LLVM assembly and native assembly are the RISC format, unlimited virtual registers, no stack management, typed values, overloaded operations, and static single assignment form. 
%%]
