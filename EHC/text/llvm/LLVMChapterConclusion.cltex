%%[chapter
\chapter{Conclusion}
\label{cha:conclusion}
In the introductory chapter of this thesis, we introduced the following research questions:
\begin{enumerate}
  \item \emph{What effect does a typed assembly language have on the design and implementation of a Haskell backend?}
  \item \emph{Does the code generated by a Haskell compiler benefit from the optimizations supported by the LLVM framework?}
\end{enumerate}

\subsubsection{Effect on the design}
We answered research question 1 by implementing a backend for EHC that outputs LLVM assembly. In \refC{cha:ehc} we showed the transformations performed in the EHC pipeline up until the LLVM assembly generation starting point. These transformations performed on the compilers' input, a Haskell program, determine the boundaries of the code that can be generated. We continued with an overview of the LLVM compiler infrastructure (\refC{cha:llvm}), showing its possibilities and restrictions. From this, we concluded that the LLVM compiler infrastructure is an attractive target for EHC, as it provides various optimizations, supports many platforms and is actively maintained. \refC{cha:implementation} discussed the implementation of the LLVM backend and compared it to the existing C backend. We concluded that there are 3 differences between the design of the LLVM backend and the C backend: typing, code generation and the runtime system.

In contrast to C, the LLVM language requires a type annotations at each operation and constant. This requires the LLVM backend to implement a full type inference algorithm to type each Silly statement in isolation, while for C it suffices to add casts in an ad hoc manner. We proposed lifting the LLVM type inferencing from the backend to the Silly level (\refS{sec:future-work-design}) to allow other backends to use the type information.

Unlike C, LLVM has no direct counterpart for each Silly construct on the same level. This means that one Silly statement expands to multiple LLVM statements, where the LLVM statements combined have the same semantics as the single Silly statement. In order to generate these statements, LLVM uses continuation variables during code generation. The continuation variables are easy to implemented with attribute grammar.

The LLVM backend uses the same runtime system library as the C backend, with one small adjustment. As the LLVM generated code is not aware of C macro's, it is not able to interface with the current garbage collector via its macro interface. Instead, a small C file, 17 lines including comments, defines wrapper functions for the garbage collector.

\subsubsection{Benefits from LLVM optimizations}
Research question 2 is answered in \refC{cha:results}, by comparing 4 properties of the generated code of the C and LLVM backend. The properties investigated were compilation time, file size, execution time, and runtime memory usage. Measurings show a positive answer on the second research question for the average program. Runtime memory usage improves marginally, while compilation time, file size, and execution time show significant improvements. The gain in execution time is explained by register usage for function calls and loops, instead of the in-memory stack used by the C backend. Also the structure of the C program makes it impossible for the compiler to construct a control flow graph and reduces the options for optimization. Compilation via LLVM is not always faster. The x86-64 backend of LLVM is not as mature as the GCC version, but is a likely target for improvement in future versions.

A large part of the execution time is consumed by the garbage collector. When garbage collection is disabled and data is not deallocated, the execution time improves significantly. Thus a big improvement in execution speed is possible if the inefficient conservative garbage collector is replaced by an fast accurate garbage collector. Further improvement is possible with the alternative return strategy and LLVM version of the runtime system presented in \refC{cha:future-work}, that could reduce the execution time even more.

\subsubsection{Final remark}
We feel that targeting a typed assembly language, in particular LLVM assembly, is a serious option for compiler builders. LLVM is especially attractive when C is too high level and more control is needed. For EHC, the generation of LLVM assembly had only minor impact on the design of the compiler compared with the generation of C code and improved the compilation time, file size, execution time and runtime memory consumption of the generated code.
%%]