\chapter{Exceptions}
\label{exceptions}

Exceptions fall into two categories: \emph{synchrone} and \emph{asynchrone}
exceptions. Synchrone exceptions consist of failures of computations or actions
of the program. Examples are division by zero, indices which are out of the
bounds of an array, or accessing unreadable files. Asynchrone exceptions, or
interrupts, are generated by external events. Examples of external events are
the Unix signals. These are signals which the operating system can send to a
program, for example when the user presses the control+C key combination. When
a program receives an Unix signal, it stops its current computation and handles
the recieved signal. When the signal is handled, the program might resume (or
restart) its computation.

This chapter adds support for handling of exceptions in GRIN. Although the
construct might prove useful for asynchrone exceptions only synchrone
exceptions are implemented here.


\section{Exception handling in Haskell}

A valid question is whether GRIN needs special exception handling support. To
answer that question we look at the exception support as modelled in Haskell.
In Haskell, a failure of a computations can be implemented in different ways.
For example, one might implement exceptions explicitly in a datatype:
\begin{code}
data Value a = OverFlowException | OK a

add3 x y z  =  case x + y of
                 OverFlowException  ->  OverFlowException
                 OK a               ->  a + z
\end{code}

The |add3| function test the result of the addition of |x| and |y|. When the
addition has failed, the exception is propagated to the caller of |add3|, if it
is successfull |z| is added to the result of the first addition. This is known
as the test-and-propagate method.

A big drawback of the test-and-propagate method is that every function result
must be tested explicitly on failures, which makes a program much harder to
read: even a simple addition of three values, as in the example above, becomes
obfuscated with a case expression. In some parts of Haskell, the
test-and-propagate code can be hidden inside a library. This is the case for
I/O computations, which are implemented in Haskell by using monads to force
sequential evaluation of I/O operations. For exceptions outside monads, like
the |add3| example above, the test-and-propagate method creates a bigger
problem than readability: the case statement fixes the evaluation order, which
takes away optimisation possibilities from the compiler.

The Haskell 98 standard \citep{haskell98} circumvents the problem of exceptions
outside monads by defining only exceptions in I/O computations. But an
extension of Haskell exists, called imprecise exceptions
\citep{peytonjones99semantics,marktoberdorf}, which introduces a semantics for
exceptions outside monads without fixing the evaluation order. With the
semantics of imprecise exceptions, the program does not explicitly propagate
exceptions.  For example, the |add3| function is defined in the program as:

\begin{code}
add3 x y z = x + y + z
\end{code}

The compiler must ensure that the overflow exception which might occur in the
addition of two values is passed to the exception handler. With the semantics
of imprecise exceptions the compiler is free to transform the |add3| function
defined in the program to the former definition of |add3| or to, for example,
the definition:

\begin{code}
add3 x y z  =  case y + z of
                 OverFlowException  ->  OverFlowException
                 OK a               ->  x + a
\end{code}

The programmer has no guarantees which exception has occured. The only guarantee
is that one of the exceptions which might be triggered by the expression is
passed to the exception handler.

The flow of the exception from location of occurence to the exception handler
can be implemented in the compiler by test-and-propagate. However, the
test-and-propagate method suffers from performance loss: each callsite between
the exception and the handler needs code to test-and-propagate, which makes the
program both bigger and slower. When a language contains constructs to jump
directly back to the exception handler no propagation is needed, and thus the
perfomance impact is non-existent. It is this jumping to the function in which
the exception handler is defined which needs special support in GRIN.


\section{Exception handling in GRIN}

Modern imperative languages define an exception handler with a statement in the
form of:

\begin{code}
try {
  guardedCode
} catch(e) {
  exceptionHandler
}
\end{code}

or something very similar. Code in the brackets after the |try| keyword are
guarded for exceptions. Excpetions thrown in this guarded code are passed to
the exception handler, which is defined by the code in the brackets after the
|catch| keyword. The exception passed to the exception handler is bound to the
variable defined in the |catch| keyword, in this example |e|.

If an exception occurs inside the guarded code, the control is passed to the
active exception handler. When try-catch statements are nested, the innermost
exception handler is active. Whenever the control leaves the guarded code of a
try-catch statement, the previous exception handler becomes active again.

\begin{Figure}{GRIN exception syntax}{syntax:exceptions}
\[
\begin{array}{lcll}
exp      & +\!\!= & \mathbf{try}\ exp\ \mathbf{catch}(var)\ exp                 & \mbox{catch exception} \\
\\
sexp     & +\!\!= & \mathbf{throw}\ val                                         & \mbox{throw exception}
\end{array}
\]
\end{Figure}

This model of exception handling is enough to encode exceptions in Haskell,
including the imprecise exceptions extension. We adopt this exception handling
model in GRIN. The syntax for the new statements is shown in Figure
\ref{syntax:exceptions}.

\section{Compiling to GRIN}
\label{exceptions:compiling2grin}

First, let we look at a small example of exceptions in Haskell with the
imprecise exceptions extension:

\begin{code}
thr x = throw x
main = catch  (thr DivByZero + thr OutOfBounds)
              (\e -> 1)
\end{code}

This program performs the addition of two expression which both raise an
exception. When an exception is thrown the exception handler is executed. But
which of the two exceptions is thrown is decided by the compiler.

The front-end compiler can express this example in GRIN as follows:

\begin{code}
add a b  =  {  eval a; \(#CInt a') ->
               eval b; \(#CInt b') ->
               ffi primAddInt a' b'; \(#U c') ->
               unit (#CInt c')
            }

thr   x  =  {  throw x
	    }

main     =  {  try {
                 store (#CDivByZero); \e1 ->
                 store (#COutOfBounds); \e2 ->
                 store (#Fthr e1); \f1 ->
                 store (#Fthr e2); \f2 ->
                 add f1 f2;
               } catch(e) {
                 unit (#CInt 1)
               }; \r -> 
               unit r
            }
\end{code}

This example shows some design choices for mapping Haskell exceptions to GRIN.
To summarize:

\begin{itemize}

\item A pointer to the exception is thrown, rather than the node itself;

\item The catch statement is not the last statement of a function body.

\end{itemize}

The first item is discussed in Section \ref{share_exceptions}. The last item
simplifies the code generator. The code generator must emit different code for
the last statement of a function body: the result of the last statement is used
as the return value of a function. However, if the last statement is a |catch|
statement, the previous exception handler must be restored before returning
from a function. This means that the code generator must emit code to temporary
hold the result while restoring the previous exception handler. When the
|catch| statement happens to be the last statement we append a unit statement
after it. 


\subsection{Sharing of exceptions}
\label{share_exceptions}

Functions in Haskell are free of side effects. This fact is used to share the
result of common computations. To accomplish this, a thunk is overwritten by
its result when it is evaluated. Exceptions can also be shared: when the
evaluation of a thunk throws an exception, it always throws the same
exception.\footnote{This is \emph{not} the case with asynchrone exceptions.
They are outside influences.} In many cases it will be more efficient to throw
the exception as soon as the thunk is evaluated, instead of evaluating the
thunk again.

To implement sharing of exceptions, the |eval| function must be modified. An
|Fthrow|-node is used to represent a suspended throw statement. When this node
is passed to |eval| the exception represented by the |Fthrow|-node is thrown.
Furthermore, each F-node under evaluation must be updated in the case of an
exception. This is done by installing an exception handler which updates the
F-node and re-throws the exception. An example of the new |eval| function is
given in Figure \ref{eval_with_exceptions}.

\begin{Figure}{Eval with exception sharing}{eval_with_exceptions}
\begin{code}
eval p  =  {  fetch p; \n ->
              case n of
                {  (Fadd a b)   ->  {  try {
                                            add a b; \r ->
                                            update p r; \() ->
                                            unit r
                                       } catch(e) {
                                            update p (Fthrow e)  ; \() ->
                                            throw e
                                       }; \x ->
                                       unit x
                                    }
                ;  (Fthrow e)   ->  { throw e
                                    }
                ...
                }
            }
\end{code}
\end{Figure}

The |update| statement in the exception handlers of |eval| (as shown in Figure
\ref{eval_with_exceptions}) updates the thunk with a |Fthrow|-node. The field
of this node is the variable defined in the |catch| statement. Since a node
cannot contain another node, only a pointer to another node, the variable
defined in the |catch| statement must be a pointer. As a result of this,
|throw| statements must throw a pointer to an exception node rather than the
exception node itself.


\subsection{Implementation details}

Any exception not caught by the GRIN program is caught by the startup code,
which displays a non informative message. In the future, this code might be
added to the GRIN program as a new main, which enables the default exception
handler to do more than just print ``an error has occured.''

The current version of EH and the implementation of EHC have no notion of
exceptions. To use the exception constructs in EH, we define the throw and
catch functions as foreign functions. These foreign functions are transformed
by the GRIN compiler into the try-catch and throw statements.


\section{Semantics}

%{
%format env''
%format empty = "\emptyset"

To express the semantics of exceptions the semantic function for expressions
(|EXP|) is modified as shown in Figure \ref{semantics:exceptions}. The function
takes an extra argument, the \emph{mode argument}, and returns an extra value,
the \emph{mode value}. The mode argument and value are usually the empty set
(|empty|). This is called the \emph{normal mode} of the semantic function.
When an exception is thrown, the function enters \emph{exception mode} and the
mode argument and value hold a pointer to the exception which is thrown.

In normal mode the semantic function is as previously defined in Section
\ref{semantics} with the addition of the mode argument and value. The mode
argument is returned as the mode result without changing its value. In
exception mode the semantic function is the identity function (first rule of
Figure \ref{semantics:exceptions}). The |throw| statement switches from normal
mode to exception mode. Its mode return value is the pointer to the exception.
When the body of the |catch| statement returns in exception mode, the pointer
to the exception is bound to the argument of the exception handler after which
the semantic function (in normal mode) is applied to the exception handler.


\begin{Figure}{GRIN Exceptions Semantics}{semantics:exceptions}
\emph{Semantic function:}
\begin{code}
EXP :: exp -> Env -> Store -> Mode -> (Value, Store, Mode)
\end{code}

\medskip
\emph{Semantic domain:}
\begin{code}
Mode = Loc | empty
\end{code}

\medskip
\emph{Additional expression semantics:}
\begin{code}
EXP  [  m        ] env heap l      =  (env, heap, l)

EXP  [  throw e  ] env heap empty  =  let l = VAL [e] env 
                                      in (env, heap, l)

EXP  [  try       {  m  } 
        catch(e)  {  k  } 
     ] env heap empty              =  let  (env',    heap',   z)   =  EXP [ m ] env heap empty
                                           env''                   =  env' [ e |-> z ]
                                      in  if z == bot
                                          then (env', heap', z)
                                          else EXP [ k ] env'' heap' empty
\end{code}
\end{Figure}
%}


\section{HPT Analysis}

\newcommand{\exceptions}{\ensuremath{\mathcal{X}}}
\newcommand{\grThrow}[1]{\ensuremath{\mathtt{throw}\ #1}}
\newcommand{\grCatch}[3]{\ensuremath{\mathtt{try}\ \{#1\}\ \mathtt{catch}(#2)\ \{#3\}}}

The HPT is modified. It must analyze the flow of exceptions, and the variable
bound by the catch statement, called the \emph{catch variable}, needs an
environment equation. This catch variable holds all pointers to exceptions
which might be thrown by the statements inside the scope of catch. The equation
of the catch variable is a join of all pointers which are thrown as exceptions
in the scope of the exception handler. To collect all variables which hold
pointers to exceptions the expression derivation rules are extended with an
exceptions set (\exceptions). The domain of exceptions set ranges over
variables. The type of the expression derivation rules (expr) are changed. The
expr type includes the exceptions set as its result:

\begin{center}
\begin{tabular}{l||l||l}
\bf type & \bf context & \bf results \\
\hline
expr    & \resultVars, p        & \env, \heap, \actuals, \exceptions
\end{tabular}
\end{center}

Figure \ref{hpt:exceptions} shows the changes in the derivation rules of HPT.
Note that the application of the rules can result in more than one instance of
an exception set, each with its own scope. This is different than the other
sets used by the derivation rules, for which only one instance exists. A new
exception set is created by two rules. The {\sc Bind} rule introduces a new
exception set to its body. The {\sc Catch} rule creates an exception set to
record all variables which hold the exceptions thrown in the guarded statements.

The |throw| statement adds its argument to the exceptions set. The catch
statement adds an environment equation: it binds the catch variable to the join
of all the variables in the exception set of the body of the |catch| statement.

Exceptions which pass the bounds of functions are collected in the same way as
function results. For each function an \emph{exception result variable} is
introduced. All exceptions thrown but not catched in a single function are
stored in the exception result variable as shown in the {\sc bind} rule in
figure \ref{hpt:exceptions}. A function call adds the exception result variable
to the exception set so that the exceptions passed by a function are joined by
the equation of the catch variable.

\begin{Figure}{Deriving equations for exception support}{hpt:exceptions}
\[ 
\mbox{\sc{Throw}}:
{
\hptAV{l} \in \exceptions
\over
\resultVars, () \follows{expr} \code{ \grThrow{l} }: \env, \heap, \actuals, \exceptions
}
\]

\[
\mbox{\sc{Call}}:
{
foo_{exceptions} \in \exceptions
\over
\dots \follows{expr} \code{ foo\ x_1\ \dots\ x_n }: \dots, \exceptions
}
\]

\[
\mbox{\sc{Bind}}:
{
\begin{array}{l}
foo_{exceptions} = \bigjoin \exceptions \in \env \\
\resultVars, foo \follows{expr} \code{ e }: \env, \heap, \actuals, \exceptions; \\
\dots
\end{array}
\over
\dots \follows{bind} \code{ foo\ a_1\ \dots\ a_n = e }: \dots
}
\]

\[ 
\mbox{\sc{Catch}}:
{
\begin{array}[t]{l}
\resultVars, p \follows{expr} \code{ b }: \env, \heap, \actuals, \exceptions' \\
l = \bigjoin \exceptions' \in \env \\
\resultVars, p \follows{expr} \code{ h }: \env, \heap, \actuals, \exceptions
\end{array}
\over
\resultVars, p \follows{expr} \code{ \grCatch{b}{l}{h} }: \env, \heap, \actuals, \exceptions
}
\]
\end{Figure}
