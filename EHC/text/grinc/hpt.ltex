\chapter{Heap points-to analysis}
\label{hpt}

%format BAS   = "\{B\}"
%format P (x) = "\mathcal{P}(" x ")"
%format N     = "\mathbb{N}"
%format y1
%format y2


%%%%%%%%%%%%%%%%% flow %%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Introduction}
%
%Data flow in grin is control flow in the original language. Heap points to analysis.
%
%\begin{itemize}
%	\item example result
%	\item flow insensitive
%	\item usages of the result
%\end{itemize}
%
%\section{Deriving equations}
%
%\begin{itemize}
%	\item preparing grin for the analysis
%	\item types of equations
%	\item flow insensitive
%	\item higher order functions
%\end{itemize}
%
%\section{Solving equations}
%
%Note: this is a rather small section... might put is somewhere else?
%\begin{itemize}
%	\item fixpoint computation
%\end{itemize}
%
%\section{Possible improvements}
%
%\begin{itemize}
%	\item dependency generation
%	\item sharing analysis
%	\item making lazy apply calls call sensitive
%\end{itemize}
%

\newcommand{\grSeq}[1]{\ensuremath{; \lambda #1 \rightarrow}}
\newcommand{\grEval}[1]{\ensuremath{\mathtt{eval}\ #1}}
\newcommand{\grApply}[2]{\ensuremath{\mathtt{apply}\ #1\ #2_1\ \dots #2_n}}
\newcommand{\grUnit}[1]{\ensuremath{\mathtt{unit}\ #1}}
\newcommand{\grStore}[2][]{\ensuremath{\mathtt{store}_{#1}\ #2}}
\newcommand{\grFFI}[1]{\ensuremath{\mathtt{prim}\ #1}}
\newcommand{\grNode}[3][]{\ensuremath{(\grTag{#2_{#1}}\ #3_{#11_{#1}}\ \dots\ #3_{#1n_{#1}})}}
\newcommand{\grTag}[1]{\ensuremath{\mathrm{#1}}}

\newcommand{\grSelect}[3]{\ensuremath{#1 \downarrow \grTag{#2} \downarrow #3}}
\newcommand{\join}[0]{\ensuremath{\sqcup}}
\newcommand{\bigjoin}[0]{\ensuremath{\bigsqcup}}


\newcommand{\Bigskip}{\hspace*{\bigskipamount}}
\newcommand{\Ldb}{\ensuremath{\left[\!\!\left[}}
\newcommand{\Rdb}{\ensuremath{\right]\!\!\right]}}
\newcommand{\ldb}{\ensuremath{[\![}}
\newcommand{\rdb}{\ensuremath{]\!]}}
\newcommand{\actuals}  {\ensuremath{\mathcal{A}}}
\newcommand{\env}{\ensuremath{\mathcal{E}}}
\newcommand{\heap}{\ensuremath{\mathcal{H}}}
\newcommand{\resultVars}{\ensuremath{\mathcal{R}}}

\newcommand{\code}[1]{\ensuremath{\ldb #1 \rdb}}
\newcommand{\Code}[1]{\ensuremath{\Ldb #1 \Rdb}}
\newcommand{\follows}[1]{\ensuremath{\!\!\begin{array}[b]{c}\vspace{-0.3em}\mbox{\tiny #1}\\\vdash\end{array}}\!\!}

\newcommand{\avBAS}{\ensuremath{\{B\}}}
\newcommand{\avTag}[1]{|#|#1}
\newcommand{\avNode}[3][]{\ensuremath{\avTag{#2_{#1}}[#3_{#11} \dots #3_{#1n}]}}
\newcommand{\avSet}[1]{\ensuremath{\{#1\}}}

\newcommand{\hptSelect}[3]{\ensuremath{#1 \downarrow \avTag{#2} \downarrow #3}}
\newcommand{\hptJoin}[1]{\ensuremath{\bigsqcup\{#1\}}}
\newcommand{\hptEval}[1]{\ensuremath{\mathtt{eval}\ #1}}
\newcommand{\hptApply}[2]{\ensuremath{\mathtt{apply}\ #1\ #2_{1}\ \dots #2_{n}}}
\newcommand{\hptAV}[1]{\ensuremath{\mathtt{av}(#1)}}


The Heap Points-To analysis (abbreviated by HPT) is an important analysis
performed on GRIN programs. It is used by many transformations, both for
simplification and for optimisation (See Chapter \ref{transformations}).

HPT is an abstract interpretation of a program. The result of the HPT is a
pessimistic approximation of the contents of the variables and the heap. Thus,
the absence of a value in a variable or heap location in the approximation is
proof of the absence of the value in that particular variable or heap location
in a run of the program.

This chapter describes the implementation of HPT. We discuss the implementation
in a top-down way: we first show the results before explaining how to get these
results. But first we start by an overview of the design of HPT.

\section{Overview and design}
\label{hpt:overview}

The result of HPT is a set of abstract values; one for each variable and one
for each store statement. An abstract value is an estimation of the possible
GRIN values bound to a variable or stored in a memory location. Abstract values
can be a set of pointers to abstract memory locations, or a set of abstract
nodes with as fields sets of pointers. An example of an abstract node is
|#CTuple[{1,2}, {3,4}]|. An abstract pointer value is |{1,2}|, which represents
a pointer to the first or second store location. The abstract value |{1,2}|
tells us that the variable bound to this value will, in a run of the program,
hold a pointer to a location returned by the first or second store statement;
never any other location.

The values derived by HPT are used by optimisations, in particular for the
elimination of unreachable case alternatives. A good example is the |eval|
function. The |eval| function contains a case statement listing all tags used
in the program. But at every call site the pointers passed to |eval| reference
only to a few of all those tags. An important transformation is the
specialisation of this |eval| function for each call site at which the function
is inlined. The result of HPT is used to prove the absence of a tag for the
current call site, which makes it safe to remove the corresponding alternative
from the case statement of |eval|.

To estimate the heap contents HPT analyses the complete program, which makes it
hard to keep the runtime of the compiler within reasonable limits. The design
of HPT shown in this chapter ignores any form of control flow. The estimates
made by HPT are worse this way, but HPT is more scaleble and is guaranteed to
terminate as described by Urban Boquist \citep{boquist96grin}.

The design of HPT is as follows:

\begin{itemize}

\item Each store statement is represented by exactly one location in an
abstract heap. This location hold all the possibly nodes stored by that
statement.

\item Actual arguments of function calls are joined and used as the
value of the corresponding formal arguments. For example: the function |foo a b
= ...| is called twice: |foo x1 y1| and |foo x2 y2|.  In HPT, the formal
argument |a| will be bound to the values of the actuals |x1| and |x2|. The formal
argument |b| will be bound to the values of |y1| and |y2|.

\item Abstract nodes with the same tag but with different fields are joined
field by field. As an example take two abstract nodes |#CTuple[{1}, {3}]| and
|#CTuple[{2}, {4}]|. These joined form the abstract node |#CTuple[{1,
2}, {3, 4}]|.

\item Any basic value is represented as one single value, |BAS|. An empty value
is represented by |bot|.

\end{itemize}

The HPT results are calulated in two steps: a set of equations is derived from
a GRIN program which are then solved by a \emph{fixpoint computation}. A fixpoint
computation is a common technique to solve a set of (mutual dependent)
equations; an excelent introduction is given in ``The Priciples of Program
Analysis'' \citep{ppa99}.

\section{Analysis result}
\label{hpt:result}

Figure \ref{hpt:domain_av} gives the domains of the abstract heap and
environment. We keep the notation close to the GRIN syntax. However, HPT and
GRIN differ in the notation of nodes. An abstract node, as used by HPT, is of
the form |#Tag[field1, ..., fieldn]| while the syntax of nodes in GRIN is
|(#Tag field1 ... fieldn)|. The difference between the abstract node and the
GRIN node lies in the domains used for their fields. The separation of notation
is necessary for the explanation of the transformations (Chapter
\ref{transformations}) which uses GRIN syntax and HPT results together.

The HPT result of the GRIN program in Figure \ref{haskell2grin} on page
\pageref{haskell2grin} is represented in Figure \ref{hpt:example_result}. We
suggest to keep both figures at hand while reading the rest of this section.

Variables which bind the result of a store statement, which includes the global
variables, are bound to a singleton set in HPT. This singleton set contains a
pointer to the abstract location of a store statement. Because each store
statement gets only one abstract location in HPT, the variables which bind the
result of a store statement are always a singleton set, of which the element
refers to a heap location.

Variables which bind the result of an |eval| call hold the union of all heap
locations passed to |eval|, but with the F-nodes filtered out. For example, the
|t| variable, which can be a pointer to the abstract location |4|, is passed to
|eval|. The result of the |eval| call, which is saved in |tn|, is equal to the
nodes storable in location |4| minus the F-nodes.

The formal arguments contain the union of corresponding actual arguments of
each function call and thunk. In this example each function is only called
once, thus the values of the formal arguments match the values of the actual
arguments. 

Some variables in the HPT result example do not occur as variables in the
program. These variables are \emph{meta variables} and are needed to perform
the analysis. There are two classes of meta variables:

\begin{itemize}

\item \emph{result variables}, which represent return values of functions with
the same name. For example, the |mk| variable holds the resulting nodes of the
|mk| function;

\item the \emph{apply variable}, which represent all applied arguments to
partial applications. This variable is named |apply|. Its use is explained in
Section \ref{hpt:apply_var}.

\end{itemize}

The analysis of functions is call insensitive. This means that the results
yielded by calls to the same function are jointly represented as a single
abstract value. Such a value is bound to a result variable. By convention, a
result variable has the same name as its corresponding function. Variables
which bind the result of a function call can use the corresponding result
variable to retrieve the result of the function call.


\subsection{First class functions}
\label{hpt:apply_var}

Haskell allows partially applied functions to be passed as arguments whereas
GRIN only allows pointers to nodes to be passed. Partial applied Haskell
functions are translated to partial application nodes (P-nodes). Applications
to partially applied functions are translated to calls of the function |apply|
(see Section \ref{compile_to_grin}).

As a consequence of the call insensitivity of HPT, HPT estimates the value of a
formal argument to be the union of all its corresponding actual arguments. This
enforces that all function calls to the same function result in the same
estimate. This method works because we statically know which arguments are
passed to which functions.  However, the existence of partial applications
breaks this method because it is no longer statically known which functions are
called. For example:

\smallskip\noindent
\begin{code}
Tuple x y  =  unit   (#CTuple x y)

main       =  store  (#CInt  1  )  ;  \a ->
              store  (#CInt  2  )  ;  \b ->
              unit   (#P2Tuple  )  ;  \p ->
              apply p a            ;  \g ->
              apply g b            ;  \r ->
              unit r

applymap:
{ #P2Tuple -> #P1Tuple
; #P1Tuple -> Tuple
}
\end{code}

The above code stores two integer nodes on the heap after which the partially
applied function |Tuple| is applied to the two integers. The function |Tuple| returns
a tuple containing its arguments. In HPT, the first store statement stores its
node in the abstract location |1|, the second store statement uses the abstract
location |2|. Thus the variables |a| and |b| are bound to the abstract values
|{1}| and |{2}| while these locations both hold the abstract nodes
|#CInt[BAS]|. The |p| variable is bound to the abstract node |#P2Tuple[]|,
which represent a partial application to the |Tuple| function missing two
arguments.

HPT bounds the formal arguments of |Tuple|, |x| and |y|, to a union of all
corresponding actual arguments. As HPT without support for partial applications
cannot find any function call or thunk to |Tuple|, it will falsely conclude that
no actuals of |Tuple| are available. Thus without support for partial
applications HPT estimates the result of the function |Tuple| to be
|#CTuple[bot, bot]|, while this should be the value |#CTuple[{1}, {2}]|.

To support partial applications, HPT uses the applymap. The applymap encodes
the flow of control between partial applications nodes and GRIN functions.
Hence HPT can estimate which arguments are passed to which functions via
|apply| and records this in the |apply| meta variable. This enables the HPT to
be call insensitive, even in the presence of partial applications. 

In the above example, the first apply statement, |apply p a|, takes the partial
application node |#P2Tuple[]| and applies it to the value |{1}|. The applymap
encodes that such a call results in a |#P1Tuple[{1}]| node. This value will be
bound to the variable |g|. The second call to apply is the statement |apply g
b|. This statement applies the node |#P1Tuple[{1}]| to the value |{2}|. The
applymap encodes that such a statement results in a function call to |Tuple|,
with the arguments |{1}| and |{2}|. This time, not only is the result of the
apply call bound to |r|, but the node |FTuple[{1}, {2}]| is also added to the
apply variable. This F-node has the same name as the function called by the
apply statement and the fields of the node contain the actual arguments of that
function. Thus, the apply variable records the names of the functions called by
the apply statement in an F-node, as well as all the arguments passed to these
functions in the fields of the F-node.

Equations of formal arguments use the apply variable to find the actual
arguments applied via |apply|. The first formal argument selects the first
field of the corresponding F-node from the apply variable, the second formal
arguments selects the second field, and so on. Thus, the equation of formal
argument |x| of |Tuple| selects from the apply variable the first field of
|FTuple|, the equation of |y| selects the second field. With the use of the
apply variable, HPT does record a value for each formal argument and estimates
the result of |Tuple| correctly to be |#CTuple[{1}, {2}]|.

\begin{Figure}{Domain of the abstract values}{hpt:domain_av}
\begin{code}
AbstractHeap         =  Location  ->  P(AbstractNode)
AbstractEnvironment  =  Variable  ->  P(AbstractValue)

AbstractValue        =  AbstractNode | AbstractBasicValue
AbstractBasicValue   =  P(Location) | BAS
AbstractNode         =  Tag[ P(AbstractBasicValue) ]

Location             = N
Variable             = String
Tag                  = #String
\end{code}
\end{Figure}

\begin{Figure}{Example abstract environment and heap}{hpt:example_result}
\center
\begin{tabular}{lrcl}
\multicolumn{4}{l}{\bf environment:}\\
                        &$ \ident{main}\_caf    $&$ \mapsto $&$  \{0\}                              $ \\
                        &$ \ident{x}_2          $&$ \mapsto $&$  \{3\}                              $ \\
                        &$ \ident{x}_1          $&$ \mapsto $&$  \{1\}                              $ \\
                        &$ \ident{t}            $&$ \mapsto $&$  \{4\}                              $ \\
                        &$ \ident{tn}           $&$ \mapsto $&$  \{\avTag{CTuple}[\{1\},\{3\}]\}    $ \\
                        &$ \ident{b}            $&$ \mapsto $&$  \{3\}                              $ \\
                        &$ \ident{a}            $&$ \mapsto $&$  \{1\}                              $ \\
                        &$ \ident{x}_3          $&$ \mapsto $&$  \{3\}                              $ \\
                        &$ \ident{f}            $&$ \mapsto $&$  \{2\}                              $ \\
                        &$ \ident{fn}           $&$ \mapsto $&$  \{\avTag{P1Tuple}[\{1\}]\}         $ \\
                        &$ \ident{s}_1          $&$ \mapsto $&$  \{1\}                              $ \\
                        &$ \ident{s}_2          $&$ \mapsto $&$  \{2\}                              $ \\
                        &$ \ident{s}_3          $&$ \mapsto $&$  \{3\}                              $ \\
                        &$ \ident{s}_4          $&$ \mapsto $&$  \{4\}                              $ \\
\mbox{result variables} &$ \ident{Tuple}        $&$ \mapsto $&$  \{\avTag{CTuple}[\{1\},\{3\}]\}    $ \\
                        &$ \ident{snd}          $&$ \mapsto $&$  \{\avTag{CInt}[\avBAS]\}           $ \\
                        &$ \ident{mk}           $&$ \mapsto $&$  \{\avTag{CTuple}[\{1\},\{3\}]\}    $ \\
                        &$ \ident{main}         $&$ \mapsto $&$  \{\avTag{CInt}[\avBAS]\}           $ \\
\mbox{apply variable}   &$ \ident{apply}        $&$ \mapsto $&$  \{\avTag{FTuple}[\{1\},\{3\}]\}    $ \\
\\
\multicolumn{4}{l}{\bf heap:}\\
  &$0  $&$ \mapsto $&$  \{\avTag{CInt}[\avBAS], \avTag{Fmain}[]\}                 $ \\
  &$1  $&$ \mapsto $&$  \{\avTag{CInt}[\avBAS]\}                                  $ \\
  &$2  $&$ \mapsto $&$  \{\avTag{P1Tuple}[\{1\}]\}                                $ \\
  &$3  $&$ \mapsto $&$  \{\avTag{CInt}[\avBAS]\}                                  $ \\
  &$4  $&$ \mapsto $&$  \{\avTag{CTuple}[\{1\},\{3\}], \avTag{Fmk}[\{2\},\{3\}]\} $
\end{tabular}
\end{Figure}


\section{Equations}

\begin{Figure}{Example equations}{example_equations}
\noindent\textbf{identifier equations (\env):}
\begin{eqnarray*}
main\_caf      & = &  \{0\}                                              \\
x_1            & = &  \bigjoin \{\} \join \hptSelect{apply}{FTuple}{1}   \\
x_2            & = &  \bigjoin \{\} \join \hptSelect{apply}{FTuple}{2}   \\
t              & = &  \bigjoin \{s_4\} \join \hptSelect{apply}{Fsnd}{1}  \\
tn             & = &  \hptEval{t}                                        \\
a              & = &  \hptSelect{tn}{CTuple}{1}                          \\
b              & = &  \hptSelect{tn}{CTuple}{2}                          \\
f              & = &  \bigjoin \{s_2\} \join \hptSelect{apply}{Fmk}{1}   \\
x_3            & = &  \bigjoin \{s_3\} \join \hptSelect{apply}{Fmk}{2}   \\
fn             & = &  \hptEval{f}                                        \\
s_1            & = &  \{1\}                                              \\
s_2            & = &  \{2\}                                              \\
s_3            & = &  \{3\}                                              \\
s_4            & = &  \{4\}                                              \\
alt1           & = &  \hptEval{b}
\\
Tuple          & = &  \avTag{CTuple}[x_1, x_2]                           \\
snd            & = &  \bigjoin \{alt1\}                                  \\
mk             & = &  \mathtt{apply}\ fn\ x_3                            \\
main           & = &  snd                                                \\
apply          & = &  \bot                                               \\
\end{eqnarray*}
\noindent\textbf{heap equations (\heap):}
\begin{eqnarray*}
0  & = &  \avTag{Fmain}[]      \join main \\
1  & = &  \avTag{CInt}[\avBAS] \join \bot \\
2  & = &  \avTag{P1tuple}[s1]  \join \bot \\
3  & = &  \avTag{CInt}[\avBAS] \join \bot \\
4  & = &  \avTag{Fmk}[s2, s3]  \join mk   \\
\end{eqnarray*}
\end{Figure}

HPT computes the approximation by deriving a set of equations from a GRIN
program. These equations can either be a combination of join functions ($x
\join y$) and select functions ($\hptSelect{v}{T}{i}$), the eval funtion, or
the apply function. Equations derived from the running example are shown in
Figure \ref{example_equations}. The eval and apply function are explained in
Section \ref{functioncalls}. The join and select functions are shown in Figure
\ref{equations:functions}. 

\begin{Figure}{Utility functions}{equations:functions}
\begin{eqnarray*}
\hptSelect{\{\dots \avNode{T}{x} \dots \}}{T}{i} & = & x_i    \quad \mbox{when $1 \le i \le n$} \\
\hptSelect{\{\dots \avNode{T}{x} \dots \}}{T}{i} & = & \bot\, \quad \mbox{otherwise}            \\
\hptSelect{\{\dots \avNode{T}{x} \dots \}}{S}{i} & = & \bot                                     \\
\\
\{\dots \avNode{T}{x} \dots \}  \join \{\dots \avNode{S}{y} \dots \} & = & \{ \dots \avNode{T}{x}, \avNode{S}{y} \dots \} \\
\{\dots \avNode{T}{x} \dots \}  \join \{\dots \avNode{T}{y} \dots \} & = & \{ \dots \avTag{T}[x_1 \cup y_1 \dots x_n \cup y_n] \dots \}       \\
x \join \bot                                                         & = & x                                              \\
x \join y                                                            & = & x \cup y
\\
\hptAV{\grNode{T}{x}} & = & \hptAV{T}[\hptAV{x_1} \dots \hptAV{x_n}] \\ 
\hptAV{var}           & = & var                                      \\ 
\hptAV{Tag}           & = & Tag                                      \\
\hptAV{literal}       & = & \avBAS                                  %\\
\end{eqnarray*}
\begin{center}
|#T| and |#S| represent different tags.
\end{center}
\end{Figure}

The select function (\hptSelect{v}{T}{i}) is used to access a field from an
abstract node value.  It selects field |i| from a node with the tag |#T| from
the variable |v|. The select function is the abstract equivalent of a pattern in
GRIN. In the example, the variable bindings in the case alternative result in
select equations with the scrutinizer as the variable to select from. Another
place where the select function is used is the equation of formals. In
equations for formal arguments ($x_1$ in the example) the corresponding actual
arguments to partial applications are selected from the apply variable and
joined with all statically known arguments.

The join function (\join{}) merges abstract values; nodes are joined based on
their tags, so that a tag occurs at most once in an abstract value. For
example:
\[
\{ \avNode{CA}{a}, \avNode{CB}{b} \} \join \{ \avNode{CA}{c} \}
\] 
results in $\{ \avNode{CA}{z}, \avNode{CB}{b} \}$, where $z_i = a_i \join c_i$.
The value $\bot$ serves as the identity value: $\bot$ merged with some value
$a$ will result in $a$. To merge locations or tags, the union is taken. The
merge function is only defined for arguments which are of the same kind. E.g.,
it is impossible to merge locations and nodes. The join function is, for
example, used to join the results of different case alternatives. It is also
used to join the the abstract values of actuals in the equations of formals.

Figure \ref{equations:functions} shows also the utility function \hptAV{e}
which is used to derive equations. This function maps a value expression in
GRIN to an abstract value. It is the identity function, except for literals.
Literals are all mapped to the abstract value $\avBAS$.

\subsection{Derivation rules}

This section describes the derivation of the equations from a GRIN program.
Boquists Ph.D. thesis \citep{boquist99phd} ignores this process and shows
only the results of HPT; one of his earlier papers \citep{boquist96grin}
describes the derivation process only informally. This lack of description is
our motivation for a more formal approach.

The derivation of the equations are described by a set of derivation rules.
These rules are of the following form:

\[
\mbox{\sc{Rule name}}:
{
\begin{array}{l}
prerequisite_1 \\
\dots \\
prerequisite_n \\
\end{array}
\over
consequence
}
\]

This means that if all $prerequisite_i$ are proven, the $consequence$ can be
concluded. To save some space, small prerequisites are placed side by side,
separated by semicolons ($;$). The prerequisites and consequence are structured
in the form of judgements. These judgements have the following form:

\[
context \follows{judgement type} \code{code}: results
\]

The values passed as context and the values returned as results can be the
following:

\begin{center}
\begin{tabular}{l||l||l}
\bf symbol    & \bf domain                                          & \bf represents                       \\
\hline
\env          & $\{\ident{Variable} \rightarrow \ident{Equation}\}$ & identifier equations                 \\
\heap         & $\{\ident{Location} \rightarrow \ident{Equation}\}$ & heap equations                       \\
\actuals      & $\{ f \mapsto a_1 \dots a_n \}$                     & actual function arguments            \\
\resultVars   & $\{ Tag \mapsto v \}$                               & result variables                     \\
v             & $\ident{Variable}$                                                   & a variable          \\
\grNode{T}{a} & $(\ident{Tag}\ \mathcal{P}(\ident{Variable}))$                       & a node              \\
p             & $\ident{Variable}\ ||\ (\ident{Tag}\ \mathcal{P}(\ident{Variable}))$ & a variable or node
\end{tabular}
\end{center}

A judgement has a type, which describes which contextual information is
expected and which results are returned by that judgement. The following table
list the possible judgement types:

\begin{center}
\begin{tabular}{l||l||l}
\bf type & \bf context & \bf results \\
\hline
module  &                       & \env, \heap           \\
resVars &                       & \resultVars           \\
bind    & \resultVars, \actuals & \env, \heap, \actuals \\
globals & \resultVars           & \env, \heap           \\
expr    & \resultVars, p        & \env, \heap, \actuals 
\end{tabular}
\end{center}

The derivation rules are declarative. The membership and subset relations found
in the prerequisites of derivation rules can be translated into computational
actions.  In the {\sc ResVar}$_{unit}$ rule defined in Figure
\ref{eq:resultvars}, for example, a value must be member of the rule result
value \resultVars{} which can be turned into a computation by adding the 
value to \resultVars{}. When \resultVars{} is passed as
context of a consequence, as in Figure \ref{eq:store} in the {\sc Store} rule,
a membership relation of the prerequisites translates to a selection from
\resultVars{}. When judgements return the same result variables, these results
are joined implicitly. An example is the {\sc Module} rule in Figure
\ref{eq:module} where, among others, \actuals{} is returned by both the bind
and the global judgements and passed as context to the bind judgement. This is
translated to a join of the resulting \actuals{}'s of both
judgements which is then passed to the bind judgment.

The top level derivation rule is given in Figure \ref{eq:module}. This
derivation rule does not use any contextual information and derives a set of
identifier equations \env{} and a set of store equations \heap{} from a whole
program by dividing the program into pieces and passing those pieces to rules
which derive equations of parts of the program. 

\begin{Figure}{Module}{eq:module}
\[
\mbox{\sc{Module}}:
{
\begin{array}{l}
\follows{resVars} \code{evalMapping}: \resultVars \\
\resultVars \follows{globals} \code{globalVars}: \env, \heap, \actuals \\
\resultVars, \actuals \follows{bind} \code{ binds }: \env, \heap, \actuals
\end{array}
\over
\follows{module} \Code {
\begin{array}{l}
\mathtt{module}\ n                            \\
\Bigskip \{globalVars\}                       \\
\Bigskip \{binds\}                            \\
\Bigskip \mathtt{evalmap}\ \{evalMapping\}    \\
\Bigskip \mathtt{applymap}\ \{applyMapping\}  \\
\end{array}
}: \env, \heap
}
\]
\end{Figure}

Besides the resulting equations, the derivation process uses two maps: the
result variables map (\resultVars), and the actual arguments map (\actuals).

The result variables map encodes whether a node represents a thunk or not. The
result variables map is generated from the evalmap, shown in Figure
\ref{eq:resultvars}, and does not depend on any contextual information. Each
tag in the evalmap is translated to an element in the result variable map: if
the tag maps to a |unit| element in the evalmap, the tag represent a value in
WHNF and maps to $\bot$ in the result variables map; if the tag maps to a
function identifier, the tag represents a thunk and the tag in the result
variables map maps to the same function identifier. The result variable map is
thus the same as the eval map, but with the |unit| written as $\bot$ and
without the node size information.

\begin{Figure}{Result variables}{eq:resultvars}
\[
\mbox{\sc{ResVars}}:
{
\follows{resVars} \code{ evalMap_1}: \resultVars; \dots; \follows{resVars} \code{ evalMap_n}: \resultVars
\over
\follows{resVars} \code{ evalMap_1; \dots; evalMap_n}: \resultVars
}
\]

\[
\mbox{\sc{ResVar$_{unit}$}}:
{
( T \mapsto \bot ) \in \resultVars
\over
\follows{resVars} \code{ (T, size) \rightarrow \grUnit{\!\!} }: \resultVars
}
\]

\[
\mbox{\sc{ResVar$_{var}$}}:
{
( T \mapsto v ) \in \resultVars
\over
\follows{resVars} \code{ (T, size) \rightarrow v }: \resultVars
}
\]
\end{Figure}

The actual arguments map is a mapping from function identifiers to all actual
parameters of calls to that function; both direct calls and thunks are stored
in this map. The actual arguments map is used by the derivation of equations of
the formal arguments which needs to join all their corresponding actual
arguments. The actual arguments map is created in Figure \ref{eq:store} in the
{\sc Store} rule and in Figure \ref{eq:functions} in the {\sc Call} rules. 

%TODO: explain ectual arguments map example
The actual arguments map of the running example is:

\[
\actuals{} = \{ (\ident{snd} \mapsto \ident{s4}), (\ident{mk} \mapsto \ident{s2}\ \ident{s3}) \}
\]

\noindent This actual arguments map records no arguments for the |Tuple| function, as
this function is not called, and no closures are created.

\subsection{Formal arguments}

An equation for the formal arguments of a function joins all its corresponding
actual arguments with the actuals selected by the apply variable (see Section
\ref{hpt:apply_var}). The derivation of such an equation is shown in Figure
\ref{eq:binds}. The actual arguments map (\actuals) is passed as context to
this rule. All actuals of a function are selected from this actual arguments
map. This results in a set of actuals, refered to by $args_i$, for the formal
argument $a_i$. Actual arguments passed by the use of |apply| are selected from
the apply variable. The selected values from the apply variable are then joined
with the join of all actual arguments.

Note that the actual arguments map occurs both as context and as result of the
derivation rule. This is best explained by looking at the {\sc bind} rule as a
computation. The computation described by the rule result in an actual
arguments map which hold only the actuals of a single binding. This map is
passed upwards so that the all actual arguments can be joined at the top level.
This complete actual arguments map is then passed down again (as context) and
can be used to find all actual arguments.

\begin{Figure}{Bindings}{eq:binds}
\[
\mbox{\sc Bind}:
{
\begin{array}{l}

\resultVars, foo \follows{expr} \code{ e }: \env, \heap, \actuals \\

\left\{
\begin{array}{l}
a_1 = \bigjoin args_1 \join \grSelect{\mathbf{apply}}{Ffoo}{1} \\
\dots \\
a_n = \bigjoin args_n \join \grSelect{\mathbf{apply}}{Ffoo}{n} \\
\end{array}
\right\} \subseteq \env \\

(\ident{foo} \mapsto \ident{args}_1 \dots \ident{args}_n) \subseteq \actuals

\end{array}
\over
\resultVars, \actuals \follows{bind} \code{ foo\ a_1\ \dots\ a_n = e }: \env, \heap, \actuals
}
\]

\[
\mbox{\sc Binds}:
{
\resultVars, \actuals \follows{bind} \code{ b_1 }: \env, \heap, \actuals; 
\dots; 
\resultVars, \actuals \follows{bind} \code{ b_n }: \env, \heap, \actuals 
\over
\resultVars, \actuals \follows{bind} \code{ b_1; \dots; b_n }: \env, \heap, \actuals
}
\]
\end{Figure}

\subsection{Store statements}

Store statements come in two flavors. The store statements of the global
variables and the store statements in the bodies of functions. Both are treated
the same in HPT.

Figure \ref{eq:store} shows the derivation rules. The {\sc GlobalVar} rule
calls the {\sc Store} rule for each global variable and returns the derived
\env{} and \heap{} equations as well as the found actual arguments. The {\sc
Store} rule is the first rule of the judgement type \emph{expr}. All the rules
on GRIN expression are of the expr judgement type. These rules need a result
variable map and a \emph{target pattern}. The target pattern denotes a variable
or a pattern with multiple variables to which the identifier equations must be
bound. These rules return the triple \env{}, \heap{}, and \actuals{}.

The result of a store statement is an identifier equation and a heap equation. Each
store statement is given an unique location ($loc$) in the abstract heap. The
identifier equation binds the target variable to this unique location. The
abstract heap equation consist of an abstract node joined by a result variable.
The abstract node is the abstract variant of the node stored by the store
statement. In an actual run of the program the node on the heap might be
updated. This only happens when the node represents a thunk: the node will be
overwritten with the result of the function call when the thunk is evaluated.
In the analysis this behaviour is accomplished by joining the result variable
of that function call with the node stored by the store statement.

\begin{Figure}{Store statements}{eq:store}
\[
\mbox{\sc GlobalVar}:
{
\begin{array}{l}
\resultVars, v_1 \follows{expr} \code{ \grStore[loc_1]{\grNode[1]{T}{a}} }: \env, \heap, \actuals \\
\dots \\
\resultVars, v_m \follows{expr} \code{ \grStore[loc_m]{\grNode[m]{T}{a}} }: \env, \heap, \actuals
\end{array}
\over
\resultVars \follows{globals} \Code{
\begin{array}{l}
v_1 \leftarrow \grStore[loc_1]{\grNode[1]{T}{a}} \\ 
\dots \\
v_m \leftarrow \grStore[loc_m]{\grNode[m]{T}{a}}
\end{array}
}: \env, \heap, \actuals
}
\]

\[
\mbox{\sc Store}:
{
\begin{array}{l}
 av_1 = \hptAV{a_1} \\
 \dots \\
 av_n = \hptAV{a_n} \\
(T \mapsto rv) \in \resultVars \\
(\ident{rv} \mapsto \ident{av}_1 \dots \ident{av}_n) \in \actuals \\
v = \{loc\} \in \env \\
loc = \grNode{T}{av} \join rv \in \heap
\end{array}
\over
\resultVars, v \follows{expr} \code{ \grStore[loc]{\grNode{T}{a}} }: \env, \heap, \actuals
}
\]
\end{Figure}


\subsection{Function calls}
\label{functioncalls}

Derivation of equations of a function call is shown in Figure
\ref{eq:functions}. While the function call only modifies \env{} and
\actuals{}, the \heap{} is also returned. The rules leave out $\emptyset
\subseteq \heap$.

The result of a function is stored in its result variable (see Section
\ref{hpt:result}).  The result of a function call is simply a copy of that
value. The {\sc Call}$_{node}$ rule gets a target pattern. For each variable in
this target pattern it selects a field from the result variable.

Two functions, |apply| and |eval| are treated differently. The |apply| function
is treated different as it adds information to the |apply| variable beside
computing the result of the equation. The |eval| function is treated different
because all other functions call |eval| to evaluate their arguments and thus
all heap locations are accessed by |eval|. This means that if |eval| would be
treated as call insensitive, like other functions, HPT would result in the
estimation that all heap locations of the program are a possible argument to
|eval|, which is as bad as not analysing |eval| at all.

HPT uses two special equations to analyse |eval| and |apply|. These equations
have the appropriate names $apply$ and $eval$. %TODO: explain why not select/join

\begin{Figure}{Function calls}{eq:functions}
\[
\mbox{\sc{Eval}}:
{
v = \grEval{w} \in \env
\over
\resultVars, v \follows{expr} \code{ \grEval{w} }: \env, \heap, \actuals
}
\]

\[
\mbox{\sc{Apply}}:
{
v = \grApply{w}{u} \in \env
\over
\resultVars, v \follows{expr} \code{ \grApply{w}{u} }: \env, \heap, \actuals
}
\]

\[
\mbox{\sc{Call$_{node}$}}:
{
\left\{
\begin{array}{lll}
a_1 & = & \grSelect{foo}{T}{1} \\
\dots \\
a_n & = & \grSelect{foo}{T}{n} \\
\end{array}
\right\} \subseteq \env; (\ident{foo} \mapsto x_1 \dots x_n) \in \actuals
\over
\resultVars, \grNode{T}{a} \follows{expr} \code{|foo x1 ... xn|}: \env, \heap, \actuals
}
\]

\[
\mbox{\sc{Call$_{var}$}}:
{
v = \ident{foo} \in \env; (\ident{foo} \mapsto x_1 \dots x_n) \in \actuals
\over
\resultVars, v \follows{expr} \code{|foo x1 ... xn|}: \env, \heap, \actuals
}
\]
\end{Figure}

\subsubsection{Eval}

The real eval function has one argument: a pointer. Eval fetches the contents
of this pointer from the heap and, when the fetched node represents a thunk,
calls the corresponding function and update the node with the result.

However, the abstract heap equations of the store statements already take into
account the update after the evaluation of a thunk. The abstract eval function
can therefore simply fetch the contents of its argument from the abstract heap.
This abstract location contain the thunk and the result of the function call.
However, thunks will never be returned by the eval function, thus the abstract
eval equation filters them from the result.

\subsubsection{Apply}

For each apply call the abstract apply equation returns a node representing the
result. Such a node can be one of the following:

\begin{itemize}

\item A P-node with the fields containing the arguments already applied with
the newly applied argument appended. This P-node represent a partial
application which takes one argument less than the P-node passed to apply.

\item The result of a function call when the newly applied arguments happens to
be the last argument of the application.

\end{itemize}

Each time the apply equation is calculated a node is added to the |apply|
variable. As explained in Section \ref{hpt:apply_var} this node stores the
correlation between the function represented by the P-node passed to apply and
the actual arguments of that function.

The actual |apply| equation can take a list of arguments which should be
applied. The arguments are applies one by one as described above.


\subsection{Foreign function interface}

The foreign function interface (ffi) statement is used for two different
purposes: the implementation of primitives, and communication to the outside
world.  Primitives are known to the compiler. The equations for primitives are
the nodes which might be returned by them. E.g., the |primEqInt| primitive
returns |(#CTrue)| or |(#CFalse)|.

Communication to the outside world is a bit more problematic: there is no
information availible on what these external functions return. The type
information of Haskell can give us a set of possible data constructors, and
thus tags. But in the current implementation the ffi statements are limited to
primitives or functions which return a basic integer.

The derived equations for ffi statements are shown in Figure \ref{eq:ffi}. The
function $\hptAV{\dots}$ is used to represent the lookup of which nodes the
given primitive might return.

\begin{Figure}{Foreign function interface}{eq:ffi}
\[
\mbox{\sc{FFI$_{prim}$}}:
{
v = \hptAV{primFoo} \in \env
\over
\resultVars, v \follows{expr} \code{|ffi primFoo x1 ... xn|}, \env, \heap, \actuals
}
\]

\[
\mbox{\sc{FFI$_{external}$}}:
{
v = \avBAS \in \env
\over
\resultVars, v \follows{expr} \code{|ffi foo x1 ... xn|}, \env, \heap, \actuals
}
\]
\end{Figure}


\subsection{Control flow}

Deriving equations for control flow is shown in Figure \ref{eq:controlflow}.
There are two types of control flow expressions: the sequence operator, and the
case statement. The sequence operator does not generate equations by itself.
It merely passes the pattern defined by it to the statement which should bind
its result to the variables from that pattern.

The case statement binds each variable of a pattern to the value selected from
the scrutinized variable. For example, the first field of the first alternative
selects the first field of the node with tag $T_1$ from the scrutinized
variable $w$. The result of each alternative is joined to the variable
after a case. To be able to express the join of each alternative as an equation
in HPT, all alternatives must end with an |unit| statement which returns a
single variable. This is enforced by a transformation before deriving the
equations.

\begin{Figure}{Flow control}{eq:controlflow}
\[
\mbox{\sc{Case}}:
{
\left\{
\begin{array}{lll}
a_{11} & = & \grSelect{w}{T_1}{1} \\
\dots \\
a_{1n} & = & \grSelect{w}{T_1}{n} \\
\dots \\
a_{m1} & = & \grSelect{w}{T_m}{1} \\
\dots \\
a_{mn} & = & \grSelect{w}{T_m}{n} \\
v      & = & \bigjoin \{x_1 \dots x_m \}
\end{array}
\right\} \subseteq \env;
\begin{array}[t]{l}
	\resultVars, x_1 \follows{expr} \code{e_1}: \env, \heap, \actuals\\
	\dots \\
	\resultVars, x_m \follows{expr} \code{e_m}: \env, \heap, \actuals
\end{array}
\over
\resultVars, v \follows{expr} \Code{
	\begin{array}{l}
	\mathtt{case}\ w\ \mathtt{of} \\
		\Bigskip \grNode[1]{T}{a} \rightarrow \\
			\Bigskip \Bigskip  e_1 \grSeq{x_1} \grUnit{x_1} \\
		\Bigskip \dots \\
		\Bigskip \grNode[m]{T}{a} \rightarrow \\
			\Bigskip \Bigskip  e_m \grSeq{x_m} \grUnit{x_m}\\
	\end{array}
}: \env, \heap, \actuals
}
\]

\[
\mbox{\sc{Seq}}:
{
\resultVars, p \follows{expr} \code{ e_1 }: \env, \heap, \actuals;\\
\resultVars, q \follows{expr} \code{ e_2 }: \env, \heap, \actuals
\over
\resultVars, q \follows{expr} \code{ e_1 \grSeq{p} e_2 }: \env, \heap, \actuals
}
\]
\end{Figure}

 
\subsection{Unit statements}

The derivation of an unit statement comes in four variants: the target pattern
can be a node or a variable and the argument of the unit statement can be a
node or a variable. These variants are shown in Figure \ref{eq:unit}. A node
unit statement which matches a node target pattern each field variable of the
pattern is bound to the value of the node in the unit statement. The tag of the
nodes in the target pattern and the unit statement is assumed to be the same.
When a node unit statement matches a variable target pattern, this variable is
bound to the complete node. 

A variable unit statement which matches a node target pattern is comparable to
a case statement with a single alternative. Each field of the pattern selects
the corresponding field from the nodes bound to the variable in the unit
statement. When a variable unit statement matches a variable target pattern,
the variables become aliases for each other thereby holding the same value.

\begin{Figure}{Unit statement}{eq:unit}
\[ 
\mbox{\sc{Unit$_{node \rightarrow node}$}}:
{
\left\{
\begin{array}{lll}
a'_1 & = & \hptAV{a_1} \\
\dots \\
a'_n & = & \hptAV{a_n} \\
\end{array}
\right\} \subseteq \env
\over 
\resultVars, \grNode{T}{a'} \follows{expr} \code{ \grUnit{\grNode{T}{a}} }: \env, \heap, \actuals
}
\]

\[ 
\mbox{\sc{Unit$_{node \rightarrow var}$}}:
{
v = \hptAV{\grNode{T}{a}} \in \env
\over
\resultVars, v \follows{expr} \code{ \grUnit{\grNode{T}{a}} }: \env, \heap, \actuals
}
\]

\[ 
\mbox{\sc{Unit$_{var \rightarrow node}$}}:
{
\left\{
\begin{array}{lll}
a_1 & = & \hptSelect{\hptAV{v}}{T}{1} \\
\dots \\
a_n & = & \hptSelect{\hptAV{v}}{T}{n} \\
\end{array}
\right\} \subseteq \env
\over
\resultVars, \grNode{T}{a} \follows{expr} \code{\grUnit{v}}: \env, \heap, \actuals
}
\]

\[ 
\mbox{\sc{Unit$_{var \rightarrow var}$}}:
{
v = \hptAV{w} \in \env
\over
\resultVars, v \follows{expr} \code{\grUnit{w}}: \env, \heap, \actuals
}
\]
\end{Figure}


\subsection{Normalizing}
\label{hpt:normalizing}

Not all combinations of patterns and GRIN constructs are covered. For example,
the case statement expect expects every alternative to end with a unit
statement which returns a single variable. And the function rules for |eval|
and |apply| are only defined for a singe variable as target pattern. A
transformation is applied on the program which add extra unit statements so
that the derivation rules defined in this section cover all possible constructs
of valid GRIN input.

\section{Solving the equations}

The final step of HPT is to solve the derived equations. This is done by a
fixpoint computation. A fixpoint computation is an iterative process. Each
iteration the values of the equations are calculated based on the values of the
previous iteration. Once all equations hold the same values as the previous
iteration, all further iterations are guaranteed to result in the same values.
At this point all equations hold.

To start the first iteration, all variables and abstract heap locations are
bound to the value bottom ($\bot$). Each time an equation refers to some
variable the value of the previous iteration is used. For example, the equation
$Tuple \mapsto \avTag{CTuple}[x1, x2]$ results in the value
$\avTag{CTuple}[\bot, \bot]$. The new values are compared to the values of the
previous iteration, if any value is changed a new iteration is started and the
values of the equations are calculated on the current values.

The current implementation does not always use the values of the previous
iteration, instead it uses the value currently recorded. If the equation is not
yet calculated in the current iteration, the value of the previous iteration is
used, once it is calculated, that value is used to calculated the other
equations in the current equation.

%Other optimization possibilities are based on dependency analysis on the
%equations. Dependency information can limit the set of equations which must be
%recomputed each iteration, resulting in less work. Another optimization
%possibility is to use the dependency information to change the order in which
%the equations are solved. An equation reaches faster its fixed point if all its
%dependencies are calculated before the equation itself is calculated. 
